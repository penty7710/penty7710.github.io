

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="努力最坏的结果不过是大器晚成">
  <meta name="author" content="pty">
  <meta name="keywords" content="">
  
  <title>刷题记录 - Pety&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"placement":"right"},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"follow_dnt":true}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Pety's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pety</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/message.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="刷题记录">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-03-25 14:28" pubdate>
        March 25, 2023 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">刷题记录</h1>
            
            <div class="markdown-body">
              <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">求根节点到叶节点数字之和</a></h3><blockquote>
<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>
<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>
<p>叶节点 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>输入：root = [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 = 495 + 491 + 40 = 1026</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>类似于二叉树的层序遍历，利用队列先进先出的特点将二叉树的结点入队，在加入队列的时候，还需要将结点的值更新为父节点的值*10加上当前节点的值，如果一个结点已经是叶子结点了（没有左右子节点），就将他的值加到结果中。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//队列</span><br>        LinkedList&lt;TreeNode&gt; path = <span class="hljs-keyword">new</span> LinkedList();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        path.add(root);<br>        <span class="hljs-keyword">while</span>(path.size()!=<span class="hljs-number">0</span>)&#123;<br>            TreeNode p = path.poll();<br>            <span class="hljs-comment">//如果已经是叶子结点，将值计入到结果</span><br>            <span class="hljs-keyword">if</span>(p.left == <span class="hljs-keyword">null</span> &amp;&amp; p.right == <span class="hljs-keyword">null</span>)&#123;<br>                result+= p.val;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>			<span class="hljs-comment">//将左子节点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(p.left != <span class="hljs-keyword">null</span>)&#123;<br>                p.left.val += p.val*<span class="hljs-number">10</span>;<br>                path.add(p.left);<br>            &#125;<br>			<span class="hljs-comment">//将右子节点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(p.right != <span class="hljs-keyword">null</span>)&#123;<br>                p.right.val +=p.val*<span class="hljs-number">10</span>;<br>                path.add(p.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="删除最短的子数组使剩余数组有序"><a href="#删除最短的子数组使剩余数组有序" class="headerlink" title="删除最短的子数组使剩余数组有序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">删除最短的子数组使剩余数组有序</a></h3><blockquote>
<p>给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。</p>
<p>一个子数组指的是原数组中连续的一个子序列。</p>
<p>请你返回满足题目要求的最短子数组的长度。</p>
<p><strong>示例 1：</strong></p>
<p>输入：arr = [1,2,3,10,4,2,3,5]<br>输出：3<br>解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。<br>另一个正确的解为删除子数组 [3,10,4] 。<br><strong>示例 2：</strong></p>
<p>输入：arr = [5,4,3,2,1]<br>输出：4<br>解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。<br><strong>示例 3：</strong></p>
<p>输入：arr = [1,2,3]<br>输出：0<br>解释：数组已经是非递减的了，我们不需要删除任何元素。<br><strong>示例 4：</strong></p>
<p>输入：arr = [1]<br>输出：0</p>
</blockquote>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfShortestSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = arr.length;<br>        <span class="hljs-keyword">int</span> right = len-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//找到最长的非递减后缀</span><br>        <span class="hljs-keyword">while</span>(right &gt;<span class="hljs-number">0</span> &amp;&amp; arr[right-<span class="hljs-number">1</span>] &lt;= arr[right])&#123;<br>            right--;<br>        &#125;<br>		<br>        <span class="hljs-comment">//如果right == 0，说明整个数组都是非递减的，直接返回0</span><br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到最长的非递减后缀，说明此时前面的都可以删除了，所以将min初始化为right。</span><br>        <span class="hljs-keyword">int</span> min = right;<br>        <span class="hljs-comment">//双指针，收缩窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;left ==<span class="hljs-number">0</span> || arr[left-<span class="hljs-number">1</span>] &lt;= arr[left];left++)&#123;<br>            <span class="hljs-keyword">while</span>(right &lt;len &amp;&amp; arr[left] &gt; arr[right])&#123;<br>                right++;<br>            &#125;<br>            min = Math.min(min,right-left-<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min;<br><br>    &#125;<br>&#125;         <br></code></pre></td></tr></table></figure>



<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h3><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4</p>
<p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p>示例 2：</p>
<p>输入：nums = [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>dp[i] 的值代表 <code>nums</code> 以 nums[i] 结尾的最长子序列长度。当nums[i] &gt; nums[j] 时，nums[i]可以接在nums[j]的后面，此时dp[i] 就等于dp[j]+1。这个1就是nums[i]本身。</p>
<p>因此转移方程为<code> dp[i] = Math.max(dp[i],dp[j]+1)</code></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> [] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-comment">//因为每一个元素本身就是一个递增序列，所以dp[i]初始化为1</span><br>            dp[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                    dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            max = Math.max(dp[i],max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="无矛盾的最佳球队"><a href="#无矛盾的最佳球队" class="headerlink" title="无矛盾的最佳球队"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-team-with-no-conflicts/">无矛盾的最佳球队</a></h3><blockquote>
<p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。</p>
<p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p>
<p>给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。</p>
<p><strong>示例 1：</strong></p>
<p>输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]<br>输出：34<br>解释：你可以选中所有球员。<br><strong>示例 2：</strong></p>
<p>输入：scores = [4,5,6,5], ages = [2,1,2,1]<br>输出：16<br>解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。<br><strong>示例 3：</strong></p>
<p>输入：scores = [1,2,3,5], ages = [8,9,10,1]<br>输出：6<br>解释：最佳的选择是前 3 名球员。</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>与最长递增子序列类似，在保证年龄不小于自己的情况下，找出分数的最长递增序列，最后对所有的分数进行求和。</p>
<p>我们可以对年龄和分数联合进行一个排序，在保证年龄升序的情况下，对分数也进行升序排序处理。此时排在后面的年龄一定不小于排在前面的人的年龄，在这种情况下，我们可以只需要求出分数的最长递增序列。</p>
<p>dp[i] 的值表示以i结尾的符合要求的球员分数。当<code>a[j][1]</code> &lt;= <code>a[i][1]</code>时，说明此时是符合要求的，即<code>a[i]</code>球员是可以被选择的==因为i 在j的后面，因此i的年龄一定不小于j，且分数还&gt;=j==,所以转移方程为<code>dp[i] = Math.max(dp[i],dp[j]+a[i][1])</code></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bestTeamScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] scores, <span class="hljs-keyword">int</span>[] ages)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = scores.length;<br>        <span class="hljs-keyword">int</span> [][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];<br>		<br>        <span class="hljs-comment">//将分数和年龄组合在一起</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            a[i][<span class="hljs-number">0</span>] = ages[i];<br>            a[i][<span class="hljs-number">1</span>] = scores[i];<br>        &#125;<br><br>        <span class="hljs-comment">//先按照年龄升序排序，再按照成绩升序排序</span><br>        Arrays.sort(a,((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] != o2[<span class="hljs-number">0</span>] ? o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>] : o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>];<br>        &#125;));<br><br>        <span class="hljs-keyword">int</span> [] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">int</span> max =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-comment">//每个元素自身可以被选择，因此dp[i]初始化为a[i][1]</span><br>            dp[i] = a[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[j][<span class="hljs-number">1</span>] &lt;= a[i][<span class="hljs-number">1</span>])&#123;<br>                    dp[i] = Math.max(dp[i],a[i][<span class="hljs-number">1</span>]+dp[j]);<br>                &#125;<br>            &#125;<br>            max = Math.max(dp[i],max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="常规题目"><a href="#常规题目" class="headerlink" title="常规题目"></a>常规题目</h2><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/">字符串相加</a></h3><blockquote>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<p><strong>示例 1：</strong></p>
<p>输入：num1 = “11”, num2 = “123”<br>输出：”134”<br><strong>示例 2：</strong></p>
<p>输入：num1 = “456”, num2 = “77”<br>输出：”533”<br><strong>示例 3：</strong></p>
<p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>由题意因为数字可能很大，所以不能够直接对数字进行相加，可以取出数字的每一位，逐个相加，添加到字符串末尾，最后反转字符串即可。注意需要保留进位，最后还需要判断进位标志是否为0，如果不为0，还需要添加到字符串末尾。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> len1 = num1.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len2 = num2.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(len1&gt;=<span class="hljs-number">0</span> || len2&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">char</span> c1 = len1&lt;<span class="hljs-number">0</span>?<span class="hljs-string">&#x27;0&#x27;</span>:num1.charAt(len1--);<br>            <span class="hljs-keyword">char</span> c2 = len2&lt;<span class="hljs-number">0</span>?<span class="hljs-string">&#x27;0&#x27;</span>:num2.charAt(len2--);<br><br>            <span class="hljs-keyword">int</span> temp = c1-<span class="hljs-string">&#x27;0&#x27;</span>+c2-<span class="hljs-string">&#x27;0&#x27;</span>+count;<br>            count = temp/<span class="hljs-number">10</span>;<br>            sb.append(temp%<span class="hljs-number">10</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(count != <span class="hljs-number">0</span>)&#123;<br>            sb.append(count);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/multiply-strings/">字符串相乘</a></h3><blockquote>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br><strong>示例 2:</strong></p>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>因为返回的乘积也需要时字符串形式，因此返回值会很大，所以不能简单的将num1和num2转换成数字然后求乘积，这样会超出范围。可以求出乘数和被乘数的每一位的积，然后按照竖式相加求和。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-comment">//如果num1和num2有一个为0，直接返回0</span><br>        <span class="hljs-keyword">if</span>(num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> len = num2.length();<br>        <span class="hljs-keyword">int</span> len1 = num1.length();<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//用字符串数组保存被乘数的每一位和乘数的积</span><br>        String [] str = <span class="hljs-keyword">new</span> String[len];<br>        <span class="hljs-comment">//遍历num2的每一位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">int</span> t = i;<br>            <span class="hljs-comment">//前置补0</span><br>            <span class="hljs-keyword">while</span>(t-- &gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">char</span> c = num2.charAt(len-<span class="hljs-number">1</span>-i);<br>            <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>			<span class="hljs-comment">//遍历num1的每一位，从最后一位开始，模拟乘法</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=len1-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">char</span> a = num1.charAt(j);<br>                <span class="hljs-keyword">int</span> temp = (c-<span class="hljs-string">&#x27;0&#x27;</span>)*(a-<span class="hljs-string">&#x27;0&#x27;</span>)+count;<br>                count = temp/<span class="hljs-number">10</span>;<br>                sb.append(temp%<span class="hljs-number">10</span>);<br>            &#125;<br>            <span class="hljs-comment">//如果count！=0，说明进位了，把这个也需要加上</span><br>            <span class="hljs-keyword">if</span>(count!=<span class="hljs-number">0</span>)&#123;<br>                sb.append(count);<br>            &#125;<br>            str[i] = sb.toString();<br>        &#125;<br><br>        <span class="hljs-comment">//求出字符串中最长的长度。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            max = Math.max(max,str[i].length());<br>        &#125;<br>		<br>        <span class="hljs-comment">//后置补0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">int</span> size = str[i].length();<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(str[i]);<br>            <span class="hljs-keyword">while</span>(max-size&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;0&quot;</span>);<br>                size++;<br>            &#125;<br>            str[i] = sb.toString();<br>        &#125;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//遍历，求和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;max;i++)&#123;<br>            <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;<br>                sum+=str[j].charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            sum+=count;<br>            count = sum/<span class="hljs-number">10</span>;<br>            sb.append(sum%<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count!=<span class="hljs-number">0</span>)&#123;<br>            sb.append(count);<br>         &#125;<br>        <span class="hljs-comment">//反转，因为之前个位放在了首位</span><br>        <span class="hljs-keyword">return</span> sb.reverse().toString();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>以上代码写的太过于臃肿，看了其他人写的以后，发现可以和字符串相加一样。不必先求出被乘数的每一位和乘数的积，在求出一个积以后，就进行相加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//初始字符串</span><br>        String str = <span class="hljs-string">&quot;0&quot;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=num2.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            StringBuilder sb =<span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">int</span> temp = num2.length()-<span class="hljs-number">1</span>-i;<br>            <span class="hljs-keyword">while</span>(temp--&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=num1.length()-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">int</span> t  = (num2.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>)*(num1.charAt(j)-<span class="hljs-string">&#x27;0&#x27;</span>)+count;<br>                count = t/<span class="hljs-number">10</span>;<br>                sb.append(t%<span class="hljs-number">10</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count !=<span class="hljs-number">0</span>) &#123;<br>                sb.append(count);<br>            &#125;<br>            <span class="hljs-comment">//将被乘数的每一位和乘数的乘积直接相加，不需要使用数组保存，最后再相加</span><br>            str = addStrings(str,sb.reverse().toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> len1 = num1.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len2 = num2.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br>		<br>        <br>        <span class="hljs-keyword">while</span>(len1&gt;=<span class="hljs-number">0</span> || len2&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//当索引越界以后直接赋值为0，不需要再去找到最大的字符串长度</span><br>            <span class="hljs-keyword">char</span> c1 = len1&lt;<span class="hljs-number">0</span>?<span class="hljs-string">&#x27;0&#x27;</span>:num1.charAt(len1--);<br>            <span class="hljs-keyword">char</span> c2 = len2&lt;<span class="hljs-number">0</span>?<span class="hljs-string">&#x27;0&#x27;</span>:num2.charAt(len2--);<br><br>            <span class="hljs-keyword">int</span> temp = c1-<span class="hljs-string">&#x27;0&#x27;</span>+c2-<span class="hljs-string">&#x27;0&#x27;</span>+count;<br>            count = temp/<span class="hljs-number">10</span>;<br>            sb.append(temp%<span class="hljs-number">10</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(count != <span class="hljs-number">0</span>)&#123;<br>            sb.append(count);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="等差子数组"><a href="#等差子数组" class="headerlink" title="等差子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/arithmetic-subarrays/">等差子数组</a></h3><blockquote>
<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列。更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] == s[1] - s[0] 都成立。</p>
<p>例如，下面这些都是 等差数列 ：</p>
<p>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9<br>下面的数列 不是等差数列 ：</p>
<p>1, 1, 2, 5, 7<br>给你一个由 n 个整数组成的数组 nums，和两个由 m 个整数组成的数组 l 和 r，后两个数组表示 m 组范围查询，其中第 i 个查询对应范围 [l[i], r[i]] 。所有数组的下标都是 从 0 开始 的。</p>
<p>返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], … , nums[r[i]] 可以 重新排列 形成 等差数列 ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。</p>
<p><strong>示例 1：</strong></p>
<p>输入：nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]<br>输出：[true,false,true]<br>解释：<br>第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。<br>第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。<br>第 2 个查询，对应子数组 [5,9,3,7] 。可以重新排列为等差数列 [3,5,7,9] 。<br><strong>示例 2：</strong></p>
<p>输入：nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]<br>输出：[false,true,false,false,true,true]</p>
</blockquote>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>根据题意，<strong>会将nums数组按照l和r两个数组数组中的值进行分隔，然后判断分隔后的数组是否能够组成一个等差数组。</strong>而等差数组是有序的，要么升序要么降序，然后求解相邻元素之间的差值是否一样，根据示例可以发现分割后的元素并不是有序的，因此<strong>需要将分隔后的元素进行排序，然后比较相邻元素间的差值即可。</strong></p>
<p>期间使用到了一个函数：<code>Arrays.copyOfRange()</code>函数，这个函数用于将数组拷贝到另一个数组，包含三个参数：第一个是拷贝的原数组，第二个参数是拷贝的起始位置from，第三个是拷贝的结束位置to，会生成一个拷贝后的新数组并返回，需要注意的是，拷贝的新数组的长度为：<code>to-from</code>,to对应的位置不会被包含进去。==[from,to)== [1,2,0,0,0,0] 拷贝0~2后得到[1,2]。</p>
<p>另一个类似的函数：<code>Arrays.copyOf()</code>,也是用于将数组拷贝到另一个数组，返回一个新生成的数组。他有两个参数：第一个拷贝的原数组，第二个拷贝的长度newLength，如果newLength没有超过原数组的长度，只会拷贝部分元素，如果超过了，就会创建一个长度为newLength的新数组，然后将原数组的元素全部拷贝进去，多出来的其他位置为该数组类型的默认值。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">checkArithmeticSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] l, <span class="hljs-keyword">int</span>[] r)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = l.length;<br>        List&lt;Boolean&gt; list = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-comment">//对数组进行拷贝,注意不包含结束位置，因此需要+1</span><br>           <span class="hljs-keyword">int</span> [] a = Arrays.copyOfRange(nums,l[i],r[i]+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//对数组进行排序</span><br>           Arrays.sort(a);<br>           list.add(checkArithmetic(a));<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>	<span class="hljs-comment">//检查数组是否为等差数组</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkArithmetic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[<span class="hljs-number">1</span>]-nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]-nums[i-<span class="hljs-number">1</span>]!=temp)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="第三大的数"><a href="#第三大的数" class="headerlink" title="第三大的数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/third-maximum-number/">第三大的数</a></h3><blockquote>
<p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p>
<p><strong>示例 1：</strong></p>
<p>输入：[3, 2, 1]<br>输出：1<br>解释：第三大的数是 1 。<br><strong>示例 2：</strong></p>
<p>输入：[1, 2]<br>输出：2<br>解释：第三大的数不存在, 所以返回最大的数 2 。<br><strong>示例 3：</strong></p>
<p>输入：[2, 2, 3, 1]<br>输出：1<br>解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。<br>此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。</p>
</blockquote>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>这是一个简单题，可以直接对数组进行排序，然后找到第三大的值，这样时间复杂度是排序算法的复杂度。如果想要实现*O(N)*的时间复杂度，可以设置三个变量，分别表示第一大，第二大，第三大的值，遍历数组，依次更新第一大、第二大、第三大的值。注意：题目提供的范围是-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1，也就是int型能够表示的最大的范围，并且给的样例中有-2<sup>31</sup> ,所以这里将第一大，第二大，第三大的值初始化为long的最小值。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">thirdMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//第一大</span><br>        <span class="hljs-keyword">long</span> min1 = Long.MIN_VALUE;<br>        <span class="hljs-comment">//第二大</span><br>        <span class="hljs-keyword">long</span> min2 = Long.MIN_VALUE;<br>        <span class="hljs-comment">//第三大</span><br>        <span class="hljs-keyword">long</span> min3 = Long.MIN_VALUE;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> temp = nums[i];<br><br>            <span class="hljs-keyword">if</span>(temp &gt;min1)&#123;<br>                min3 = min2;<br>                min2 = min1;<br>                min1 = temp;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;min2 &amp;&amp; min1&gt;temp)&#123;<br>                min3 = min2;<br>                min2 = temp;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &gt;min3 &amp;&amp;min2&gt;temp)&#123;<br>                min3 = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//方法的返回值是int型，这里需要做一个转型</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (min3 ==Long.MIN_VALUE?min1:min3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="力扣周赛"><a href="#力扣周赛" class="headerlink" title="力扣周赛"></a>力扣周赛</h2><h3 id="合法分割的最小下标"><a href="#合法分割的最小下标" class="headerlink" title="合法分割的最小下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-index-of-a-valid-split/">合法分割的最小下标</a></h3><blockquote>
<p>如果元素 <code>x</code> 在长度为 <code>m</code> 的整数数组 <code>arr</code> 中满足 <code>freq(x) * 2 &gt; m</code> ，那么我们称<code>x</code> 是 <strong>支配元素</strong> 。其中 <code>freq(x)</code> 是 <code>x</code> 在数组 <code>arr</code> 中出现的次数。注意，根据这个定义，数组 <code>arr</code><strong>最多</strong>只会有<strong>一个</strong>支配元素。</p>
<p>给你一个下标从<strong>0</strong>开始长度为 <code>n</code> 的整数数组 <code>nums</code> ，数据保证它含有一个支配元素。</p>
<p>你需要在下标 i 处将 nums 分割成两个数组 <code>nums[0, ..., i]</code> 和 <code>nums[i + 1, ..., n - 1]</code> ，如果一个分割满足以下条件，我们称它是 合法 的：</p>
<ul>
<li><code>0 &lt;= i &lt; n - 1</code></li>
<li><code>nums[0, ..., i]</code> 和 <code>nums[i + 1, ..., n - 1]</code> 的支配元素相同。</li>
</ul>
<p>这里， <code>nums[i, ..., j]</code> 表示 <code>nums</code> 的一个子数组，它开始于下标 <code>i</code> ，结束于下标 <code>j</code>，两个端点都包含在子数组内。特别地，如果 <code>j &lt; i</code> ，那么 <code>nums[i, ..., j]</code> 表示一个空数组。</p>
<p>请你返回一个 <strong>合法分割</strong> 的 <strong>最小</strong> 下标。如果合法分割不存在，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入</strong>：nums = [1,2,2,2]<br><strong>输出</strong>：2<br><strong>解释</strong>：我们将数组在下标 2 处分割，得到 [1,2,2] 和 [2] 。<br>数组 [1,2,2] 中，元素 2 是支配元素，因为它在数组中出现了 2 次，且 2 * 2 &gt; 3 。<br>数组 [2] 中，元素 2 是支配元素，因为它在数组中出现了 1 次，且 1 * 2 &gt; 1 。<br>两个数组 [1,2,2] 和 [2] 都有与 nums 一样的支配元素，所以这是一个合法分割。<br>下标 2 是合法分割中的最小下标。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入</strong>：nums = [2,1,3,1,1,1,7,1,2,1]<br><strong>输出</strong>：4<br><strong>解释</strong>：我们将数组在下标 4 处分割，得到 [2,1,3,1,1] 和 [1,7,1,2,1] 。<br>数组 [2,1,3,1,1] 中，元素 1 是支配元素，因为它在数组中出现了 3 次，且 3 * 2 &gt; 5 。<br>数组 [1,7,1,2,1] 中，元素 1 是支配元素，因为它在数组中出现了 3 次，且 3 * 2 &gt; 5 。<br>两个数组 [2,1,3,1,1] 和 [1,7,1,2,1] 都有与 nums 一样的支配元素，所以这是一个合法分割。<br>下标 4 是所有合法分割中的最小下标。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入</strong>：nums = [3,3,3,3,7,2,2]<br><strong>输出</strong>：-1<br><strong>解释</strong>：没有合法分割。</p>
</blockquote>
<p>看到这个题目的时候，我想到的是先求出未分隔之前的支配元素，然后遍历每一个下标，根据下标分成前后两个数组，在分别求出他们的支配数，看是否一样，如果一样就返回支配数，和未分割之前的比较，相同直接返回。</p>
<p>于是有了下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumIndex</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//将集合转变成数组</span><br>        <span class="hljs-keyword">int</span> [] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [nums.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>            a[i] = nums.get(i);<br>        &#125;<br>        <br>        <span class="hljs-comment">//未分割前的支配数</span><br>        <span class="hljs-keyword">int</span> temp = fenpeiNum(a);<br>        <br>        <span class="hljs-comment">//遍历下标，找到最小下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">int</span>  t = f(nums,i,a.length);<br>            <span class="hljs-keyword">if</span>( t == temp)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//根据index 将 nums分成前后两个数组，分别求出他们的支配数并返回是否相同</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(List&lt;Integer&gt;nums ,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> len)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> [] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[index+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> [] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len-index-<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//分隔数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>            a[i] = nums.get(count);<br>            count++;<br>        &#125;<br>        <br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;b.length;i++)&#123;<br>            b[i] = nums.get(count);<br>            count++;<br>        &#125;<br>        <br>        <span class="hljs-comment">//分别求出他们的支配数</span><br>        <span class="hljs-keyword">int</span> a1 = fenpeiNum(a);<br>        <span class="hljs-keyword">int</span> b1 = fenpeiNum(b);<br>        <br>        <span class="hljs-keyword">if</span> (a1 == b1)&#123;<br>            <span class="hljs-keyword">return</span> a1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">//求支配配数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fenpeiNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] a)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> len = a.length;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>            map.put(a[i],map.getOrDefault(a[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">//遍历map，找到符合条件的key。</span><br>        Set&lt;Integer&gt; keys = map.keySet();<br>        <span class="hljs-keyword">for</span>(Integer key:keys)&#123;<br>            <span class="hljs-keyword">int</span> value = map.get(key);<br>            <span class="hljs-keyword">if</span>(value*<span class="hljs-number">2</span>&gt;len)&#123;<br>                <span class="hljs-keyword">return</span> key;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码的思路是没有问题的，测试证明也是这样，只是上面的时间复杂度太高了，最终没有通过全部测试数据。</p>
<p>对于每一个下标，都需要重新构建数组，并且还需要在遍历map。</p>
<h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>先查询出未分割前的支配数，如果存在最小分隔下标，那么他们的支配数也必定是未分割前的支配数。</p>
<p>所以求出支配数后，遍历nums集合，看当前元素是不是支配数，如果是的话，将支配数的个数+1，（那么后面数组支配数的个数就需要-1）。然后判断当前下标是否符合要去要即可。</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumIndex</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-comment">//统计数字出现的次数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            map.put(num,map.getOrDefault(num,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> max =nums.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//由于数组只会有一个支配数，那么支配数一定是出现次数最多的那个数字</span><br>        <span class="hljs-comment">//遍历map，找到出现次数最多的数字（支配数）</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<br>            <span class="hljs-keyword">if</span>(entry.getValue() &gt; map.get(max))&#123;<br>                <span class="hljs-comment">//这里的max就是key</span><br>                max = entry.getKey();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//遍历nums集合，统计当前下标支配数的个数，然后判断是否符合规范</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size()-<span class="hljs-number">1</span>;i++)&#123;<br>            count += nums.get(i) == max ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(count *<span class="hljs-number">2</span> &gt; i+<span class="hljs-number">1</span> &amp;&amp; (map.get(max)-count)*<span class="hljs-number">2</span>&gt;(nums.size()-i-<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="数组的最大美丽值"><a href="#数组的最大美丽值" class="headerlink" title="数组的最大美丽值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/">数组的最大美丽值</a></h3><blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个 <strong>非负</strong> 整数 <code>k</code> 。</p>
<p>在一步操作中，你可以执行下述指令：</p>
<p>在范围 <code>[0, nums.length - 1]</code> 中选择一个 <strong>此前没有选过</strong> 的下标 <code>i</code> 。<br>将 <code>nums[i]</code> 替换为范围 <code>[nums[i] - k, nums[i] + k]</code> 内的任一整数。<br>数组的 <strong>美丽值</strong> 定义为数组中由相等元素组成的最长子序列的长度。</p>
<p>对数组 <code>nums</code> 执行上述操作任意次后，返回数组可能取得的 <strong>最大</strong> 美丽值。</p>
<p>注意：你 <strong>只</strong> 能对每个下标执行 一次 此操作。</p>
<p>数组的 <strong>子序列</strong> 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入</strong>：nums = [4,6,1,2], k = 2<br><strong>输出</strong>：3<br>解释：在这个示例中，我们执行下述操作：</p>
<ul>
<li>选择下标 1 ，将其替换为 4（从范围 [4,8] 中选出），此时 nums = [4,4,1,2] 。</li>
<li>选择下标 3 ，将其替换为 4（从范围 [0,4] 中选出），此时 nums = [4,4,1,4] 。</li>
</ul>
<p>执行上述操作后，数组的美丽值是 3（子序列由下标 0 、1 、3 对应的元素组成）。<br>可以证明 3 是我们可以得到的由相等元素组成的最长子序列长度。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入</strong>：nums = [1,1,1,1], k = 10<br><strong>输出</strong>：4<br><strong>解释</strong>：在这个示例中，我们无需执行任何操作。<br>数组 nums 的美丽值是 4（整个数组）。</p>
</blockquote>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>由于可以将数字替换成<code>[nums[i] - k, nums[i] + k]</code>的任意整数，因此也就是说只需要满足在最开始的时候，这个子序列的最大值和最小值的差值不大于2*k，那么就可以达到题目的要求。由于选取的是子序列，与原来的顺序无关，因此可以先对数组进行排序。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumBeauty</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =<span class="hljs-number">0</span>;<br>		<br>        <span class="hljs-keyword">while</span>(right &lt;nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[right]-nums[left] &lt;= <span class="hljs-number">2</span>*k)&#123;<br>                right++;<br>                max = Math.max(max,right-left);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/03/Lombok%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">lombok常用注解</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">
                        <span class="hidden-mobile">排序算法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js" ></script>



  <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>



  <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
