<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EasyExcel处理Excel</title>
    <url>/2022/05/29/EasyExcel%E5%A4%84%E7%90%86Excel/</url>
    <content><![CDATA[<h1 id="实现写操作"><a href="#实现写操作" class="headerlink" title="实现写操作"></a>实现写操作</h1><a id="more"></a>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>由于easyexcel是对poi的一个封装，因此低版本的还需要引入poi的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoData</span> </span>&#123;<br><br>    <span class="hljs-comment">//设置exccel表头名称，使用@ExcelProperty注解</span><br><br>    <span class="hljs-meta">@ExcelProperty(&quot;学生编号&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer sno;<br><br>    <span class="hljs-meta">@ExcelProperty(&quot;学生姓名&quot;)</span><br>    <span class="hljs-keyword">private</span> String sname;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="实现写操作-1"><a href="#实现写操作-1" class="headerlink" title="实现写操作"></a>实现写操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.EasyExcel;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEasyExcel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//实现excel写操作</span><br><br>        <span class="hljs-comment">//1.设置写入文件地址和名称</span><br>        String filename = <span class="hljs-string">&quot;F:\\write.xlsx&quot;</span>;<br><br>        <span class="hljs-comment">//2.调用easyexcal</span><br>        <span class="hljs-comment">//write方法中两个参数：第一个参数文件路径名称，第二个参数文件实体类class</span><br>        <span class="hljs-comment">//sheet是excel表格底下的分类</span><br>        <span class="hljs-comment">//dowrite需要传入一个列表</span><br>        EasyExcel.write(filename,DemoData.class).sheet(&quot;学生列表<span class="hljs-number">1</span><span class="hljs-string">&quot;).doWrite(getData());</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    private static List&lt;DemoData&gt; getData()&#123;</span><br><span class="hljs-string">        List&lt;DemoData&gt; list = new ArrayList&lt;&gt;();</span><br><span class="hljs-string">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="hljs-string">            DemoData data = new DemoData();</span><br><span class="hljs-string">            data.setSno(i);</span><br><span class="hljs-string">            data.setSname(&quot;</span>lucy<span class="hljs-string">&quot;+i);</span><br><span class="hljs-string">            list.add(data);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        return  list;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>sheet就是这个</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220422141638360.png" alt="image-20220422141638360"></p>
<h1 id="实现读操作"><a href="#实现读操作" class="headerlink" title="实现读操作"></a>实现读操作</h1><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoData1</span> </span>&#123;<br><br>    <span class="hljs-comment">//表示sno对应的是excel表格中的第一列</span><br>    <span class="hljs-meta">@ExcelProperty(index = 0)</span><br>    <span class="hljs-keyword">private</span> Integer sno;<br><br>    <span class="hljs-meta">@ExcelProperty(index = 1)</span><br>    <span class="hljs-keyword">private</span> String sname;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//继承AnalysisEventListener类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnalysisEventListener</span>&lt;<span class="hljs-title">DemoData1</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//一行一行的读取excel的内容</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(DemoData1 demoData1, AnalysisContext analysisContext)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;内容&quot;</span>+demoData1);<br>    &#125;<br><br>    <span class="hljs-comment">//读取表头</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeHeadMap</span><span class="hljs-params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;表头&quot;</span>+headMap);<br>    &#125;<br><br>    <span class="hljs-comment">//读取完成之后执行的操作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext analysisContext)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.EasyExcel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEasyExcel1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//定义读取的文件的路径</span><br>        String filename = <span class="hljs-string">&quot;F:\\write.xlsx&quot;</span>;<br><br>        <span class="hljs-comment">//第一个参数是文件路径名</span><br>        <span class="hljs-comment">//第二个是实体类的类信息</span><br>        <span class="hljs-comment">//第三个是监听器</span><br>        EasyExcel.read(filename,DemoData1.class,<span class="hljs-keyword">new</span> ExcelListener()).sheet().doRead();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java实现MD5</title>
    <url>/2022/09/01/Java%E5%AE%9E%E7%8E%B0MD5/</url>
    <content><![CDATA[<h1 id="摘要算法介绍"><a href="#摘要算法介绍" class="headerlink" title="摘要算法介绍"></a>摘要算法介绍</h1><p>摘要算法是一种能产生特殊输出格式的算法，这种算法的特点是：<strong>无论用户输入什么长度的原始数据，经过计算后输出的密文都是固定长度的</strong>，这种算法的原理是根据一定的运算规则对原数据进行某种形式的提取，这种提取就是摘要，被摘要的数据内容与原数据有密切联系，<strong>只要原数据稍有改变，输出的“摘要”便完全不同</strong>，因此，基于这种原理的算法便能对数据完整性提供较为健全的保障。</p>
<p>但是，由于输出的密文是提取原数据经过处理的定长值，所以它已经不能还原为原数据，<strong>即消息摘要算法是不可逆的</strong>，理论上无法通过反向运算取得原数据内容，因此它通常只能被用来做数据完整性验证。</p>
<p>MD5就是一种摘要算法。</p>
<p>我们可以生成一个salt，然后将他任意拼接在需要加密的原始数据上。==这样可以增加密码安全。因为只有我们才知道是怎么拼接的==</p>
<h1 id="手写工具类"><a href="#手写工具类" class="headerlink" title="手写工具类"></a>手写工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : pety</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2022/6/1 15:34</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String str)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//定义16进制字符</span><br>            <span class="hljs-keyword">char</span> [] hexChars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span> &#125;;<br>            <span class="hljs-comment">//创建MD5的MessageDigest对象</span><br>            MessageDigest md5 = MessageDigest.getInstance(<span class="hljs-string">&quot;md5&quot;</span>);<br>            <span class="hljs-comment">//获取字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = str.getBytes();<br>            <span class="hljs-comment">//使用字节数组更新摘要</span><br>            md5.update(bytes);<br>            <span class="hljs-comment">//通过执行填充完成哈希计算,得到的是16位的10进制字符</span><br>            <span class="hljs-keyword">byte</span>[] digest = md5.digest();<br>            <span class="hljs-keyword">int</span> len = digest.length;<br>            <span class="hljs-keyword">char</span> [] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len*<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//将16位10进制字符转为32位16进制字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                <span class="hljs-keyword">byte</span> b = digest[i];<br>                <span class="hljs-comment">//&gt;&gt;&gt; 表示无符号右移，高四位和f做与运算</span><br>                chars[k++] = hexChars[b&gt;&gt;&gt;<span class="hljs-number">4</span>&amp;<span class="hljs-number">0xf</span>];<br>                chars[k++] = hexChars[b&amp;<span class="hljs-number">0xf</span>];<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> chars.toString();<br><br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;MD5加密出错！！+&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>也可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//定义16进制字符</span><br>            <span class="hljs-keyword">char</span>[] hexChars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>&#125;;<br>            <span class="hljs-comment">//创建MD5的MessageDigest对象</span><br>            MessageDigest md5 = MessageDigest.getInstance(<span class="hljs-string">&quot;md5&quot;</span>);<br>            <span class="hljs-comment">//获取字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = str.getBytes();<br>            <span class="hljs-comment">//使用字节数组更新摘要</span><br>            md5.update(bytes);<br>            <span class="hljs-comment">//通过执行填充完成哈希计算,得到的是16位的10进制字符</span><br>            <span class="hljs-keyword">byte</span>[] digest = md5.digest();<br><br>            StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : digest) &#123;<br>                <span class="hljs-comment">//转化为16进制字符串</span><br>                <span class="hljs-comment">//将高4位转换为16进制</span><br>                builder.append(Integer.toHexString(b &gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xf</span>));<br>                <span class="hljs-comment">//将低4位转换为16进制</span><br>                builder.append(Integer.toHexString(b &amp; <span class="hljs-number">0xf</span>));<br>            &#125;<br>            <span class="hljs-keyword">return</span> builder.toString();<br><br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;MD5加密出错！！+&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h1 id="利用Spring自带的加密工具"><a href="#利用Spring自带的加密工具" class="headerlink" title="利用Spring自带的加密工具"></a>利用Spring自带的加密工具</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s = DigestUtils.md5DigestAsHex(<span class="hljs-string">&quot;123456&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure>





<h1 id="利用第三方jar包"><a href="#利用第三方jar包" class="headerlink" title="利用第三方jar包"></a>利用第三方jar包</h1><h3 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>    String s = DigestUtils.md5Hex(<span class="hljs-string">&quot;123456&quot;</span>.getBytes());<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="使用hutoll工具包"><a href="#使用hutoll工具包" class="headerlink" title="使用hutoll工具包"></a>使用hutoll工具包</h1><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>





<h3 id="直接使用-1"><a href="#直接使用-1" class="headerlink" title="直接使用"></a>直接使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>    String s = DigestUtil.md5Hex(<span class="hljs-string">&quot;123456&quot;</span>);<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JMeter压力测试</title>
    <url>/2022/05/29/Jemeter/</url>
    <content><![CDATA[<h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><a id="more"></a>

<p>JMeter 依赖于JDK，所以必须确保当前计算机上已经安装了 JDK，并且配置了环境变量。</p>
<p>Apache Jmeter官网下载，地址：<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182402429.png" alt="image-20220520182402429"></p>
<p>解压缩即可使用，目录结构如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182426302.png" alt="image-20220520182426302"></p>
<p>其中的 bin 目录就是执行的脚本，其中包含启动脚本</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182445106.png" alt="image-20220520182445106"></p>
<p>双击即可运行，但是有两点注意</p>
<ul>
<li>启动时速度比较慢，要耐心等待。</li>
<li>启动后终端（黑窗口）不能关闭，否则 JMeter 也跟着关闭。</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182502234.png" alt="image-20220520182502234"></p>
<h2 id="修改中文"><a href="#修改中文" class="headerlink" title="修改中文"></a>修改中文</h2><p>默认 JMeter 的语言是英文，需要设置</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182516753.png" alt="image-20220520182516753"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182538054.png" alt="image-20220520182538054"></p>
<p>上面的配置只能保证本次运行是中文，如果要永久中文，需要修改 JMeter 的配置文件。</p>
<p>打开 JMeter 文件夹，在 bin 目录中找到 <strong>jmeter.properties</strong>，添加下面配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">language</span>=<span class="hljs-string">zh_CN</span><br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182555036.png" alt="image-20220520182555036"></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在测试计划上点鼠标右键，选择「添加 &gt; 线程（用户） &gt; 线程组」</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182612199.png" alt="image-20220520182612199"></p>
<p>在新增的线程组中，填写线程信息</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182622262.png" alt="image-20220520182622262"></p>
<p>在线程组这里点鼠标右键，添加 http 请求</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182635810.png" alt="image-20220520182635810"></p>
<p>编写取样器内容</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182646501.png" alt="image-20220520182646501"></p>
<p>添加监听报告</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182658504.png" alt="image-20220520182658504"></p>
<p>汇总报告结果</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182716297.png" alt="image-20220520182716297"></p>
<p>添加监听结果树</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182815816.png" alt="image-20220520182815816"></p>
<p>察看结果树</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182731253.png" alt="image-20220520182731253"></p>
]]></content>
  </entry>
  <entry>
    <title>Linux无法ping通外网的问题</title>
    <url>/2022/05/29/Linux%E6%97%A0%E6%B3%95ping%E9%80%9A%E5%A4%96%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天重新装了一个Linux系统，下载东西的时候报出如下错误:</p>
<p><code>Cannot find a valid baseurl for repo: base/7/x86_64</code></p>
<a id="more"></a>

<p>然后使用ping命令发现无法ping通外网</p>
<p>需要设置一下DNS信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">vim /etc/resolv.conf<br><br>在里面加入如下配置<br>nameserver=8.8.8.8<br>nameserver=8.8.4.4<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Mysql函数</title>
    <url>/2022/07/31/Mysql%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>记录刷题过程中需要使用到的一些mysql函数</p>
<p>窗口函数：窗口函数也叫OLAP函数，可以对数据进行实时分析处理。</p>
<p>窗口函数用法：</p>
<p>&lt;窗口函数&gt; OVER ( [PARTITION BY &lt;列清单&gt; ]</p>
<p>​                ORDER BY &lt;排序用列清单&gt; ）</p>
<p>*其中[ ]中的内容可以忽略</p>
</blockquote>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK()"></a>RANK()</h3><p>在计算排序时，若存在相同位次，会跳过之后的位次。例如，有3条排在第1位时，排序为：1，1，1，4······</p>
<h3 id="DENSE-RANK"><a href="#DENSE-RANK" class="headerlink" title="DENSE_RANK()"></a>DENSE_RANK()</h3><p>在计算排序时，若存在相同位次，不会跳过之后的位次。例如，有3条排在第1位时，排序为：1，1，1，2······</p>
<h3 id="ROW-NUMBER"><a href="#ROW-NUMBER" class="headerlink" title="ROW_NUMBER()"></a>ROW_NUMBER()</h3><p>这个函数赋予唯一的连续位次。例如，有3条排在第1位时，排序为：1，2，3，4······</p>
<p>牛客网SQL217就用到了<code>dense_rank()</code>函数：</p>
<p>对所有员工的薪水按照salary降序先进行1-N的排名，如果salary相同，再按照emp_no升序排列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  emp_no,<br>  salary,<br>  <span class="hljs-keyword">dense_rank</span>() <span class="hljs-keyword">over</span> (<br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>      salary <span class="hljs-keyword">desc</span><br>  ) <span class="hljs-keyword">rank</span><br><span class="hljs-keyword">from</span><br>  salaries<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">rank</span> <span class="hljs-keyword">asc</span>,emp_no <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure>





<h2 id="小数格式化"><a href="#小数格式化" class="headerlink" title="小数格式化"></a>小数格式化</h2><blockquote>
<p>有时题目需要将结果保留几位小数</p>
</blockquote>
<h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND()"></a>ROUND()</h3><p><code>round(number,n)</code>可以指定保留几位小数，采用四舍五入。 如<code>round(3.1415,3)</code>会变成3.142</p>
<p>如果小数位不足指定的位数，比如只有一位小数，需要保留到两位小数则只会显示一位小数。</p>
<h3 id="CONVERT"><a href="#CONVERT" class="headerlink" title="CONVERT()"></a>CONVERT()</h3><p><code>CONVERT(X,DECIMAL(L,D))</code></p>
<p>L:格式化的数的总的长度；D:小数的个数；X:格式化的数字。 如：<code>convert(3.1314,decimal(10,2))</code>将会保留两位小数。四舍五入。</p>
<p>如果小数位不足，会自动补0。</p>
<h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><p><code>TRUNCATE（X,D）</code></p>
<p>X:格式化的数字，D:小数的个数。会直接舍去，不会四舍五入。</p>
<p>如果小数位不足，只会显示已有的小数位。不会补0。</p>
<h3 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h3><p><code>FORMAT（X,D）</code></p>
<p>四舍五入，会自动补0。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux部署开发环境</title>
    <url>/2021/04/12/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="Linux部署开发环境"><a href="#Linux部署开发环境" class="headerlink" title="Linux部署开发环境"></a>Linux部署开发环境</h3><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><h5 id="获取mysql-YUM源"><a href="#获取mysql-YUM源" class="headerlink" title="获取mysql YUM源"></a>获取mysql YUM源</h5><ol>
<li>打开网址  <a href="https://dev.mysql.com/downloads/repo/yum/">Mysql yum存储库</a></li>
<li>进入需要下载的文件，点击这里，获取到链接地址，这样就不需要把文件下载到本地。</li>
</ol>
<a id="more"></a>

<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407095725914.png" alt="image-20210407095725914"></p>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407095911292.png" alt="image-20210407095911292"></p>
<h5 id="下载和安装mysql源"><a href="#下载和安装mysql源" class="headerlink" title="下载和安装mysql源"></a>下载和安装mysql源</h5><ol>
<li><p>先创建一个MySQL的文件夹 ：<code>mkdir mysql</code>    </p>
</li>
<li><p>设置权限：<code>chmod 777 mysql </code></p>
</li>
<li><p>进入mysql文件夹，wget加上刚才复制的地址，下载mysql源</p>
</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407100358273.png" alt="image-20210407100358273"></p>
<ol start="4">
<li>如果显示wget未找到命令，则先安装wget：<code>yum -y install wget</code>,然后在执行刚才的命令。</li>
<li>安装mysql源 ：<code>yum -y localinstall mysql80-community-release-el8-1.noarch.rpm</code></li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407100801585.png" alt="image-20210407100801585"></p>
<h5 id="在线安装mysql"><a href="#在线安装mysql" class="headerlink" title="在线安装mysql"></a>在线安装mysql</h5><ol>
<li><code>yum -y install mysql-community-server</code>  会安装mysql服务器(mysql-community-server) 所需要的依赖和相关组件。</li>
<li>直接输入这个命令会报错</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407101844829.png" alt="image-20210407101844829"></p>
<ol start="3">
<li>在使用这个命令前，先输入<code>yum module disable mysql</code></li>
<li>输入<code>yum -y install mysql-community-server</code>,下载的时间会有点长，因为需要下载很多东西</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407102007009.png" alt="image-20210407102007009"></p>
<h5 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h5><p><code>systemctl start mysqld</code></p>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407102153546.png" alt="image-20210407102153546"></p>
<h5 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h5><p><code>systemctl enable mysqld</code>   <code>systemctl daemon-reload</code></p>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407102344314.png" alt="image-20210407102344314"></p>
<h5 id="登录mysql，并且修改密码"><a href="#登录mysql，并且修改密码" class="headerlink" title="登录mysql，并且修改密码"></a>登录mysql，并且修改密码</h5><ol>
<li>网上的教程说会随机生成一个密码，但是我这个并没有生成密码，也就是在登录的时候不需要输入密码<code>mysql -u root -p</code> 登录数据库</li>
<li><strong>通过</strong> <strong>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;</strong> <strong>命令来修改密码</strong></li>
</ol>
<h5 id="修改用户登录权限"><a href="#修改用户登录权限" class="headerlink" title="修改用户登录权限"></a>修改用户登录权限</h5><p>我们使用root用户登录mysql，但是刚刚部署的环境中，只允许本机访问数据库，不允许其他地址访问，因此我们需要修改权限。</p>
<ol>
<li>查看一共有哪几个数据库：<code>show databases;</code></li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407103023040.png" alt="image-20210407103023040"></p>
<ol start="2">
<li>进入mysql这个库:<code>use mysql</code>;</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407103113302.png" alt="image-20210407103113302"></p>
<ol start="3">
<li>查询user和host：<code>select user,host from user</code>,我这里已经修改过了，正常刚部署的时候，root后面的host也是localhost。</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407103209085.png" alt="image-20210407103209085"></p>
<ol start="4">
<li>修改root的host：<code>update user set host =&#39;%&#39; where user=root;</code></li>
</ol>
<h5 id="服务器开启3306端口"><a href="#服务器开启3306端口" class="headerlink" title="服务器开启3306端口"></a>服务器开启3306端口</h5><p>登录阿里云控制台，在安全组规则中添加访问规则，开放3306端口。开启的时候注意是在服务器的实例的那个安全组添加，我一开始就是重新创建了一个安全组，但是那个安全组并没有对应的实例，浪费了好久的时间。可以在本机dos窗口下使用<code>tcping ip地址 端口号</code>查看该端口能不能访问。</p>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407103500323.png" alt="image-20210407103500323"></p>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>就可以用navicat连接数据库了。</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><h5 id="下载redis"><a href="#下载redis" class="headerlink" title="下载redis"></a>下载redis</h5><ol>
<li><p>进入官方网站下载redis：<a href="https://redis.io/download">下载地址</a></p>
</li>
<li><p>获取下载链接地址，复制链接。</p>
</li>
<li><p>使用wget下载redis文件：<code>wget https://download.redis.io/releases/redis-6.2.1.tar.gz?_ga=2.218275550.693953461.1617763684-492675992.1602071540 </code>   wget+刚才复制的地址。</p>
</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407105237017.png" alt="image-20210407105237017"></p>
<p><strong>注意：我这个地址是直接从官网下载地址复制过来的，但是他后面多了一串字符，从”?_ga=”开始，为什么会这样我也不清楚，因此我们需要将这个文件重新改名。如果后缀直接是.tar.gz就不需要改名了</strong></p>
<ol start="4">
<li>使用<code>mv 原来文件的名字  需要修改的名字</code>修改文件的名字。</li>
</ol>
<h5 id="解压并移动redis"><a href="#解压并移动redis" class="headerlink" title="解压并移动redis"></a>解压并移动redis</h5><ol>
<li><p>使用<code>tar zvxf redis-6.2.1.tar.gz</code>解压文件，可以看到多出了redis-6.2.1这个文件夹。</p>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407110251832.png" alt="image-20210407110251832"></p>
</li>
<li><p>将redis目录移动到/usr/local/redis目录下，使用<code>mv /root/redis-6.2.1 /usr/local/redis</code>移动文件，该命令会自动创建一个redis子目录，因此不需要手动去创建一个redis目录。</p>
</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407110706199.png" alt="image-20210407110706199"></p>
<h5 id="编译安装redis"><a href="#编译安装redis" class="headerlink" title="编译安装redis"></a>编译安装redis</h5><ol>
<li>输入<code>make</code>执行编译命令，最终会出现这个结果：</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407111216978.png" alt="image-20210407111216978"></p>
<ol start="2">
<li>使用<code>make PREFIX=/usr/local/redis install</code>安装redis 。<strong>这里多了一个关键字 <code>PREFIX=</code> ，这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/usr/local/redis目录。假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。这里指定号目录也方便后续的卸载，后续直接rm -rf /usr/local/redis 即可删除redis。</strong></li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407111505750.png" alt="image-20210407111505750"></p>
<h5 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h5><p>上面的操作已经完成了redis的安装.</p>
<h6 id="前端启动"><a href="#前端启动" class="headerlink" title="前端启动"></a>前端启动</h6><p>在redis的安装目录下直接启动redis：使用<code>redis-server</code>启动redis，<strong>注意是在/bin这个目录下</strong></p>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407112151333.png" alt="image-20210407112151333"></p>
<h6 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h6><ol>
<li>将redis.conf复制到/user/local/redis/bin 目录下 <code>cp redis.conf /usr/local/redis/bin</code></li>
<li>修改redis.conf配置 ，进入/bin目录  输入<code>vim redis.conf</code>进入修改界面，向下找，将daemonize设置为yes（原来为no）。</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407112834813.png" alt="image-20210407112834813"></p>
<ol start="3">
<li>启动redis ：/bin目录下，<code>./redis-server redis.conf</code></li>
<li>查看redis是否启动 <code>ps aux|grep redis</code>  **ps:想要关闭redis，  <code>kill -9 44565</code>后面的数字就是前面那个命令显示出来的第二个。</li>
</ol>
<p><img src="/images/Linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/image-20210407120052553.png" alt="image-20210407120052553"></p>
<h5 id="修改开启指令"><a href="#修改开启指令" class="headerlink" title="修改开启指令"></a>修改开启指令</h5><p>经过上面的操作，我们可以通过<code>./redis-cli</code>连接redis，但是每次输入./比较麻烦，因此我们可以修改启动的命令，在任意界面下都可以开启，也就是添加一个环境变量。</p>
<ol>
<li>修改profile文件：<code>vim /etc/profile</code></li>
<li>在文件的最后添加如下代码  <code>export PATH=$PATH:/usr/local/redis/src</code>。然后我们就可以通过<code>redis-cli</code>连接redis了。</li>
</ol>
<h5 id="开启6379端口"><a href="#开启6379端口" class="headerlink" title="开启6379端口"></a>开启6379端口</h5><p>注意要开启6379端口，开启方式和mysql中开启3306端口一样。</p>
<h5 id="配置redis-config"><a href="#配置redis-config" class="headerlink" title="配置redis.config"></a>配置redis.config</h5><p><code>vim redis.config</code> hao</p>
<ol>
<li>修改bind 为0.0.0.0 </li>
<li>修改protected-mod 为no</li>
</ol>
<p>连接redis：<code>redis-cli</code>,使用<code>config set requirepass 密码</code>设置密码，今后在进行操作的时候就需要先输入<code>AUTH 密码</code>在进行操作。</p>
<p><strong>注意：阿里云服务器默认没有开启8080端口，只开启了80端口，我在部署springboot项目的时候，发现请求超时，然后就想到应该是没有开启8080端口，需要到安全组中配置规则，一开始以为80端口就是8080端口，而且在快速添加中也没有8080端口这个选项，浪费了好久时间，以后要注意</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>ORM简介</title>
    <url>/2021/07/22/ORM/</url>
    <content><![CDATA[<h2 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h2><p>ORM（Object-Relational Mapping ，对象关系映射）模式是为了解决面向对象与关系数据库存在的互不匹配的现象的技术。</p>
<p>ORM主要是把数据库中的关系映射为程序中的对象，将程序中的对象自动持久化到关系型数据库中，他是随着面向对象的开发方法发展起来的，ORM在业务逻辑层和数据库层之间充当了桥梁的作用，我们在具体的操作业务对象的时候，不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。</p>
<a id="more"></a>

<h2 id="ORM的由来"><a href="#ORM的由来" class="headerlink" title="ORM的由来"></a>ORM的由来</h2><p>面向对象是从软件工程基本原则（如耦合，聚合，封装等）的基础上发展来的，而关系型数据库是从数学理论发展而来的，这两种理论存在显著差别，为解决这一差异，ORM应运而生。</p>
<p>O是object，也就类对象的意思，R是relation，翻译成中文是关系，也就是关系数据库中数据表的意思，M是mapping，是映射的意思。</p>
<p>在ORM框架中，它帮我们把类和数据表进行了一个映射，可以让我们通过类和类对象就能操作它所对应的表格中的数据。ORM框架还有一个功能，它可以根据我们设计的类自动帮我们生成数据库中的表格，省去了我们自己建表的过程。</p>
<p>几乎所有的软件开发过程中都会涉及到对象和关系数据库，在用户层面和业务逻辑层面，我们是面向对象的。当对象的信息发生变化的时候，我们就需要把对象的信息保存在关系数据库中。</p>
<blockquote>
<p>按之前的方式进行开发，就会出现程序员会在自己的业务逻辑代码中夹杂很多SQL语句用来增加、读取、修改、删除相关数据，而这些代码通常是重复的。</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/1418466-20181224093538503-655204666.png" alt="img"></p>
<h2 id="ORM的核心原则"><a href="#ORM的核心原则" class="headerlink" title="ORM的核心原则"></a>ORM的核心原则</h2><p>（1）简单性：以最基本的形式建模数据</p>
<p>（2）传达性：数据库结构被任何人都能理解的语言文档化</p>
<p>（3）精确性：基于数据库模型创建正确标准化了的结构</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>ORM主要解决理论对象和关系的映射。通常把一个类和一张表一一对应，类的每一个实例对应表中的一条记录，类的每个属性对应表中的每个字段。</li>
<li>ORM提供了对数据库的映射，不用直接编写sql语句，只需向操作对象一样从数据库操作数据。</li>
<li>提高开发效率，让软件开发人员专注于业务逻辑的处理。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能。</li>
<li>对于复杂查询，ORM力不从心</li>
<li>执行效率低语直接编写的SQL语句</li>
</ul>
<h2 id="DJango框架中ORM示意图"><a href="#DJango框架中ORM示意图" class="headerlink" title="DJango框架中ORM示意图"></a>DJango框架中ORM示意图</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/7918604-f5fa11d7421ac4c8.png" alt="img"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/7918604-1facae29d03da5b5.png" alt="img"></p>
<p>虽然图是Python，但是其他的也是类似的。</p>
]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Springmvc文件上传</title>
    <url>/2020/09/25/SprigMVC%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h2><h3 id="前端页面的要求"><a href="#前端页面的要求" class="headerlink" title="前端页面的要求"></a>前端页面的要求</h3><p>为了上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制流数据发送给服务器。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="引入fileupload和io坐标"><a href="#引入fileupload和io坐标" class="headerlink" title="引入fileupload和io坐标"></a>引入fileupload和io坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>1.3.3版本</strong>会自动引入io包，所以不需要在单独引入</p>
<h3 id="配置DispatcherServlet（前端控制器）"><a href="#配置DispatcherServlet（前端控制器）" class="headerlink" title="配置DispatcherServlet（前端控制器）"></a>配置DispatcherServlet（前端控制器）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--绑定applicationContext.xml，里面用来配置springmvc需要的一些东西--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置启动级别,1为服务器已启动就启动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="配置MultipartResolver解析器"><a href="#配置MultipartResolver解析器" class="headerlink" title="配置MultipartResolver解析器"></a>配置MultipartResolver解析器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/c&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启注解扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.pty.controller&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置MultipartResoolver，用于文件上传--&gt;</span><br>    <span class="hljs-comment">&lt;!--注意：CommonsMultipartResolver的id是固定不变的，一定是multipartResolver，不能修改--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--阈值，低于这个的保存在内存中，高于这个的，生成硬盘上的临时文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxInMemorySize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;40960&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--上传文件大小上限，单位为字节,这是总的文件的大小--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;104857600&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--设置请求的编码格式，这里设置为utf-8，默认为IOS-8859-1--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--单个文件大小上限--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSizePerFile&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10485760&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Upload</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-comment">//@RequestParam(&quot;file)将前端表单中name=file的控件得到的文件封装成MultipartFile 对象</span><br>    <span class="hljs-comment">//如果上传的是多文件，将MutipartFile改成MutipartFile 数组即可</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpSession session)</span> </span>&#123;<br>        <span class="hljs-comment">//获取文件名</span><br>        String filename = file.getOriginalFilename();<br><br>        <span class="hljs-comment">//判断是否上传文件(即文件名是否为空)，如果没有，返回上传页</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(filename)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;上传失败&quot;</span><br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        除了通过判断文件名是否为空来判断是否上传文件，还可以通过以下方式来验证</span><br><span class="hljs-comment">        1. 判断文件的大小是否大于0：file.getSize()得到文件的大小，进行判断。</span><br><span class="hljs-comment">        2.判断文件是否为空： file.isEmpty()</span><br><span class="hljs-comment">         */</span><br>        System.out.println(<span class="hljs-string">&quot;上传文件名&quot;</span> + filename);<br>        <span class="hljs-comment">//获取文件存储路径（绝对路径）</span><br>        <span class="hljs-comment">/*session.getServletContext()拿到了一个servlet的容器</span><br><span class="hljs-comment">        这个path的位置是</span><br><span class="hljs-comment">        */</span><br>        String path = session.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br><br>        <span class="hljs-comment">//可以对上传的文件的类型做限制，比如说只能够上传jpg和png的图片文件</span><br>        <span class="hljs-comment">//注意这里的逻辑问题，我一开始是用或，但是应该是既不是jpg也不是png，应该用与</span><br>        <span class="hljs-comment">//endsWith:判断字符串是否以指定的后缀结尾</span><br>        <span class="hljs-keyword">if</span> (!path.endsWith(<span class="hljs-string">&quot;jpg&quot;</span>) &amp;&amp; !path.endsWith(<span class="hljs-string">&quot;png&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;格式不符合&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//新建文件实例</span><br>        <span class="hljs-comment">/*这里应该使用File(String parent, String child) 构造方法，从父路径和子路径字符创建新的File实例</span><br><span class="hljs-comment">        因为下面的transferTo（）会将上传的文件保存到一个目录文件中，即让这个目录文件变成上传的文件。</span><br><span class="hljs-comment">        我之前就是使用File(String pathname)构造方法，使得upload文件夹变成了upload文件*/</span><br>        File upfile = <span class="hljs-keyword">new</span> File(path,filename);<br>        <span class="hljs-comment">//判断是否有此文件，没有的话就创建一个。</span><br>        <span class="hljs-comment">//因为如果是第一次保存，就没有文件。</span><br>        <span class="hljs-keyword">if</span> (!upfile.exists()) &#123;<br>            <span class="hljs-comment">/*新建文件,因为上面创建File实例的时候，创建了两层路径。</span><br><span class="hljs-comment">            mkdir()创建由此抽象路径名命名的目录。</span><br><span class="hljs-comment">            mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。</span><br><span class="hljs-comment">            因为创建了两层路径，用前者创建的时候只会创建最后一层目录，如果第一层路径没有，则看不到创建出来的目录</span><br><span class="hljs-comment">            而后者在创建最后一层的目录时，还会创建最后一层之前且不存在的目录。</span><br><span class="hljs-comment">            */</span><br>            upfile.mkdirs();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;文件上传路径&quot;</span> + upfile);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//接收用户上传文件流，输出到指定文件中</span><br>            file.transferTo(upfile);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;文件上传失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//得到上传文件的路径和名字，将其生成一个字符串，然后将这个值保存到数据库。</span><br>        <span class="hljs-comment">//比如说图片，用户上传头像，我们将图像路径保存到数据库，显示的时候直接将这个地址返回给前端</span><br>        <span class="hljs-comment">//然后就可以显示图片</span><br>        String filePath = path+filename;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>减少了一些注释，以后可以直接拿过来用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pty.controller;<br><br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">fileupload</span> </span>&#123;<br><br>        <span class="hljs-comment">//@RequestParam(&quot;file)将前端表单中name=file的控件得到的文件封装成MultipartFile 对象</span><br>        <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpSession session)</span> </span>&#123;<br>            String filename = file.getOriginalFilename();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>.equals(filename))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:index.jsp&quot;</span>;<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;上传的文件名：&quot;</span>+filename);<br><br>            <span class="hljs-comment">//获取文件存储路径（绝对路径）</span><br>            <span class="hljs-comment">//session.getServletContext()拿到了一个servlet的容器</span><br>            String path = session.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br><br>            <span class="hljs-keyword">if</span>(!filename.endsWith(<span class="hljs-string">&quot;jpg&quot;</span>)&amp;&amp;!filename.endsWith(<span class="hljs-string">&quot;png&quot;</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:index.jsp&quot;</span>;<br>            &#125;<br><br>            File upfile = <span class="hljs-keyword">new</span> File(path,filename);<br>            <span class="hljs-keyword">if</span>(!upfile.exists())&#123;<br>                upfile.mkdirs();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;文件上传路径&quot;</span> + upfile);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                file.transferTo(upfile);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>                System.out.println(<span class="hljs-string">&quot;上传失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hahah&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><p>上面的操作是单文件上传，但有时候会需要上传多个文件。</p>
<p>我们的方法是将多文件上传分解成单文件上传。</p>
<p>可以通过一个方法来接收前端传过来的文件，然后我们将文件遍历，单个文件在调用保存方法。</p>
<h3 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h3><p>一次性选择多个文件上传，在input标签中添加<strong>multiple</strong>属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/test/upload.do&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br> <br>  一次选择多个文件的多文件上传 : <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;imgs1&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br> <br>  一次选择一个文件的多文件上传 : <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;imgs2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;imgs2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br> <br>  单文件上传 : <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;imgs3&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><p>多文件上传是，需要用MultipartFile数组来接收这些文件。</p>
<p>虽然从前端接收到了多个文件，但是springmvc只会将一个文件封装进一个MultipartFile对象，而不会将多个文件封装进一个MutipartFile数组，所以需要使用<code>@RequestParam</code>注解来校正参数，必须写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(value = &quot;/upload.do&quot;, method = RequestMethod.POST)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> MultipartFile[] imgs1,<span class="hljs-meta">@RequestParam</span> MultipartFile[] imgs2,<span class="hljs-meta">@RequestParam</span> MultipartFile[] imgs3, HttpSession session)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String path = session.getServletContext().getRealPath(<span class="hljs-string">&quot;images&quot;</span>);<br>    <span class="hljs-keyword">for</span> (MultipartFile img : imgs1) &#123;<br>        <span class="hljs-comment">//遍历文件，单个文件在调用保存的方法，也就是上面写的controller,这里就不写了。</span><br>      uploadFile(path, img);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (MultipartFile img : imgs2) &#123;<br>      uploadFile(path, img);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (MultipartFile img : imgs3) &#123;<br>      uploadFile(path, img);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/success.jsp&quot;</span>;<br>  &#125;<br> <br></code></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="MultipartFile类常用的一些方法"><a href="#MultipartFile类常用的一些方法" class="headerlink" title="MultipartFile类常用的一些方法"></a>MultipartFile类常用的一些方法</h3><ul>
<li>String getContentType()：获取文件MIME类型</li>
<li>InputStream getInputStream()：后去文件流</li>
<li>String getName() ：获取表单中文件组件的名字</li>
<li>String getOriginalFilename() ：获取上传文件的原名</li>
<li>long getSize() ：获取文件的字节大小，单位byte</li>
<li>boolean isEmpty() ：是否为空</li>
<li>void transferTo(File dest) ：保存到一个目标文件中。</li>
</ul>
<h3 id="CommonsMultipartResolver的属性解析"><a href="#CommonsMultipartResolver的属性解析" class="headerlink" title="CommonsMultipartResolver的属性解析"></a>CommonsMultipartResolver的属性解析</h3><ul>
<li>defaultEncoding：表示用来解析request请求的默认编码格式，当没有指定的时候根据Servlet规范会使用默认值ISO-8859-1。当request自己指明了它的编码格式的时候就会忽略这里指定的defaultEncoding。</li>
<li>uploadTempDir：设置上传文件时的临时目录，默认是Servlet容器的临时目录。</li>
<li>maxUploadSize：设置允许上传的总的最大文件大小，以字节为单位计算。当设为-1时表示无限制，默认是-1。</li>
<li>maxUploadSizePerFile：跟maxUploadSize差不多，不过maxUploadSizePerFile是限制每个上传文件的大小，而maxUploadSize是限制总的上传文件大小。</li>
<li>maxInMemorySize：设置在文件上传时允许写到内存中的最大值，以字节为单位计算，默认是10240。</li>
<li>resolveLazily：为true时，启用推迟文件解析，以便在UploadAction中捕获文件大小异常。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的多文件上传是参考一遍博客的，我自己没有打代码实现，可能会存在问题。</p>
<p>经过这次操作，发现了一些问题。</p>
<ol>
<li>要保持一个好的心态，一般问题的出现是一个接着一个的，不要太早崩溃。</li>
<li>出现错误的时候，先检查下自己的环境，很多时候并不是代码的原因而是环境的问题，比如说一些依赖没有导入，项目结构中的Artifacts中没有jar包。</li>
<li>尽量多查文档之类的。</li>
<li>没事别手贱乱删东西，说真的强迫症搞程序员太难了，看到一些没用的东西就想删，但是那个可能只是你以为没有用。</li>
<li>要熟悉新建一个模板的流程，现在用的是springmvc,需要自己配置tomcat，让项目变成web项目。虽然springboot在这些方面比较方便，但是还是要多加练习。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot整合mybatis 和 druid</title>
    <url>/2020/09/13/Springboot%E6%95%B4%E5%90%88Mybatis%E5%92%8Cdruid/</url>
    <content><![CDATA[<p>在实际开发中，我们一般不使用springboot自带的数据池，通常会整合mybatis和druid连接池，这篇博客就是用来记录怎么整合mybatis和druid</p>
<a id="more"></a>

<h2 id="spring-boot-整合mybatis"><a href="#spring-boot-整合mybatis" class="headerlink" title="spring boot 整合mybatis"></a>spring boot 整合mybatis</h2><ol>
<li>导入相关依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>或者在用<strong>Spring initializr</strong>创建springboot项目时直接添加mybatis maven坐标</p>
<ol start="2">
<li><p>配置数据源</p>
<p>在resource下新建一个application.yml文件</p>
<p>在里面配置数据源信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>  	<span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/blog?serverTimezone=UTC</span>  <br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>   <br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <br></code></pre></td></tr></table></figure>

<p><strong>username</strong> 如果使用 **data-username: **好像会出错</p>
<p>会报这个错误： <strong>Access denied for user ‘’@’localhost’ (using password: YES)</strong></p>
</li>
<li><p>添加mybatis配置</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.example.druid.bean</span><br>  <span class="hljs-attr">config-location:</span> <br></code></pre></td></tr></table></figure>

<ul>
<li><code>mapper-locations</code>：mapper所在的文件夹，用来定位mapper的位置</li>
<li><code>type-aliases-package</code>：别名类所在的文件夹，用来给实体类设置别名。</li>
<li><code>config-location</code>：mabatis配置文件的地址，如果用了<code>type-aliases-package</code>,就不用这个，因为在mybatis的配置类中基本上就是设置别名，type这个更加简单，不用再去新建一个config.xml。</li>
</ul>
<ol start="4">
<li><p>创建mapper文件</p>
<p> 在resources文件夹下创建mapper文件夹，在该文件下创建xxxmapper.xml。</p>
<p>在xxxmapper.xml下添加如下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!--mapper的约束--&gt;</span><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--里面写具体的sql语句，必须要写namespace,这个是用来定位到你这个sql语句是由哪一个来调用，全限定类名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.druid.mapper.Usermapper&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--id是用来定位具体是哪个方法来调用。</span><br><span class="hljs-comment">    resultType表示返回值类型，设置别名之后，只需要写类名就行了，不大小写--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findOne&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>写mapper,service,controller层，不要忘记注解</p>
<ul>
<li>mapper  @Repository</li>
<li>service @Service</li>
<li>controller @RestController 或者 @Controller 推荐使用@RestController</li>
</ul>
</li>
<li><p>在启动类上面，要写上@MapperScan(“mapper层所在的文件夹的全限定名”)注解，用来定位到mapper层。</p>
</li>
</ol>
<h2 id="springboot整合druid数据库连接池"><a href="#springboot整合druid数据库连接池" class="headerlink" title="springboot整合druid数据库连接池"></a>springboot整合druid数据库连接池</h2><ol>
<li>导入相关依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这两个坐标其实都是导入druid,但是上面的是可以进入到druid的监测页面(<a href="http://localhost:8080/druid)%EF%BC%8C%E6%89%80%E4%BB%A5%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%9D%90%E6%A0%87">http://localhost:8080/druid)，所以推荐使用上面的坐标</a></p>
<ol start="2">
<li>配置数据源</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/blog?serverTimezone=UTC</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br></code></pre></td></tr></table></figure>

<p>细心的人会发现其实这个和mybatis配置数据源是差不多的，只不过druid配置时多加了一个type属性</p>
<p><strong>type</strong>：用来设置数据库连接池的种类，我们是要整合druid，所以设置成druid。</p>
<ol start="3">
<li>配置druid的其他属性</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">spring:<br>  datasource:<br>    url: jdbc:mysql://localhost:3306/blog?serverTimezone=UTC<br>    driver-class-name: com.mysql.cj.jdbc.Driver<br>    password: 123456<br>    type: com.alibaba.druid.pool.DruidDataSource<br>    username: root<br><br><span class="hljs-comment">&lt;!--druid其它配置--&gt;</span><br>    druid:<br>      #初始化大小<br>      initial-size: 5<br>      #最多支持多少个活动会话<br>      max-active: 50<br>      #最小连接个数<br>      min-idle: 1<br>      #配置获取连接等待超时的时间，单位是毫秒<br>      max-wait: 60000<br>      #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒<br>      time-between-eviction-runs-millis: 60000<br>      #配置一个连接池最小的生存时间，单位是毫秒<br>      min-evictable-idle-time-millis: 300000<br>      # 用来检测连接是否有效的sql，要求是一个查询语句。<br>      # 如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用<br>      validation-query: SELECT 1 FROM DUAL<br>      # 建议配置为true，不影响性能，并且保证安全性。<br>      # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。<br>      test-while-idle: true<br>      # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能<br>      test-on-borrow: false<br>      # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能<br>      test-on-return: false<br>      # 打开PSCache，并且指定每个连接上PSCache的大小<br>      pool-prepared-statements: true<br>      max-pool-prepared-statement-per-connection-size: 20<br>      # 通过别名的方式配置扩展插件，多个英文逗号分隔，常用的插件有：<br>      #监控统计用的filter:stat<br>      # 日志用的filter:log4j<br>      # 防御sql注入的filter:wall<br>      filters: stat,wall,log4j<br>      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录<br>      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000<br>      # 合并多个DruidDataSource的监控数据<br>      useGlobalDataSourceStat: true<br></code></pre></td></tr></table></figure>

<p>filters这里配置有问题</p>
<ol start="4">
<li>其他的就和整合mybatis一样了。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/05/29/git/</url>
    <content><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><a id="more"></a>

<blockquote>
<p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点， 将文档的状态作为更新记录保存起来，也可以在任何时间点， 将更新记录恢复回来。</p>
</blockquote>
<h1 id="Git工作机制"><a href="#Git工作机制" class="headerlink" title="Git工作机制"></a>Git工作机制</h1><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423163817744.png" alt="image-20220423163817744"></p>
<p><strong>代码托管中心是基于网络服务器的远程代码仓库，我们一般简单称为远程库，如gitee，github</strong></p>
<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><table>
<thead>
<tr>
<th><strong>命令名称</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>git config –global user.name 用户名</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git config –global user.email 邮箱</td>
<td>设置用户签名</td>
</tr>
<tr>
<td><strong>git init</strong></td>
<td><strong>初始化本地库</strong></td>
</tr>
<tr>
<td><strong>git status</strong></td>
<td><strong>查看本地库状态</strong></td>
</tr>
<tr>
<td><strong>git add 文件名</strong></td>
<td><strong>添加到暂存区</strong></td>
</tr>
<tr>
<td><strong>git commit m “ 日志信息 “ 文件名</strong></td>
<td><strong>提交到本地库</strong></td>
</tr>
<tr>
<td><strong>git reflog</strong></td>
<td><strong>查看历史记录</strong></td>
</tr>
<tr>
<td><strong>git log</strong></td>
<td><strong>查看历史记录，详细信息</strong></td>
</tr>
<tr>
<td><strong>git reset hard 版本号</strong></td>
<td><strong>版本穿梭</strong></td>
</tr>
</tbody></table>
<h1 id="Git使用前配置"><a href="#Git使用前配置" class="headerlink" title="Git使用前配置"></a>Git使用前配置</h1><blockquote>
<p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p>
<ol>
<li><p>配置提交人姓名：git config –global user.name “提交人姓名” # (对当前系统用户有效)</p>
</li>
<li><p>配置提交人邮箱：git config –global user.email  “提交人邮箱” # (对当前系统用户有效)</p>
<p>作用：识别开发人员，与登良github的账户无关</p>
</li>
<li><p>查看git配置信息：git config –list</p>
</li>
</ol>
<p>注意<br>1.如果要对配置信息进行修改，重复上述命令即可。</p>
<ol start="2">
<li>配置只需要执行一次。</li>
</ol>
<p><strong>自己 <code>C:\Users\Augenestern</code> 下有个 <code>.gitconfig</code> 文件，打开里面就是我们设置的用户签名</strong></p>
</blockquote>
<h1 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h1><ul>
<li>初始化本地库：<code>git init</code><ul>
<li>git定位到要操作的文件目录，输入<code>git init</code>,生成一个.git的隐藏文件夹</li>
</ul>
</li>
<li>查看本地库状态：<code>git status</code><ul>
<li><code>git status</code>后有红色的表示该文件未被添加到暂存区</li>
</ul>
</li>
<li>添加暂存区：<code>git add 文件名</code><ul>
<li>添加成功后，<code>git status</code>会用绿色显示文件名</li>
<li>使用<code>git rm --cached 文件名</code>删除暂存区文件，只是删除暂存区，工作区文件还在</li>
<li>使用<code>git rm -r --cached .</code>清空暂存区文件</li>
</ul>
</li>
<li>提交本地库：<code>git commit -m &quot;日志信息&quot; 文件名</code><ul>
<li>提交之后，<code>git status</code>无文件显示</li>
</ul>
</li>
<li>查看历史版本：<code>git reflog</code>  查看版本信息  <code>git log</code>  查看版本详细信息</li>
<li>版本穿梭：<code>git reset --hard 版本号</code><ul>
<li>可以将版本恢复到指定版本号的版本</li>
</ul>
</li>
</ul>
<h2 id="图文讲解"><a href="#图文讲解" class="headerlink" title="图文讲解"></a>图文讲解</h2><p><strong>设置用户签名</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165805821.png" alt="image-20220423165805821"></p>
<p><strong>初始化本地库</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165848541.png" alt="image-20220423165848541"></p>
<p><strong>查看本地库状态</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165926361.png" alt="image-20220423165926361"></p>
<p><strong>新增文件后查看状态</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165958038.png" alt="image-20220423165958038"></p>
<p><strong>添加暂存区</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170017367.png" alt="image-20220423170017367"></p>
<p><strong>提交本地库</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170032291.png" alt="image-20220423170032291"></p>
<p><strong>修改文件</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170116877.png" alt="image-20220423170116877"></p>
<p><strong>查看历史版本</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170213186.png" alt="image-20220423170213186"></p>
<p><strong>版本穿梭</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170235756.png" alt="image-20220423170235756"></p>
<p><strong>版本切换原理</strong></p>
<p>Git 切换版本，底层其实是移动的HEAD 指针</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170324500.png" alt="image-20220423170324500"></p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><blockquote>
<ul>
<li>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支</li>
<li>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行</li>
<li>对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本</li>
</ul>
<p>分支的好处是同时并行推进多个功能开发，提高开发效率。</p>
<p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</p>
</blockquote>
<h1 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h1><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody></table>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><ul>
<li><p>查看分支：<code>git branch -v</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171330263.png" alt="image-20220423171330263"></p>
</li>
<li><p>创建分支：<code>git branch 分支名</code></p>
</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171405996.png" alt="image-20220423171405996"></p>
<ul>
<li><p>切换分支：<code>git checkout 分支名</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171442859.png" alt="image-20220423171442859"></p>
</li>
<li><p>修改分支</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171507205.png" alt="image-20220423171507205"></p>
</li>
<li><p>合并分支：<code>git merge 分支名</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423173526151.png" alt="image-20220423173526151"></p>
</li>
<li><blockquote>
<p>合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。</p>
<p>有两套完全不同的修改。 Git无法替我们决定使用哪一个。必须 人为决定新代码内容。</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/4e603c5ffb3f4383a1082cade9b10a4d.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>head 到 == 之前是主分支的代码，== 到 hot-fix 之前是hot-fix的代码，删除掉不需要保留的代码即可，同时删除三个标志位</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/0db79fb0322441b8bbed5c0434e07066.png" alt="在这里插入图片描述"></p>
<h1 id="Git团队协作"><a href="#Git团队协作" class="headerlink" title="Git团队协作"></a>Git团队协作</h1><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183055973.png" alt="image-20220423183055973"></p>
<h1 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h1><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183132491.png" alt="image-20220423183132491"></p>
<h1 id="Git和github"><a href="#Git和github" class="headerlink" title="Git和github"></a>Git和github</h1><h2 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h2><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容克隆到本地</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td>
</tr>
</tbody></table>
<h2 id="推送到github步骤"><a href="#推送到github步骤" class="headerlink" title="推送到github步骤"></a>推送到github步骤</h2><p><strong>创建远程库</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183208786.png" alt="image-20220423183208786"></p>
<p><strong>起别名</strong>：<code>git remote add 别名 远程地址</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183629968.png" alt="image-20220423183629968"></p>
<p><strong>推送到远程库</strong>：<code>git push 别名 分支</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183701561.png" alt="image-20220423183701561"></p>
]]></content>
  </entry>
  <entry>
    <title>fastapi多文件</title>
    <url>/2021/07/22/fastapi%E5%A4%9A%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><a id="more"></a>

<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">├── app<br>│   ├── __init__.<span class="hljs-keyword">py</span><br>│   ├── main.<span class="hljs-keyword">py</span><br>│   ├── dependencies.<span class="hljs-keyword">py</span><br>│   └── routers<br>│   │   ├── __init__.<span class="hljs-keyword">py</span><br>│   │   ├── <span class="hljs-built_in">items</span>.<span class="hljs-keyword">py</span><br>│   │   └── users.<span class="hljs-keyword">py</span><br>│   └── internal<br>│       ├── __init__.<span class="hljs-keyword">py</span><br>│       └── admin.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>app</code> 目录包含了所有内容。并且它有一个空文件 <code>app/__init__.py</code>，因此它是一个「Python 包」（「Python 模块」的集合）：<code>app</code>。</li>
<li>它包含一个 <code>app/main.py</code> 文件。由于它位于一个 Python 包（一个包含 <code>__init__.py</code> 文件的目录）中，因此它是该包的一个「模块」：<code>app.main</code>。</li>
<li>还有一个 <code>app/dependencies.py</code> 文件，就像 <code>app/main.py</code> 一样，它是一个「模块」：<code>app.dependencies</code>。</li>
<li>有一个子目录 <code>app/routers/</code> 包含另一个 <code>__init__.py</code> 文件，因此它是一个「Python 子包」：<code>app.routers</code>。</li>
<li>文件 <code>app/routers/items.py</code> 位于 <code>app/routers/</code> 包中，因此它是一个子模块：<code>app.routers.items</code>。</li>
<li>同样适用于 <code>app/routers/users.py</code>，它是另一个子模块：<code>app.routers.users</code>。</li>
<li>还有一个子目录 <code>app/internal/</code> 包含另一个 <code>__init__.py</code> 文件，因此它是又一个「Python 子包」：<code>app.internal</code>。</li>
<li><code>app/internal/admin.py</code> 是另一个子模块：<code>app.internal.admin</code>。</li>
</ul>
<h2 id="APIRouter"><a href="#APIRouter" class="headerlink" title="APIRouter"></a>APIRouter</h2><p>可以使用<code>APIRouter</code>为模块创建路径操作，可以与<code>FastAPI</code>类相同的方式创建一个实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入APIRouter</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter<br><span class="hljs-comment">#创建一个实例</span><br>router = APIRouter()<br><br><span class="hljs-comment">#像FastAPI一样创建路径操作，相当于一个迷你的FastAPI类</span><br><span class="hljs-meta">@router.get(&quot;/users/&quot;, tags=[&quot;users&quot;])</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_users</span>():</span><br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;Rick&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;Morty&quot;</span>&#125;]<br><br><br><span class="hljs-meta">@router.get(&quot;/users/me&quot;, tags=[&quot;users&quot;])</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_user_me</span>():</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;fakecurrentuser&quot;</span>&#125;<br><br><br><span class="hljs-meta">@router.get(&quot;/users/&#123;username&#125;&quot;, tags=[&quot;users&quot;])</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_user</span>(<span class="hljs-params">username: str</span>):</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: username&#125;<br></code></pre></td></tr></table></figure>



<h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><p><code>dependencies</code> 模块（<code>app/dependencies.py</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Header, HTTPException<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_token_header</span>(<span class="hljs-params">x_token: str = Header(<span class="hljs-params">...</span>)</span>):</span><br><br>    <span class="hljs-keyword">if</span> x_token != <span class="hljs-string">&quot;fake-super-secret-token&quot;</span>:<br><br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&quot;X-Token header invalid&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_query_token</span>(<span class="hljs-params">token: str</span>):</span><br>    <span class="hljs-keyword">if</span> token != <span class="hljs-string">&quot;jessica&quot;</span>:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&quot;No Jessica token provided&quot;</span>)<br></code></pre></td></tr></table></figure>



<h2 id="其他使用APIRouter的模块"><a href="#其他使用APIRouter的模块" class="headerlink" title="其他使用APIRouter的模块"></a>其他使用APIRouter的模块</h2><p><code>app/routers/items.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><br><span class="hljs-keyword">from</span> ..dependencies <span class="hljs-keyword">import</span> get_token_header<br><br><span class="hljs-comment">#给该模块下的所有路径操作进行统一的设置</span><br>router = APIRouter(<br>    prefix=<span class="hljs-string">&quot;/items&quot;</span>,  <span class="hljs-comment">#设置了路径， 地址都变成了 /items/xxxx</span><br>    tags=[<span class="hljs-string">&quot;items&quot;</span>],   <span class="hljs-comment">#设置了标签</span><br>    dependencies=[Depends(get_token_header)],  <span class="hljs-comment">#设置了依赖</span><br>    responses=&#123;<span class="hljs-number">400</span>:&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;NOT found&quot;</span>&#125;&#125;  <span class="hljs-comment">#设置了response</span><br>)<br><br>fake_items_db = &#123;<span class="hljs-string">&quot;plumbus&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;pty&quot;</span>&#125;,<span class="hljs-string">&quot;gun&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;gun&quot;</span>&#125;&#125;<br><br><br><span class="hljs-meta">@router.get(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_items</span>():</span><br>    <span class="hljs-keyword">return</span> fake_items_db<br><br><span class="hljs-meta">@router.get(&quot;/&#123;item_id&quot;)  #路径变为：/items/&#123;item_id&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_item</span>(<span class="hljs-params">item_id:str</span>):</span><br>    <span class="hljs-keyword">if</span> item_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> fake_items_db:<br>        <span class="hljs-keyword">raise</span>  HTTPException(status_code=<span class="hljs-number">400</span>,detail=<span class="hljs-string">&quot;not found&quot;</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:fake_items_db[item_id][<span class="hljs-string">&quot;name&quot;</span>],<span class="hljs-string">&quot;item_id&quot;</span>:item_id&#125;<br><br><span class="hljs-comment">#还可以再为某个路径操作单独设置，这样会和之前统一设置的进行叠加</span><br><span class="hljs-meta">@router.put(</span><br>    <span class="hljs-string">&quot;/&#123;item_id&#125;&quot;</span>,<br>    tags=[<span class="hljs-string">&quot;custom&quot;</span>],  <span class="hljs-comment">#有两个tags，items和custom</span><br>    responses=&#123;<span class="hljs-number">403</span>:&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;operation&quot;</span>&#125;&#125; <span class="hljs-comment">#有两个response：404和403</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_item</span>(<span class="hljs-params">item_id:str</span>):</span><br>    <span class="hljs-keyword">if</span> item_id!=<span class="hljs-string">&quot;plumbus&quot;</span>:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">403</span>,detail=<span class="hljs-string">&quot;you can only update plumbus&quot;</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;item_id&quot;</span>:item_id,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;the great&quot;</span>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>需要设置<code>dependencies</code>的时候的格式，<code>dependencies=[Depends(get_token_header)]</code>      <code>Depends</code>要用[]括起来了，我之前没括起来，报错</strong></p>
<h2 id="FastAPI主体"><a href="#FastAPI主体" class="headerlink" title="FastAPI主体"></a>FastAPI主体</h2><p>位于 <code>app/main.py</code> 的模块，在这里导入并使用<code>FastAPI</code>类，这将是你的应用程序中将所有内容联结在一起的主文件。</p>
<p>由于大部分逻辑都存在于自己的特定模块中，所以主文件的内容将非常简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends<br><br><span class="hljs-keyword">from</span> .dependencies <span class="hljs-keyword">import</span> get_token_header, get_query_token<br><span class="hljs-keyword">from</span> .internal <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .routers <span class="hljs-keyword">import</span> items, users<br><br><span class="hljs-comment">#需要注意这里的格式，Depends用[]括起来了，我之前没括起来，报错</span><br>app=FastAPI(dependencies=[Depends(get_query_token)])<br><br><span class="hljs-comment">#</span><br>app.include_router(items.router)<br>app.include_router(users.router)<br><br><span class="hljs-comment">#可以在主文件中对其他文件的router进行设置</span><br><span class="hljs-comment">#对interal/admin.py进行router设置</span><br>app.include_router(<br>    admin.router,<br>    prefix=<span class="hljs-string">&quot;/admin&quot;</span>,<br>    tags=[<span class="hljs-string">&quot;admin&quot;</span>],<br>    dependencies=[Depends(get_token_header)],<br>    responses=&#123;<span class="hljs-number">418</span>:&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;i&#x27;m a teapot&quot;</span>&#125;&#125;<br>)<br><br>app.get(<span class="hljs-string">&quot;/&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span>():</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="避免名称冲突"><a href="#避免名称冲突" class="headerlink" title="避免名称冲突"></a>避免名称冲突</h3><p>我们将直接导入 <code>items</code> 子模块，而不是仅导入其 <code>router</code> 变量。</p>
<p>这是因为我们在 <code>users</code> 子模块中也有另一个名为 <code>router</code> 的变量。</p>
<p>如果我们一个接一个地导入，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> .routers.items <span class="hljs-keyword">import</span> router<br><span class="hljs-keyword">from</span> .routers.users <span class="hljs-keyword">import</span> router<br></code></pre></td></tr></table></figure>

<p>来自 <code>users</code> 的 <code>router</code> 将覆盖来自 <code>items</code> 中的 <code>router</code>，我们将无法同时使用它们。</p>
<h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p>在上面我们会看到这样的代码，这些是从我们的文件中导入的模块，他们是怎么工作的呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .dependencies <span class="hljs-keyword">import</span> get_token_header, get_query_token<br><span class="hljs-keyword">from</span> .internal <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .routers <span class="hljs-keyword">import</span> items, users<br></code></pre></td></tr></table></figure>



<p>一个单点 <code>.</code>，例如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> .<span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">import</span> get_token_header<br></code></pre></td></tr></table></figure>

<p>表示：</p>
<ul>
<li>从该模块（<code>app/routers/items.py</code> 文件）所在的同一个包（<code>app/routers/</code> 目录）开始…</li>
<li>找到 <code>dependencies</code> 模块（一个位于 <code>app/routers/dependencies.py</code> 的虚构文件）…</li>
<li>然后从中导入函数 <code>get_token_header</code>。</li>
</ul>
<p>两个点 <code>..</code>，例如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> ..<span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">import</span> get_token_header<br></code></pre></td></tr></table></figure>

<p>表示：</p>
<ul>
<li>从该模块（<code>app/routers/items.py</code> 文件）所在的同一个包（<code>app/routers/</code> 目录）开始…</li>
<li>跳转到其父包（<code>app/</code> 目录）…</li>
<li>在该父包中，找到 <code>dependencies</code> 模块（位于 <code>app/dependencies.py</code> 的文件）…</li>
<li>然后从中导入函数 <code>get_token_header</code>。</li>
</ul>
<p>同样，如果我们使用了三个点 <code>...</code>，例如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> ...<span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">import</span> get_token_header<br></code></pre></td></tr></table></figure>

<p>那将意味着：</p>
<ul>
<li>从该模块（<code>app/routers/items.py</code> 文件）所在的同一个包（<code>app/routers/</code> 目录）开始…</li>
<li>跳转到其父包（<code>app/</code> 目录）…</li>
<li>然后跳转到该包的父包（该父包并不存在，<code>app</code> 已经是最顶层的包 😱）…</li>
<li>在该父包中，找到 <code>dependencies</code> 模块（位于 <code>app/</code> 更上一级目录中的 <code>dependencies.py</code> 文件）…</li>
<li>然后从中导入函数 <code>get_token_header</code>。</li>
</ul>
<p><code>from .routers import items, users</code></p>
<p>表示：</p>
<ul>
<li>从该模块（<code>app/main.py</code> 文件）所在的同一个包（<code>app/</code> 目录）开始…</li>
<li>寻找 <code>routers</code> 子包（位于 <code>app/routers/</code> 的目录）…</li>
<li>从该包中，导入子模块 <code>items</code> (位于 <code>app/routers/items.py</code> 的文件) 以及 <code>users</code> (位于 <code>app/routers/users.py</code> 的文件)…</li>
</ul>
<p><code>items</code> 模块将具有一个 <code>router</code> 变量（<code>items.router</code>）。这与我们在 <code>app/routers/items.py</code> 文件中创建的变量相同，它是一个 <code>APIRouter</code> 对象。</p>
<p>然后我们对 <code>users</code> 模块进行相同的操作。</p>
<h3 id="绝对引入"><a href="#绝对引入" class="headerlink" title="绝对引入"></a>绝对引入</h3><p><code>from app.routers import items, users</code>    如果是这种样子的话，就是绝对引入</p>
<h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><p><img src="/.com//Users\彭天怡\AppData\Roaming\Typora\typora-user-images\image-20210721180819459.png" alt="image-20210721180819459"></p>
<p><strong>API文档界面如上，可以看到因为给每个模块设置了tags，所以分成了不同的类，而<code>/items/&#123;item_id&#125;</code>因为设置了两个tags(统一设置了一个items，自己单独设置了custom)，所以显示出了两个。</strong></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>mapperLocations属性通配符的使用</title>
    <url>/2022/05/29/mapperLocations%E5%B1%9E%E6%80%A7%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">mybatis:<br>  mapper-locations:<br>    - classpath:mapper/*.xml<br>    - classpath*:com/**/mapper/*.xml<br></code></pre></td></tr></table></figure>



<p>*<em>注意：在classpath后面的</em>必不可少，缺少型号的话后面的通配符不起作用。**</p>
<p>** 可以表示任意多级目录，如上述文件可以查到 ：[com/pty/mall/tiny/mapper/PmsBrandMapper.xml]</p>
<p>*表示多个任意字符</p>
<p>缺少classpath后面的*会报一下错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for framework.system.dao.UserDao.getNextUserId_MySQL<br>### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for framework.system.dao.UserDao.getNextUserId_MySQL<br>	at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:<span class="hljs-number">75</span>)<br>	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:<span class="hljs-number">371</span>)<br>	at com.sun.proxy.$Proxy18.selectOne(Unknown Source)<br>	at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:<span class="hljs-number">163</span>)<br>	at com.huaxin.framework.core.dao.impl.BaseDaoImpl.selectOne(BaseDaoImpl.java:<span class="hljs-number">298</span>)<br>	at com.huaxin.framework.system.dao.impl.UserDaoImpl.getNextUserId(UserDaoImpl.java:<span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>java生成二维码</title>
    <url>/2021/04/27/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<h3 id="Java生成二维码"><a href="#Java生成二维码" class="headerlink" title="Java生成二维码"></a>Java生成二维码</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.zxing<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.zxing<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javase<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="不带logo"><a href="#不带logo" class="headerlink" title="不带logo"></a>不带logo</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pdf.pty;<br><br><br><span class="hljs-keyword">import</span> com.google.zxing.BarcodeFormat;<br><span class="hljs-keyword">import</span> com.google.zxing.EncodeHintType;<br><span class="hljs-keyword">import</span> com.google.zxing.MultiFormatWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.WriterException;<br><span class="hljs-keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.common.BitMatrix;<br><span class="hljs-keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Path;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QRCodeUtil</span> </span>&#123;<br>    <span class="hljs-comment">// 二维码尺寸</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QRCODE_SIZE = <span class="hljs-number">500</span>;<br>    <span class="hljs-comment">// LOGO宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WIDTH = <span class="hljs-number">400</span>;<br>    <span class="hljs-comment">// LOGO高度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEIGHT = <span class="hljs-number">400</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createQrcode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WriterException, IOException </span>&#123;<br>       <span class="hljs-comment">//二维码中的内容，这个内容一般都需要传参过来，我这里先写死</span><br>       String contents = <span class="hljs-string">&quot;http://baidu.com&quot;</span>;<br>       HashMap&lt;EncodeHintType, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//设置字符集</span><br>       map.put(EncodeHintType.CHARACTER_SET,<span class="hljs-string">&quot;utf-8&quot;</span>);<br>       <span class="hljs-comment">//设置纠错等级L/M/Q/H,等级越高越不容易识别，等级最高为H</span><br>       map.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);<br>       <span class="hljs-comment">//设置边框</span><br>       map.put(EncodeHintType.MARGIN,<span class="hljs-number">2</span>);<br>       <span class="hljs-comment">//设置生成的图片的后缀名</span><br>       String format = <span class="hljs-string">&quot;png&quot;</span>;<br>       BitMatrix bitMatrix = <span class="hljs-keyword">new</span> MultiFormatWriter().encode(contents, BarcodeFormat.QR_CODE, WIDTH, HEIGHT, map);<br>       <span class="hljs-comment">//设置输出地址</span><br>       Path file=<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:/new.png&quot;</span>).toPath();<br>       MatrixToImageWriter.writeToPath(bitMatrix,format,file);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一般来说上面的工具类已经够用了，但是有时候我们想搞点不一样的，比如说在二维码上面添加一个logo，这样让二维码看起来不一样，于是就有了下面这个工具类</p>
<h4 id="带logo"><a href="#带logo" class="headerlink" title="带logo"></a>带logo</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pdf.pty;<br><br><span class="hljs-keyword">import</span> com.google.zxing.BarcodeFormat;<br><span class="hljs-keyword">import</span> com.google.zxing.EncodeHintType;<br><span class="hljs-keyword">import</span> com.google.zxing.MultiFormatWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.WriterException;<br><span class="hljs-keyword">import</span> com.google.zxing.client.j2se.MatrixToImageConfig;<br><span class="hljs-keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.common.BitMatrix;<br><span class="hljs-keyword">import</span> com.itextpdf.text.pdf.qrcode.ErrorCorrectionLevel;<br><br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.geom.RoundRectangle2D;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QRCodeUtil</span> </span>&#123;<br>    <span class="hljs-comment">//二维码高度和宽度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WIDTH = <span class="hljs-number">400</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEIGHT = <span class="hljs-number">400</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WriterException, IOException </span>&#123;<br>        HashMap&lt;EncodeHintType, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//二维码内容</span><br>        String contents = <span class="hljs-string">&quot;http://baidu.com&quot;</span>;<br><br>        <span class="hljs-comment">//设置字符集</span><br>        map.put(EncodeHintType.CHARACTER_SET, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">//设置纠错等级</span><br>        map.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);<br>        <span class="hljs-comment">//设置边框</span><br>        map.put(EncodeHintType.MARGIN, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//生成二维码对应的位矩阵对象</span><br>        BitMatrix bitMatrix = <span class="hljs-keyword">new</span> MultiFormatWriter().encode(contents, BarcodeFormat.QR_CODE, WIDTH, HEIGHT, map);<br>        <span class="hljs-comment">//设置位矩阵转图片的参数</span><br>        MatrixToImageConfig config = <span class="hljs-keyword">new</span> MatrixToImageConfig(<span class="hljs-number">0xFF000001</span>, <span class="hljs-number">0xFFFFFFFF</span>);<br><br>        <span class="hljs-comment">// 位矩阵对象转BufferedImage对象</span><br>        BufferedImage qrcode = MatrixToImageWriter.toBufferedImage(bitMatrix, config);<br>        <span class="hljs-comment">//将不带logo的输出</span><br>        ImageIO.write(qrcode, <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://1.png&quot;</span>));<br><br>        BufferedImage QRcode = createQRCodeWithLogo(qrcode, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\logo.png&quot;</span>));<br>		<span class="hljs-comment">//将带logo的输出</span><br>        ImageIO.write(QRcode, <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://code.png&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;输出成功&quot;</span>);<br>    &#125;<br><br><br>	<span class="hljs-comment">//增加logo</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title">createQRCodeWithLogo</span><span class="hljs-params">(BufferedImage bufferedImage, File logofile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//创建绘图对象</span><br>        Graphics2D g2 = bufferedImage.createGraphics();<br><br><br><span class="hljs-comment">//设置logo的宽高,这里除4是为了让图片比二维码小，这里有个问题，可能是因为我的高和宽都设置为400，我一开始除3，发现生成的带logo的二维码无法识别，我猜想是因为400/3是一个浮点数，导致图片不全，当我除4、 5的时候就可以了。</span><br><br>        <span class="hljs-keyword">int</span> height = bufferedImage.getHeight()/<span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">int</span> width = bufferedImage.getWidth()/<span class="hljs-number">5</span>;<br><br>        <span class="hljs-comment">//设置logo在二维码图片上的起始坐标</span><br>        <span class="hljs-keyword">int</span> x = (bufferedImage.getWidth()-width)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> y = (bufferedImage.getHeight()-height)/<span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//读取logo文件</span><br>        BufferedImage logo = ImageIO.read(logofile);<br><br>        <span class="hljs-comment">//开始绘制图像</span><br>        g2.drawImage(logo,x,y,width,height,<span class="hljs-keyword">null</span>);<br><br>        BasicStroke stroke = <span class="hljs-keyword">new</span> BasicStroke(<span class="hljs-number">5</span>,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);<br>        g2.setStroke(stroke);<span class="hljs-comment">// 设置笔画对象</span><br>        <span class="hljs-comment">//指定弧度的圆角矩形</span><br>        RoundRectangle2D.Float round = <span class="hljs-keyword">new</span> RoundRectangle2D.Float(x,y,width,height,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>);<br>        g2.setColor(Color.white); <span class="hljs-comment">//指定圆弧边框的颜色</span><br>        g2.draw(round);<br><br>        g2.dispose();<br>        bufferedImage.flush();<br>        <span class="hljs-keyword">return</span> bufferedImage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>经测试发现，如果加入了圆弧边框，logo图片设置为二维码大小的1/4也是扫不出来的，1/5可以扫出来</strong></p>
]]></content>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2020/09/08/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示</p>
<p>一个#是一级标题，两个#是二级标题，以此类推。支持六级标题</p>
<a id="more"></a>

<p>并且在#后面加上空格之后在添加文字</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br><span class="hljs-section">#### 四级标题</span><br><span class="hljs-section">##### 五级标题</span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure>

<p>效果如下</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul>
<li><p>加粗</p>
<p>要加粗的文字左右分别使用两个*号包起来</p>
</li>
<li><p>斜体</p>
<p>使用一个*包起来</p>
</li>
<li><p>斜体加粗</p>
<p>使用三个*号包起来</p>
</li>
<li><p>删除线</p>
<p>使用两个~~号包起来</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**加粗**</span><br><span class="hljs-emphasis">*斜体*</span><br><span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗<span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span></span><br><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis">~~删除线~~</span></span></span></span><br></code></pre></td></tr></table></figure>

<p>效果如下</p>
<p><strong>加粗</strong><br><em>斜体</em><br><strong><em>斜体加粗</em></strong><br><del>删除线</del></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前面加&gt;即可，也可以嵌套使用，如加两个&gt;,三个&gt;,n个&gt;</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&gt;引用<br>&gt;&gt;引用2<br>&gt;&gt;&gt;引用3<br></code></pre></td></tr></table></figure>

<p>效果如下</p>
<blockquote>
<p>引用</p>
<blockquote>
<p>引用2</p>
<blockquote>
<p>引用3</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或三个以上的+ - *都可以</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">+++<br><span class="hljs-strong">****</span><span class="hljs-emphasis">*</span><br><span class="hljs-emphasis">----</span><br></code></pre></td></tr></table></figure>



<h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片alt</span>](<span class="hljs-link">图片地址 &quot;图片title&quot;</span>)<br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释<br>图片title是图片的标题，当鼠标移到图片上时显示的内容，title可加可不加<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">![blockchain](https:<span class="hljs-comment">//ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</span><br>u=<span class="hljs-number">702257389</span>,<span class="hljs-number">1274025419</span>&amp;fm=<span class="hljs-number">27</span>&amp;gp=<span class="hljs-number">0.</span>jpg <span class="hljs-string">&quot;区块链&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p>
<h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">超链接名</span>](<span class="hljs-link">超链接地址 &quot;超链接title&quot;</span>)<br>title 可加可不加<br>[百度] (http://www.baidu.com)<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="http://baidu.com/" title="百度">百度</a></p>
<p><strong>注意</strong>：markdown本身不支持超链接在新页面中打开，如果想在新页面中打开的话可以用html中的a标签来代替</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;超链接地址&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>超链接名<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>效果如下</p>
<p><a href="http://www.baidu.com" target="_blank">百度</a>  (但是这个好像也打开不了)</p>
<h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><p><strong>无序列表</strong></p>
<p>使用 + - * 任意一种都可以</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 无序列表<br><span class="hljs-bullet">+</span> 无序列表<br><span class="hljs-bullet">*</span> 无序列表<br></code></pre></td></tr></table></figure>

<p>效果如下</p>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<p><strong>有序列表</strong></p>
<p>数字加点    <em>在点的后面要加空格</em></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> <br><span class="hljs-bullet">2.</span> <br><span class="hljs-bullet">3.</span> <br></code></pre></td></tr></table></figure>

<p><strong>列表的嵌套</strong></p>
<p>只需要在字列表的选项前面添加4个空格即可</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表<br><span class="hljs-bullet">    -</span> 无序列表1<br><span class="hljs-bullet">    -</span> 无序列表2<br></code></pre></td></tr></table></figure>

<ol>
<li>有序列表<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markd">- 无序列表<br>    1. 有序列表<br>    2. 有序列表<br></code></pre></td></tr></table></figure>

<ul>
<li>无序列表<ol>
<li>有序列表</li>
<li>有序列表</li>
</ol>
</li>
</ul>
<h2 id="八、代码"><a href="#八、代码" class="headerlink" title="八、代码"></a>八、代码</h2><p>代码之间分别用一个反引号包起来</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`void main`</span><br></code></pre></td></tr></table></figure>

<p>效果如下</p>
<p><code>public static void main(String args[])</code></p>
<p><strong>代码块</strong></p>
<p>用四个反引号包起来，后面写语言名称(三个反引号也可以)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">````java    ```</span>java<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><br><br></code></pre></td></tr></table></figure>

<p>​        </p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis generator</title>
    <url>/2022/09/01/mbg%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>MyBatis的代码生成器，可以根据数据库生成model、mapper.xml、mapper接口。不需要自己手动创建java的实体类和mapper文件</p>
</blockquote>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyBatis 生成器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- MyBatis  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>这里导入1.3.7，因为版本低，会导致重复生成mapper.xml文件时是追加在文件上面，导致mapper.xml文件越来越长</strong></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>创建<code>generatorConfig.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span>  <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!--生成mapper.xml时覆盖原文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;</span> /&gt;</span><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!--数据库链接URL，用户名、密码,需要修改成自己的数据库配置 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mall?serverTimezone=Asia/Shanghai&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 生成实体类的包名和位置 ，targetPackage指的是包名,targetProject值得是路径位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.pty.mall.tiny.model&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 生成映射文件的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.pty.mall.tiny.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 生成DAO的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.pty.mall.tiny.mbg.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br><br>		<span class="hljs-comment">&lt;!-- tableName是数据库中表的名字，如果要生成所有的表，填写%--&gt;</span><br>         <span class="hljs-comment">&lt;!-- 后面几个配置也要写，不然会生成很多Example类和mapper--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;ums_admin_permission_relation&quot;</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableUpdateByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableDeleteByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableSelectByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">selectByExampleQueryId</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="运行Generator的main函数生成代码"><a href="#运行Generator的main函数生成代码" class="headerlink" title="运行Generator的main函数生成代码"></a>运行Generator的main函数生成代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于生产MBG的代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//MBG 执行过程中的警告信息</span><br>        List&lt;String&gt; warnings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        <span class="hljs-comment">//当生成的代码重复时，覆盖原代码</span><br>        <span class="hljs-keyword">boolean</span> overwrite = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//读取我们的 MBG 配置文件</span><br>        InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);<br>        ConfigurationParser cp = <span class="hljs-keyword">new</span> ConfigurationParser(warnings);<br>        Configuration config = cp.parseConfiguration(is);<br>        is.close();<br><br>        DefaultShellCallback callback = <span class="hljs-keyword">new</span> DefaultShellCallback(overwrite);<br>        <span class="hljs-comment">//创建 MBG</span><br>        MyBatisGenerator myBatisGenerator = <span class="hljs-keyword">new</span> MyBatisGenerator(config, callback, warnings);<br>        <span class="hljs-comment">//执行生成代码</span><br>        myBatisGenerator.generate(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//输出警告信息</span><br>        <span class="hljs-keyword">for</span> (String warning : warnings) &#123;<br>            System.out.println(warning);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="使用Generator插件生成代码"><a href="#使用Generator插件生成代码" class="headerlink" title="使用Generator插件生成代码"></a>使用Generator插件生成代码</h2><p><strong>在pom.xml中添加下面代码</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>运行mvn mybatis-generator:generate即可自动生成代码</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210322204729417.png" alt="image-20210322204729417"></p>
]]></content>
  </entry>
  <entry>
    <title>mybatis-plus更新部分列</title>
    <url>/2022/09/01/mybatis-plus%E6%9B%B4%E6%96%B0%E9%83%A8%E5%88%86%E5%88%97/</url>
    <content><![CDATA[<h3 id="方法一：先查询后更新"><a href="#方法一：先查询后更新" class="headerlink" title="方法一：先查询后更新"></a>方法一：先查询后更新</h3><p>先查询到实体，然后使用修改属性，在执行一次update操作</p>
<h3 id="方法二：使用UpdateWrapper"><a href="#方法二：使用UpdateWrapper" class="headerlink" title="方法二：使用UpdateWrapper"></a>方法二：使用UpdateWrapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> UpdateWrapper&lt;&gt;();<br><span class="hljs-comment">//设置where条件</span><br>wrapper.eq(<span class="hljs-string">&quot;id&quot;</span>,id);<br><span class="hljs-comment">//修改值，注意前面的是字段的名称，不是实体类</span><br>wrapper.set(<span class="hljs-string">&quot;header_url&quot;</span>,headerUrl);<br><span class="hljs-comment">//实体类传入null</span><br>userMapper.update(<span class="hljs-keyword">null</span>,wrapper);<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Php语言基础</title>
    <url>/2022/07/31/php/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<ul>
<li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li>
<li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li>
<li>函数之间存在作用域互不影响。</li>
<li>函数内访问全局变量需要 <strong>global</strong> 关键字或者使用 <strong>$GLOBALS[index]</strong> 数组</li>
</ul>
<p>在 php 中函数是有独立的作用域，所以局部变量会覆盖全局变量，即使局部变量中没有全局变量相同的变量，也会被覆盖。</p>
</blockquote>
<p>php是一门弱类型语言，声明变量时不需要声明变量的数据类型。</p>
<p>命名规则和Java一样，以字母或者下划线开头，只能用字母、下划线、数字命名。区分大小写。</p>
<p>声明变量时，使用<code>$</code>,后面紧跟变量名称。</p>
<p>如：<code>$a = 1</code></p>
<p>有四种变量定义域：</p>
<ul>
<li>local:局部作用域</li>
<li>global：全局作用域</li>
<li>static：静态作用域</li>
<li>parameter：参数作用域</li>
</ul>
<p>定义在所有函数之外的变量具有全局作用域。在一个函数内想要使用全局变量，需要使用<code>global</code>关键字。</p>
<p>PHP 将所有全局变量存储在一个名为 <code>$GLOBALS[*index*]</code>的数组中。 <em>index</em> 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$x=<span class="hljs-number">5</span>;<br>$y=<span class="hljs-number">10</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTest</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">global</span> $x,$y;<br>    $y=$x+$y;<br>&#125;<br> <br>myTest();<br><span class="hljs-keyword">echo</span> $y; <span class="hljs-comment">// 输出 15</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<p>当一个函数完成时，他定义的所有变量都会被删除，如果你不想某个局部变量被删除，可以使用static修饰。<strong>该变量仍然是函数的局部变量。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTest</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">static</span> $x=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">echo</span> $x;<br>    $x++;<br>    <span class="hljs-keyword">echo</span> PHP_EOL;    <span class="hljs-comment">// 换行符</span><br>&#125;<br> <br>myTest(); <span class="hljs-comment">//0</span><br>myTest(); <span class="hljs-comment">//1</span><br>myTest(); <span class="hljs-comment">//2</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量值被定义后，在脚本的其他任何地方都不能被改变，在整个脚本中都可以使用。</p>
<p>设置常量，使用 define() 函数，函数语法如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> define ( <span class="hljs-keyword">string</span> $name , mixed $value [, <span class="hljs-keyword">bool</span> $case_insensitive = <span class="hljs-literal">false</span> ] )<br></code></pre></td></tr></table></figure>

<p>该函数有三个参数:</p>
<ul>
<li><strong>name：</strong>必选参数，常量名称，即标志符。</li>
<li><strong>value：</strong>必选参数，常量的值。</li>
<li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li>
</ul>
<p><code>define(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;);</code></p>
<p>创建了一个变量名为GREETING的常量。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>可以使用<code>echo</code> 和<code>print</code>来进行打印输出，两者都可以使用括号或者不使用括号。</p>
<p>区别在于前者可以输出多个字符串，后者只可以输出一个字符串。</p>
<p>输出的字符可以包含html标签。</p>
<h2 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h2><p>虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。</p>
<ul>
<li>松散比较：使用两个等号 <strong>==</strong> 比较，只比较值，不比较类型。</li>
<li>严格比较：用三个等号 <strong>===</strong> 比较，除了比较值，也比较类型。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">42</span> == <span class="hljs-string">&quot;42&quot;</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;1、值相等&#x27;</span>;<br>&#125;<br> <br><span class="hljs-keyword">echo</span> PHP_EOL; <span class="hljs-comment">// 换行符</span><br> <br><span class="hljs-keyword">if</span>(<span class="hljs-number">42</span> === <span class="hljs-string">&quot;42&quot;</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;2、类型相等&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;3、类型不相等&#x27;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br>  <br><span class="hljs-comment">// 1、值相等 3、类型不相等</span><br></code></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>定义字符串的时候需要使用单引号或者双引号括起来。</p>
<h3 id="并置运算符"><a href="#并置运算符" class="headerlink" title="并置运算符"></a>并置运算符</h3><p>将两个字符串连接起来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$txt1=<span class="hljs-string">&quot;Hello world!&quot;</span>;<br>$txt2=<span class="hljs-string">&quot;What a nice day!&quot;</span>;<br><span class="hljs-keyword">echo</span> $txt1 . $txt2;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p>返回字符串的长度</p>
<h3 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a>strpos()</h3><p>在字符串中查找一个字符或者指定的文本。如果存在返回第一个匹配的字符的位置，否则返回false。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> strpos(<span class="hljs-string">&quot;Hello world!&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br>  <br><span class="hljs-comment">//返回6</span><br></code></pre></td></tr></table></figure>





<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数主要用来在创建对象时初始化对象，即为对象成员变量赋初值。</p>
<p>使用<code>_construct</code>关键字定义。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数和构造函数相反，当对象结束其生命周期时系统自动执行析构函数。</p>
<p>使用<code>_destruct</code>关键字定义。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类可以继承父类，使用<code>extends</code>关键字。</p>
<p>继承之后，子类拥有父类的所有东西，包括protected、private，但是父类私有的属性和方法不能让子类直接调用。子类可以扩展自己的属性和方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口使用<code>interface</code>定义，接口中的所有方法都必须是公有的。php可以实现多个接口，实现接口时必须实现接口定义的所有方法，使用<code>implements</code>实现接口。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类里面有一个抽象方法，那么这个类必须是抽象类。抽象类不能被实例化。</p>
<p>继承一个抽象类的时候，必须重写所有的抽象方法；并且这些方法的访问权限必须大于等于父类的访问权限。使用<code>abstruct</code>修饰抽象方法和抽象类。</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>声明属性或者方法为static，就可以不实例化类而直接访问。</p>
<p>静态属性不能通过一个实例化的对象来访问，静态方法可以。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> $my_static = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">staticValue</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::$my_static;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">print</span> Foo::$my_static . PHP_EOL;<br>$foo = <span class="hljs-keyword">new</span> Foo();<br><br><span class="hljs-keyword">print</span> $foo-&gt;staticValue() . PHP_EOL;<br><span class="hljs-meta">?&gt;</span>  <br>  <br><span class="hljs-comment">//foo</span><br><span class="hljs-comment">//foo</span><br></code></pre></td></tr></table></figure>

<h3 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h3><p>如果父类中的方法被声明为final，则子类无法覆盖该方法。如果一个类被声明为final，则不能被继承。</p>
<h3 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h3><p>php不像java，php不会自动调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用<code>parent::_construct()</code></p>
<h3 id="date-函数"><a href="#date-函数" class="headerlink" title="date()函数"></a>date()函数</h3><p>date()函数用于格式化时间/日期。</p>
<p><code>string date ( string $format [, int $timestamp ] )</code></p>
<ul>
<li>format:必需。规定时间戳的格式。</li>
<li>timestamp:可选。规定时间戳。默认是当前的日期和时间。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y/m/d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y.m.d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y-m-d&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	2016/10/21</span><br><span class="hljs-comment">	2016.10.21</span><br><span class="hljs-comment">	2016-10-21</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>

<p>date() 函数的第一个必需参数 <em>format</em> 规定了如何格式化日期/时间。</p>
<p>这里列出了一些可用的字符：</p>
<ul>
<li>d - 代表月中的天 (01 - 31)</li>
<li>m - 代表月 (01 - 12)</li>
<li>Y - 代表年 (四位数)</li>
</ul>
<h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p>假设您有一个标准的页头文件，名为 “header.php”。如需在页面中引用这个页头文件，请使用 include/require：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;header.php&#x27;</span>; <span class="hljs-meta">?&gt;</span><br>&lt;h1&gt;欢迎来到我的主页!&lt;/h1&gt;<br>&lt;p&gt;一些文本。&lt;/p&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p>require() 语句的性能与 include() 相类似，都是包括并运行指定文件。不同之处在于：对 include() 语句来说，在执行文件时每次都要进行读取和评估；而对于 require() 来说，文件只处理一次（实际上，文件内容替换 require() 语句）。这就意味着如果可能执行多次的代码，则使用 require() 效率比较高。</p>
<ul>
<li><p>require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；==在一开始就加载==</p>
</li>
<li><p>include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。==用到时才加载==</p>
</li>
<li><p>require 引入的文件有错误时，执行会中断，并返回一个致命错误；</p>
</li>
<li><p>include 引入的文件有错误时，会继续执行，并返回一个警告。</p>
</li>
</ul>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>fopen() 函数用于在 PHP 中打开文件。</p>
<p>此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">只读。在文件的开头开始。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">读/写。在文件的开头开始。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">只写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">读/追加。通过向文件末尾写内容，来保持文件内容。</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td>
</tr>
<tr>
<td align="left">x+</td>
<td align="left">读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td>
</tr>
</tbody></table>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">&lt;html&gt;<br>&lt;body&gt;<br><br><span class="hljs-meta">&lt;?php</span><br>$file=fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);  <span class="hljs-comment">//以只读的形式打开文件</span><br><span class="hljs-meta">?&gt;</span><br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p><strong>如果无法打开文件则fopen()函数会返回0</strong></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>fclose() 函数用于关闭打开的文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$file = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">//执行一些代码</span><br><br>fclose($file);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="检测文件末尾（EOF）"><a href="#检测文件末尾（EOF）" class="headerlink" title="检测文件末尾（EOF）"></a>检测文件末尾（EOF）</h3><p>feof() 函数检测是否已到达文件末尾（EOF）。</p>
<p>在循环遍历未知长度的数据时，feof() 函数很有用。</p>
<p><strong>注释：</strong>在 w 、a 和 x 模式下，您无法读取打开的文件！</p>
<p><code>if (feof($file)) echo &quot;文件结尾&quot;;</code></p>
<h3 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h3><p>fgets() 函数用于从文件中逐行读取文件。</p>
<p><strong>注释：</strong>在调用该函数之后，文件指针会移动到下一行。</p>
<p>下面的实例逐行读取文件，直到文件末尾为止：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$file = fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;无法打开文件!&quot;</span>);<br><span class="hljs-comment">// 读取文件每一行，直到文件结尾</span><br><span class="hljs-keyword">while</span>(!feof($file))<br>&#123;<br>  <span class="hljs-keyword">echo</span> fgets($file). <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>&#125;<br>fclose($file);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="逐字符读取文件"><a href="#逐字符读取文件" class="headerlink" title="逐字符读取文件"></a>逐字符读取文件</h3><p>fgetc() 函数用于从文件中逐字符地读取文件。</p>
<p><strong>注释：</strong>在调用该函数之后，文件指针会移动到下一个字符。</p>
<p>下面的实例逐字符地读取文件，直到文件末尾为止：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$file=fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;无法打开文件!&quot;</span>);<br><span class="hljs-keyword">while</span> (!feof($file))<br>&#123;<br>  <span class="hljs-keyword">echo</span> fgetc($file);<br>&#125;<br>fclose($file);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p><a href="https://www.runoob.com/php/php-file-upload.html">详情参考如下链接</a></p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote>
<p>cookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。</p>
</blockquote>
<h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><p>setcookie() 函数用于设置 cookie。<strong>setcookie() 函数必须位于 <html> 标签之前。</html></strong></p>
<p><code>setcookie(name, value, expire, path, domain);</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>setcookie(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;runoob&quot;</span>, time()+<span class="hljs-number">3600</span>);<br><span class="hljs-meta">?&gt;</span><br><br>&lt;html&gt;<br>.....<br></code></pre></td></tr></table></figure>



<h3 id="取回cookie"><a href="#取回cookie" class="headerlink" title="取回cookie"></a>取回cookie</h3><p>PHP 的 $_COOKIE 变量用于取回 cookie 的值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 输出 cookie 值</span><br><span class="hljs-keyword">echo</span> $_COOKIE[<span class="hljs-string">&quot;user&quot;</span>];<br><br><span class="hljs-comment">// 查看所有 cookie</span><br>print_r($_COOKIE);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h3><p>当删除 cookie 时，您应当使过期日期变更为过去的时间点。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 设置 cookie 过期时间为过去 1 小时</span><br>setcookie(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, time()<span class="hljs-number">-3600</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>





<h2 id="SESSION"><a href="#SESSION" class="headerlink" title="SESSION"></a>SESSION</h2><p>PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。</p>
<p>在使用php session之前，需要先开启php session</p>
<p><code>session_start();</code>,这个函数必须位于<html>标签之前</html></p>
<p>session_start()会向服务器注册用户的会话，以便您可以开始保存用户信息，同时会为用户会话分配一个 UID。</p>
<h3 id="存储session"><a href="#存储session" class="headerlink" title="存储session"></a>存储session</h3><p>存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>session_start();<br><span class="hljs-comment">// 存储 session 数据</span><br>$_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-meta">?&gt;</span><br> <br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 检索 session 数据</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;浏览量：&quot;</span>. $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p>在下面的实例中，我们创建了一个简单的 page-view 计数器。isset() 函数检测是否已设置 “views” 变量。如果已设置 “views” 变量，我们累加计数器。如果 “views” 不存在，则创建 “views” 变量，并把它设置为 1：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>session_start();<br> <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]))<br>&#123;<br>    $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]=$_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;浏览量：&quot;</span>. $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="销毁SESSION"><a href="#销毁SESSION" class="headerlink" title="销毁SESSION"></a>销毁SESSION</h3><p>使用 unset() 或 session_destroy() 函数销毁session。</p>
<p>unset() 函数用于释放指定的 session 变量；session_destroy() 函数彻底销毁 session：</p>
<p><code>unset($_SESSION[&#39;views&#39;]); 或者  session_destroy();</code></p>
]]></content>
  </entry>
  <entry>
    <title>python创建Token</title>
    <url>/2021/07/17/python%20%E5%88%9B%E5%BB%BAjwt/</url>
    <content><![CDATA[<h1 id="Python创建Token"><a href="#Python创建Token" class="headerlink" title="Python创建Token"></a>Python创建Token</h1><h2 id="关于-JWT"><a href="#关于-JWT" class="headerlink" title="关于 JWT"></a>关于 JWT</h2><p>JWT 表示 「JSON Web Tokens」。</p>
<p>它是一个将 JSON 对象编码为密集且没有空格的长字符串的标准。字符串看起来像这样：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>.eyJzdWIiOiIxMjM<span class="hljs-number">0</span>NTY<span class="hljs-number">3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>IkpvaG<span class="hljs-number">4</span>gRG<span class="hljs-number">9</span>lIiwiaWF<span class="hljs-number">0</span>IjoxNTE<span class="hljs-number">2</span>MjM<span class="hljs-number">5</span>MDIyfQ.SflKxwRJSMeKKF<span class="hljs-number">2</span>QT<span class="hljs-number">4</span>fwpMeJf<span class="hljs-number">36</span>POk<span class="hljs-number">6</span>yJV_adQssw<span class="hljs-number">5</span>c<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<p>它没有被加密，因此任何人都可以从字符串内容中还原数据。</p>
<p>但它经过了签名。因此，当你收到一个由你发出的令牌时，可以校验令牌是否真的由你发出。</p>
<p>通过这种方式，你可以创建一个有效期为 1 周的令牌。然后当用户第二天使用令牌重新访问时，你知道该用户仍然处于登入状态。</p>
<p>一周后令牌将会过期，用户将不会通过认证，必须再次登录才能获得一个新令牌。而且如果用户（或第三方）试图修改令牌以篡改过期时间，你将因为签名不匹配而能够发觉。</p>
<h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3><h4 id="Header头部"><a href="#Header头部" class="headerlink" title="Header头部"></a>Header头部</h4><p>头部包含了两部分，token类型和采用的加密算法</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;alg&quot;</span>:<span class="hljs-string">&quot;HS256&quot;</span><br>    <span class="hljs-string">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>会使用Base64编码组成JWT结构的第一部分。</p>
<h4 id="Payload负载"><a href="#Payload负载" class="headerlink" title="Payload负载"></a>Payload负载</h4><p>负载就是存放有效信息的地方，这些有效信息包含三个部分。</p>
<ul>
<li>标准中注册声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<h5 id="公共的声明："><a href="#公共的声明：" class="headerlink" title="公共的声明："></a>公共的声明：</h5><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<h5 id="私有的声明："><a href="#私有的声明：" class="headerlink" title="私有的声明："></a>私有的声明：</h5><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;iss&quot;</span>: <span class="hljs-string">&quot;lion1ou JWT&quot;</span>,<br>    <span class="hljs-attr">&quot;iat&quot;</span>: <span class="hljs-number">1441593502</span>,<br>    <span class="hljs-attr">&quot;exp&quot;</span>: <span class="hljs-number">1441594722</span>,<br>    <span class="hljs-attr">&quot;aud&quot;</span>: <span class="hljs-string">&quot;www.example.com&quot;</span>,<br>    <span class="hljs-attr">&quot;sub&quot;</span>: <span class="hljs-string">&quot;lion1ou@163.com&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 包括需要传递的用户信息；</span><br>&#123; <br>  <span class="hljs-attr">&quot;iss&quot;</span>: <span class="hljs-string">&quot;Online JWT Builder&quot;</span>, <br>  <span class="hljs-attr">&quot;iat&quot;</span>: <span class="hljs-number">1416797419</span>, <br>  <span class="hljs-attr">&quot;exp&quot;</span>: <span class="hljs-number">1448333419</span>, <br>  <span class="hljs-attr">&quot;aud&quot;</span>: <span class="hljs-string">&quot;www.gusibi.com&quot;</span>, <br>  <span class="hljs-attr">&quot;sub&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span>, <br>  <span class="hljs-attr">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;goodspeed&quot;</span>, <br>  <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;goodspeed&quot;</span>, <br>  <span class="hljs-attr">&quot;scopes&quot;</span>: [ <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;user&quot;</span> ] <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>iss: 该JWT的签发者，是否使用是可选的；</li>
<li>sub: 该JWT所面向的用户，是否使用是可选的；</li>
<li>aud: 接收该JWT的一方，是否使用是可选的；</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳，是否使用是可选的</li>
<li>iat(issued at): 在什么时候签发的(UNIX时间)，是否使用是可选的；</li>
<li>nbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的；</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分。</li>
<li>Signature 签名<br>前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 根据alg算法与私有秘钥进行加密得到的签名字串；</span><br><span class="hljs-comment">// 这一段是最重要的敏感信息，只能在服务端解密；</span><br>HMACSHA256(  <br>    base64UrlEncode(header) + &quot;.&quot; +<br>    base64UrlEncode(payload),<br>    SECREATE_KEY<br>)<br></code></pre></td></tr></table></figure>

<p>三个部分通过.连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s<br></code></pre></td></tr></table></figure>



<h3 id="签名的目的"><a href="#签名的目的" class="headerlink" title="签名的目的"></a>签名的目的</h3><p>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</p>
<blockquote>
<p>itsdangerous(使用固定密钥/字符串进行加密, jwt 有多种加密方式, 这只是其中一种, 建议先去了解一下)所生成的 token 仍然是可以被破译从而看到 jwt 的 payload(有效负载) 里的数据, 只不过因为破译者并不知道加密的密钥, 也就无法对数据进行篡改, 所以如果是私密的数据, 就不应该使用 jwt 进行传递, 如 账号的密码, 以防止泄露. 如果需要传递私密数据, 解决办法是,对 payload 的数据进行加密,从而杜绝非法破译者看到 payload 内的任何信息,但是目前加密payload的操作不是很普及,在不加密 payload 的前提下, jwt 比较适合进行非受信任端的身份验证, 此时即使接收方破译了 token, 看到了 payload 的数据, 也不会造成太大的影响, 因为数据是无法被篡改的(当接收方将 token 值返回给服务器后, 需要使用相同的密钥进行解密, 所以服务器的密钥一定要保管好), 只要接收方将 token 原封不动的返回给服务器, 那么服务器就可以根据 token 值的内容来确认接收方身份的合法性,而不需要关心接收方是否看到过 payload 的内容.</p>
<p>　简而言之, 除非额外对 payload 加密过, 否则就不要在 jwt 中传递不可被第三方获知的私密数据</p>
</blockquote>
<h2 id="安装python-jose"><a href="#安装python-jose" class="headerlink" title="安装python-jose"></a>安装<code>python-jose</code></h2><p>需要安装<code>python-jose</code>以在Python中生成和校验JWT令牌：</p>
<p><code>pip install python-jose</code></p>
<h2 id="生成和解析jwt"><a href="#生成和解析jwt" class="headerlink" title="生成和解析jwt"></a>生成和解析jwt</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#从jose导入jwt，用于token的生成和验证</span><br><span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwt<br><br><span class="hljs-comment">#导入日期模块，用来设置和验证token的过期时间</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span>  datetime,timedelta<br><br><span class="hljs-comment">#密钥，这个很重要，可以通过他来验证是否是自己签发的token</span><br><span class="hljs-comment">#内容可以随便写，也可以不定义变量</span><br>SECRT_KEY=<span class="hljs-string">&quot;hut@pty&quot;</span><br><br><span class="hljs-comment">#生成token的代码，token过期时长定义为默认参数，单位为秒</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_token</span>(<span class="hljs-params">seconds=<span class="hljs-number">60</span></span>):</span><br>    <span class="hljs-comment">#定义过期时间，当前时间+60秒</span><br>    expire = datetime.utcnow()+timedelta(seconds=seconds)<br>    <span class="hljs-comment">#定义签发时间</span><br>    iat = datetime.utcnow()<br><br>    <span class="hljs-comment">#定义token的payload，设置了过期时间,签发时间，username（自定义）...</span><br>    <span class="hljs-comment">#此处的to_encode还可以是空的字典，但是不建议这样</span><br>    to_encode=&#123;<span class="hljs-string">&quot;expire&quot;</span>:expire,<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;pty&quot;</span>,<span class="hljs-string">&quot;iat&quot;</span>:iat&#125;<br><br>    <span class="hljs-comment">#使用jwt生成token，传入payload、签名、验证算法</span><br>    token =jwt.encode(to_encode,SECRT_KEY,<span class="hljs-string">&quot;HS256&quot;</span>)<br>    <span class="hljs-keyword">return</span> token<br><br><br><span class="hljs-comment">#解析jwt</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verify_token</span>(<span class="hljs-params">token:str</span>):</span><br>    <span class="hljs-comment">#解析jwt，需要传入token，签名，验证算法，返回token的payload</span><br>    payload = jwt.decode(token,SECRT_KEY,<span class="hljs-string">&quot;HS256&quot;</span>)<br>    <span class="hljs-comment">#可以取出payload的值</span><br>    username = payload.get(<span class="hljs-string">&quot;username&quot;</span>)<br></code></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>python</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>redis黑马</title>
    <url>/2022/05/29/redis%20%E9%BB%91%E9%A9%AC/</url>
    <content><![CDATA[<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><a id="more"></a>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String命名方式"><a href="#String命名方式" class="headerlink" title="String命名方式"></a>String命名方式</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305145240506.png" alt="image-20220305145240506"></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305145458174.png" alt="image-20220305145458174"></p>
<p><img src="/.com//blog\java复习\image-20220305150210040.png" alt="image-20220305150210040"></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305153327413.png" alt="image-20220305153327413"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305154418649.png" alt="image-20220305154418649"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305155510456.png" alt="image-20220305155510456"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305160246063.png" alt=" "></p>
<p><strong>==用于随机推送==</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305160742714.png" alt="image-20220305160742714"></p>
<h3 id="sorted-set-zset"><a href="#sorted-set-zset" class="headerlink" title="sorted_set(zset)"></a>sorted_set(zset)</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305162453500.png" alt="image-20220305162453500"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305162845435.png" alt="image-20220305162845435"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305163730760.png" alt="image-20220305163730760"></p>
<p><strong>做排行榜</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305170913560.png" alt="image-20220305170913560"></p>
<h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305215551318.png" alt="image-20220305215551318"></p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p><strong>应用场景：在统计访问量的时候，一个人多次访问一个网站，还是算作一个人。这个时候就需要统计基数。</strong></p>
<p>==占用的内存是固定的，2^64个不同元素的基数，只需要12kb的内存。==</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306102643155.png" alt="image-20220306102643155"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306102839532.png" alt="image-20220306102839532"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306103049254.png" alt="image-20220306103049254"></p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p><strong>只能计算水平，不能计算垂直距离，如果你在山下，他在山上，可能距离只有几百米。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306103528145.png" alt="image-20220306103528145"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306103748591.png" alt="image-20220306103748591"></p>
<h2 id="服务器的配置"><a href="#服务器的配置" class="headerlink" title="服务器的配置"></a>服务器的配置</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305214048604.png" alt="image-20220305214048604"></p>
<p><strong>日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频率</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305214235538.png" alt="image-20220305214235538"></p>
<p>单位是秒</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305214350250.png" alt="image-20220305214350250"></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305174451622.png" alt="image-20220305174451622"></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="save指令"><a href="#save指令" class="headerlink" title="save指令"></a>save指令</h4><p>使用<code>save</code>命令手动执行保存操作，会生成一个叫<code>dump.rdb</code>的文件来保存快照信息</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305174849937.png" alt="image-20220305174849937"></p>
<p><strong><code>save</code>指令的执行会阻塞当前redis服务器，知道当前rdb过程完成为止，有可能会造成上时间阻塞，线上环境不建议使用</strong></p>
<h4 id="bgsave指令"><a href="#bgsave指令" class="headerlink" title="bgsave指令"></a>bgsave指令</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305175814214.png" alt="image-20220305175814214"></p>
<p>提交保存命令，有服务器后台决定什么时候保存，不是马上保存</p>
<h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180017057.png" alt="image-20220305180017057"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180026755.png" alt="image-20220305180026755"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180600421.png" alt="image-20220305180600421"></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180951059.png" alt="image-20220305180951059"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181055702.png" alt="image-20220305181055702"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181326611.png" alt="image-20220305181326611"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181842686.png" alt="image-20220305181842686"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181941904.png" alt="image-20220305181941904"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305182455183.png" alt="image-20220305182455183"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305182937777.png" alt="image-20220305182937777"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305183043020.png" alt="image-20220305183043020"></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305183124698.png" alt="image-20220305183124698"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305183517150.png" alt="image-20220305183517150"></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305203544777.png" alt="image-20220305203544777"></p>
<p><strong>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305203944796.png" alt="image-20220305203944796"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305204337363.png" alt="image-20220305204337363"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305204549831.png" alt="image-20220305204549831"></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305204811840.png" alt="image-20220305204811840"></p>
<p><strong>在事务之前添加watch，不能在开启事务之后再添加watch</strong></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305205411064.png" alt="image-20220305205411064"></p>
<p><strong>必须锁同一个对象</strong></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305205943153.png" alt="image-20220305205943153"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305210015123.png" alt="image-20220305210015123"></p>
<h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p><strong>过期数据：</strong>设置了有效期但是已经超时的数据</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305211027639.png" alt="image-20220305211027639"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305211205516.png" alt="image-20220305211205516"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212158883.png" alt="image-20220305212158883"></p>
<p><img src="/.com//blog\java复习\image-20220305212252768.png" alt="image-20220305212252768"></p>
<p><strong>redis内部使用了惰性删除和定期删除</strong></p>
<h3 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212527850.png" alt="image-20220305212527850"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212626026.png" alt="image-20220305212626026"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212931160.png" alt="image-20220305212931160"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305213138141.png" alt=" "></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306104858862.png" alt="image-20220306104858862"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306105058615.png" alt="image-20220306105058615"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306105153719.png" alt="image-20220306105153719"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306105912646.png" alt="image-20220306105912646"></p>
<h3 id="主从复制的工作流程"><a href="#主从复制的工作流程" class="headerlink" title="主从复制的工作流程"></a>主从复制的工作流程</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306110202558.png" alt="image-20220306110202558"></p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306110504327.png" alt="image-20220306110504327"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306111313162.png" alt="image-20220306111313162"></p>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306111841231.png" alt="image-20220306111841231"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306112310778.png" alt="image-20220306112310778"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306112547878.png" alt="image-20220306112547878"></p>
<h4 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306112817915.png" alt="image-20220306112817915"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113039939.png" alt="image-20220306113039939"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113445015.png" alt="image-20220306113445015"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113621935.png" alt="image-20220306113621935"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113656411.png" alt="image-20220306113656411"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306114227118.png" alt="image-20220306114227118"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306114520969.png" alt="image-20220306114520969"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306114806850.png" alt="image-20220306114806850"></p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306120410301.png" alt="image-20220306120410301"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306120502893.png" alt="image-20220306120502893"></p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306153648226.png" alt="image-20220306153648226"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154156940.png" alt="image-20220306154156940"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154218457.png" alt="image-20220306154218457"></p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><ul>
<li>请求数量较高</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306155730705.png" alt="image-20220306155730705"></p>
<p><strong>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统，避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</strong></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160005562.png" alt="image-20220306160005562"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160056409.png" alt="image-20220306160056409"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160221880.png" alt="image-20220306160221880"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160330647.png" alt="image-20220306160330466"></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160852994.png" alt="image-20220306160852994"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160922045.png" alt="image-20220306160922045"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160958459.png" alt="image-20220306160958459"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161158132.png" alt="image-20220306161158132"></p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161223740.png" alt="image-20220306161223740"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161306116.png" alt="image-20220306161306116"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161347227.png" alt="image-20220306161347227"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161425855.png" alt="image-20220306161425855"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161809827.png" alt="image-20220306161809827"></p>
]]></content>
  </entry>
  <entry>
    <title>python连接mysql</title>
    <url>/2021/07/22/python%20%E8%BF%9E%E6%8E%A5mysql/</url>
    <content><![CDATA[<p>在看fastapi的官方文档，然后感觉sql部分挺难的，于是写下一篇博客来记录下。</p>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>首先要安装两个东西</p>
<p><code>pip install sqlalchemy</code></p>
<p><code>pip install pymysql</code></p>
<p>前者是一个ORM框架，在ORM中，你创建一个类就会通过SQLAlchemy将其自动转成一张表，在类中的每一个属性就会转成表中的字段。</p>
<p>后者是用来连接数据库的</p>
<a id="more"></a>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><br>└── <span class="hljs-selector-tag">sql_app</span><br>    ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">crud</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">database</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">models</span><span class="hljs-selector-class">.py</span><br>    └── <span class="hljs-selector-tag">schemas</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure>

<ul>
<li>sql_app是包名，注意是创建一个包，而不是创建一个目录</li>
<li><code>_init_.py</code>是一个空文件，创建sql_app会自动创建这个文件</li>
<li><code>crud.py</code>是用来进行crud操作的文件</li>
<li><code>database.py</code>是用来连接数据库的</li>
<li><code>main.py</code>是用来接受前端请求，类似于controller层</li>
<li><code>models.py</code>是用来创建SQLAlchemy模型的，也就是创建表</li>
<li><code>schemas.py</code>是用来创建Pydentic模型的</li>
</ul>
<h2 id="database-py"><a href="#database-py" class="headerlink" title="database.py"></a>database.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, declarative_base<br><br><span class="hljs-comment">#连接数据库的url</span><br>SQLALCHEMY_DATABASES_URL =<span class="hljs-string">&quot;mysql+pymysql://root:123456@localhost:3306/python&quot;</span><br><br><span class="hljs-comment">#echo=True表示引擎将用repr()函数记录所有语句及其参数列表到日志</span><br>engine = create_engine(SQLALCHEMY_DATABASES_URL,encoding=<span class="hljs-string">&quot;utf8&quot;</span>,echo=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment">#SQLAlchemy中，CRUD是通会话进行管理的，所以需要先创建会话</span><br><span class="hljs-comment">#每一个SessionLocal实例就是一个数据库会话</span><br><span class="hljs-comment">#commit是指提交事务，将变更保存到数据库</span><br><span class="hljs-comment">#flush是指发送到数据库语句到数据库，但数据库不一定执行写入磁盘</span><br><span class="hljs-comment">#autocommit和autoflush是可以不写的</span><br>SessionLocal = sessionmaker(autocommit=<span class="hljs-literal">False</span>,autoflush=<span class="hljs-literal">False</span>,bind=engine)<br><br><span class="hljs-comment">#创建基本映射类</span><br>Base = declarative_base()<br></code></pre></td></tr></table></figure>



<p><strong>在数据库相关的配置文件中，首先创建一个SQLAlchemy的”engine”，然后创建SessionLocal实例进行会话，最后创建模型类的基类。</strong></p>
<h2 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Integer, String, Boolean, ForeignKey<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> relationship<br><br><span class="hljs-keyword">from</span> .database <span class="hljs-keyword">import</span> Base<br><br><span class="hljs-comment">#使用database.py创建的Base类创建SQLAlchemy模型</span><br><span class="hljs-comment">#可以理解为这个是与真正的数据库相关联的类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">Base</span>):</span><br>    <span class="hljs-comment">#对应的是数据库中的表名</span><br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-comment">#设置表的属性名，使用Column设置，定义了属性的类型</span><br>    id = Column(Integer,primary_key=<span class="hljs-literal">True</span>,index=<span class="hljs-literal">True</span>)<br>    email = Column(String(<span class="hljs-number">32</span>),unique=<span class="hljs-literal">True</span>,index=<span class="hljs-literal">True</span>)<br>    hashed_password = Column(String(<span class="hljs-number">32</span>))<br>    is_active = Column(Boolean,default=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment">#设置关系，通过relationship设置，这个不是属性，在数据库中不需要有这一个字段</span><br>    <span class="hljs-comment">#当访问users.items时，会直接关联到Item表，可以直接获取到Item的字段数据</span><br>    <span class="hljs-comment">#后面的back_populates是反向查询，有这个Item表可以通过items.owner访问到User表的字段数据</span><br>    <span class="hljs-comment">#使用了back_populates,那么被关联的数据库也要显示的使用relationship</span><br>    <span class="hljs-comment">#这个其实我也还不是太懂</span><br>    items = relationship(<span class="hljs-string">&quot;Item&quot;</span>,back_populates=<span class="hljs-string">&quot;owner&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>(<span class="hljs-params">Base</span>):</span><br>    __tablename__ = <span class="hljs-string">&quot;items&quot;</span><br><br>    id=Column(Integer,primary_key=<span class="hljs-literal">True</span>,index=<span class="hljs-literal">True</span>)<br>    title = Column(String(<span class="hljs-number">32</span>),index=<span class="hljs-literal">True</span>)<br>    description = Column(String(<span class="hljs-number">32</span>) , index=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment">#设置了外键，使用ForeignKey参数设置，里面填写关联的表和具体的属性</span><br>    <span class="hljs-comment">#注意这里是表名而不是上面的类名</span><br>    owner_id  = Column(Integer,ForeignKey(<span class="hljs-string">&quot;users.id&quot;</span>))<br><br>    owner = relationship(<span class="hljs-string">&quot;User&quot;</span>,back_populates=<span class="hljs-string">&quot;items&quot;</span>)<br></code></pre></td></tr></table></figure>



<p><strong>通过数据库配置文件中的基类来创建模型类。</strong></p>
<h2 id="schemas-py"><a href="#schemas-py" class="headerlink" title="schemas.py"></a>schemas.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, List<br><br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemBase</span>(<span class="hljs-params">BaseModel</span>):</span><br>    title:str<br>    description:Optional[str]=<span class="hljs-literal">None</span><br><br><br><span class="hljs-comment">#这个是用来创建Item的类，可以理解为前端传过来的要新增的数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemCreate</span>(<span class="hljs-params">ItemBase</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment">#继承自ItemBase</span><br><span class="hljs-comment">#Pydantic风格是声明类型，所以用的是:</span><br><span class="hljs-comment">#SQLAlchemy风格是定义属性，所以用的是=</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>(<span class="hljs-params">ItemBase</span>):</span><br>    id: int<br>    owner_id: int<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>:</span><br>        orm_mode=<span class="hljs-literal">True</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBase</span>(<span class="hljs-params">BaseModel</span>):</span><br>    email:str<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCreate</span>(<span class="hljs-params">UserBase</span>):</span><br>    password:str<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">UserBase</span>):</span><br>    id: int<br>    is_active: bool<br>    items: List[Item]=[]<br><br>    <span class="hljs-comment">#Config类用来给Pydantic提供配置信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>:</span><br>        <span class="hljs-comment">#orm_mode出了可以让Pydantic读取字典类型的数据，还支持Pydantic读取属性数据，比如SQLAlchemy模型的数据</span><br>        <span class="hljs-comment">#这样我们就可以在路径操作函数中直接返回SQLAlchemy数据模型，没有这个配置项是不支持的</span><br>        orm_mode = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>



<p><strong>定义请求参数模型验证与响应模型验证的Pydantic模型，其中响应模型中设置orm_mode=True参数，表示与ORM模型兼容，因为后续中返回的数据库查询是orm模型，通过设置这个参数可以将orm模型通过pydantic模型进行验证。</strong></p>
<h2 id="crud-py"><a href="#crud-py" class="headerlink" title="crud.py"></a>crud.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> models, schemas<br><br><br><span class="hljs-comment">#通过id查询用户</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span>(<span class="hljs-params">db:Session,user_id: int</span>):</span><br>    <span class="hljs-comment">#返回的是models.User(其实就是users表)中的全部属性，并且条件是user_id = users中的id</span><br>    <span class="hljs-keyword">return</span> db.query(models.User).filter(models.User.id==user_id).first()<br><br><span class="hljs-comment">#通过email查询用户</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_email</span>(<span class="hljs-params">db:Session,email:str</span>):</span><br>    <span class="hljs-comment">#条件是邮箱相等</span><br>    <span class="hljs-keyword">return</span>  db.query(models.User).filter(models.User.email == email).first()<br><br><span class="hljs-comment">#查询多个用户</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_users</span>(<span class="hljs-params">db:Session,skip:int = <span class="hljs-number">0</span>,limit:int =<span class="hljs-number">100</span></span>):</span><br>    <span class="hljs-comment">#offset表示偏移量，0表示不偏移,1表示偏移1条数据，即从第二条开始</span><br>    <span class="hljs-comment">#limit表示表示限定数量</span><br>    <span class="hljs-comment">#从第一条开始,查询100条数据，返回的是个列表</span><br>    <span class="hljs-keyword">return</span> db.query(models.User).offset(skip).limit(limit).all()<br><br><span class="hljs-comment">#增加数据</span><br><span class="hljs-comment">#将前端传过来的数据保存到数据库</span><br><span class="hljs-comment">#传过来的数据是Pydantic模型，需要先转换为SQLAlchemy模型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">db:Session,user:schemas.UserCreate</span>):</span><br>    <span class="hljs-comment">#密码哈希化(伪造)</span><br>    fake_hashed_password = user.password+<span class="hljs-string">&quot;pty123&quot;</span><br>    <span class="hljs-comment">#user是Pydantic模型的，重新创建db_user,db_user是SQLALchemy类型的</span><br>    db_user = models.User(email=user.email,hashed_password=fake_hashed_password)<br>    <span class="hljs-comment">#添加到数据库</span><br>    db.add(db_user)<br>    <span class="hljs-comment">#提交</span><br>    db.commit()<br>    <span class="hljs-comment">#刷新</span><br>    db.refresh(db_user)<br>    <span class="hljs-keyword">return</span> db_user<br><br><span class="hljs-comment">#查询多个项目</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_items</span>(<span class="hljs-params">db:Session,skip:int = <span class="hljs-number">0</span>,limit :int=<span class="hljs-number">100</span></span>):</span><br>    <span class="hljs-keyword">return</span> db.query(models.Item).offset(skip).limit(limit).all()<br><br><br><span class="hljs-comment">#增加数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user_item</span>(<span class="hljs-params">db:Session,item:schemas.ItemCreate,user_id:int</span>):</span><br>    db_item = models.Item(**item.dict(),owner_id = user_id)<br>    db.add(db_item)<br>    db.commit()<br>    db.refresh(db_item)<br>    <span class="hljs-keyword">return</span> db_item<br></code></pre></td></tr></table></figure>



<p><strong>通过传入数据库连接以及参数等进行数据库操作，包括创建用户、查询用户等，返回的是orm模型对象。</strong></p>
<h2 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends,HTTPException<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> schemas, crud, models<br><span class="hljs-keyword">from</span> .database <span class="hljs-keyword">import</span> SessionLocal, engine<br><br><span class="hljs-comment">#创建数据库，就算你没有自己创建表，orm会根据models中的类自动创建表</span><br>models.Base.metadata.create_all(bind=engine)<br><br>app=FastAPI()<br><br><span class="hljs-comment">#Dependency</span><br><span class="hljs-comment">#每一个请求完毕后都需要关闭当前的数据库会话，不同请求使用不同的数据库会话</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_db</span>():</span><br>    db=SessionLocal()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db<br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br><br><span class="hljs-meta">@app.post(&quot;/users/&quot;,response_model=schemas.User)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">user:schemas.UserCreate,db:Session=Depends(<span class="hljs-params">get_db</span>)</span>):</span><br>    <span class="hljs-keyword">return</span> crud.create_user(db,user)<br><br><span class="hljs-meta">@app.get(&quot;/user/&#123;user_id&#125;&quot;,response_model=schemas.User)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_user</span>(<span class="hljs-params">user_id: int,db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):</span><br>    db_user =crud.get_user(db,user_id)<br>    <span class="hljs-keyword">if</span> db_user <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span>  HTTPException(status_code=<span class="hljs-number">404</span>,detail=<span class="hljs-string">&quot;User not found&quot;</span>)<br>    <span class="hljs-keyword">return</span> db_user<br><br><span class="hljs-comment">#这里返回多个对象，需要使用List，一开始没用，报错了</span><br><span class="hljs-meta">@app.get(&quot;/users/&quot;,response_model=List[schemas.User])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_usres</span>(<span class="hljs-params">skip: int=<span class="hljs-number">0</span>,limit :int=<span class="hljs-number">100</span>,db:Session = Depends(<span class="hljs-params">get_db</span>)</span>):</span><br>  <span class="hljs-keyword">return</span>  crud.get_users(db,skip,limit)<br></code></pre></td></tr></table></figure>

<p><strong>主文件进行数据库初始化、FastAPI实例创建以及处理各种请求。</strong></p>
<h2 id="SQLAlchemy的查询语句"><a href="#SQLAlchemy的查询语句" class="headerlink" title="SQLAlchemy的查询语句"></a>SQLAlchemy的查询语句</h2><h3 id="查询执行器"><a href="#查询执行器" class="headerlink" title="查询执行器"></a>查询执行器</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">all()</td>
<td align="center">返回一个元素为查询结果的列表</td>
</tr>
<tr>
<td align="center">count()</td>
<td align="center">返回查询结果的数量</td>
</tr>
<tr>
<td align="center">first()</td>
<td align="center">返回第一个结果或None</td>
</tr>
<tr>
<td align="center">first_or_404()</td>
<td align="center">返回第一个结果或404</td>
</tr>
<tr>
<td align="center">get(主键)</td>
<td align="center">返回主键对应的对象或None</td>
</tr>
<tr>
<td align="center">get_or_404(主键)</td>
<td align="center">返回主键对应的对象或404</td>
</tr>
<tr>
<td align="center">paginate(页码，每页条数)</td>
<td align="center">返回一个分页查询结果</td>
</tr>
</tbody></table>
<h3 id="查询过滤器"><a href="#查询过滤器" class="headerlink" title="查询过滤器"></a>查询过滤器</h3><table>
<thead>
<tr>
<th align="center">过滤器</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">filter_by(字段名=值)</td>
<td align="center">等值查询</td>
</tr>
<tr>
<td align="center">filter(函数引用/比较运算)</td>
<td align="center">函数或比较查询</td>
</tr>
<tr>
<td align="center">limit(限定条数)</td>
<td align="center">限定返回结果数量</td>
</tr>
<tr>
<td align="center">offset(偏移条数)</td>
<td align="center">偏移1即从第二条开始查询</td>
</tr>
<tr>
<td align="center">order_by(排序字段)</td>
<td align="center">对查询结果根据字段进行排序</td>
</tr>
<tr>
<td align="center">options()</td>
<td align="center">针对原查询限定查询的字段</td>
</tr>
</tbody></table>
<h2 id="relationship"><a href="#relationship" class="headerlink" title="relationship"></a>relationship</h2><p>在构建SQLAlchemy模型的时候，relationship我觉得有点难，可以看一下这篇博客，感觉讲的比较详细。</p>
<p><a href="https://www.cnblogs.com/goldsunshine/p/9269880.html">sqlalchemy外键和relationship查询</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Util</title>
    <url>/2021/07/22/redis-utils/</url>
    <content><![CDATA[<h2 id="redis-util工具类"><a href="#redis-util工具类" class="headerlink" title="redis util工具类"></a>redis util工具类</h2><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.utils;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtil</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-comment">//自己定义的redistemplate</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-comment">// =============================common============================</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定缓存失效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                redisTemplate.expire(key, time, TimeUnit.SECONDS);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key 获取过期时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断key是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasKey</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.hasKey(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 可以传一个值 或多个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String... key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span> &amp;&amp; key.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (key.length == <span class="hljs-number">1</span>) &#123;<br>                redisTemplate.delete(key[<span class="hljs-number">0</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                redisTemplate.delete(CollectionUtils.arrayToList(key));<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// ============================String=============================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : redisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存放入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForValue().set(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存放入并设置时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false 失败</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递增</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要增加几(大于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递增因子必须大于0&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, delta);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递减</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要减少几(小于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">decr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递减因子必须大于0&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);<br>    &#125;<br><br><br>    <span class="hljs-comment">// ================================Map=================================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashGet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hget</span><span class="hljs-params">(String key, String item)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().get(key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取hashKey对应的所有键值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对应的多个键值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Object, Object&gt; <span class="hljs-title">hmget</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().entries(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashSet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 对应多个键值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().putAll(key, map);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashSet 并设置时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map  对应多个键值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().putAll(key, map);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                expire(key, time);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().put(key, item, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().put(key, item, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                expire(key, time);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除hash表中的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 可以使多个 不能为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hdel</span><span class="hljs-params">(String key, Object... item)</span> </span>&#123;<br>        redisTemplate.opsForHash().delete(key, item);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断hash表中是否有该项的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hHasKey</span><span class="hljs-params">(String key, String item)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要增加几(大于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hincr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash递减</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要减少记(小于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hdecr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);<br>    &#125;<br><br><br>    <span class="hljs-comment">// ============================set=============================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key获取Set中的所有值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">sGet</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().members(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据value从一个set中查询,是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sHasKey</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(key, value);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将数据放入set缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSet</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().add(key, values);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将set数据放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time   时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSetAndTime</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long count = redisTemplate.opsForSet().add(key, values);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取set缓存的长度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sGetSetSize</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除值为value的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">setRemove</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long count = redisTemplate.opsForSet().remove(key, values);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ===============================list=================================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取list缓存的内容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 开始</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   结束 0 到 -1代表所有值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">lGet</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().range(key, start, end);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取list缓存的长度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lGetListSize</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().size(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过索引 获取list中的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">lGetIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().index(key, index);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPush(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPush(key, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPushAll(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPushAll(key, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引修改list中的某条数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lUpdateIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().set(key, index, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除N个值为value</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 移除多少个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lRemove</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> count, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long remove = redisTemplate.opsForList().remove(key, count, value);<br>            <span class="hljs-keyword">return</span> remove;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>工具类</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis配置</title>
    <url>/2022/05/29/redis%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"># 修改触发生成RDB文件的条件,表示900s内有一个key被就修改，就执行bgsave，如果是save &quot;&quot; 表示禁用RDB<br>save 900 1<br>save 300 10<br>save 60 10000<br><br>#RDB文件名称<br>dbfilename dump.rdb<br><br>#rdb文件保存的目录,默认当前目录<br>dir ./<br><br>#是否压缩，建议不开启，压缩会消耗cpu<br>rdbcompression yes<br></code></pre></td></tr></table></figure>



<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">#是否开启AOF功能，默认是no<br>appendonly yes<br><br>#AOF文件的名称<br>appendfilename &quot;appendonly.aof&quot;<br><br>#表示每执行一次写命令，立即记录到AOF文件<br>appendfsync always<br><br># 写命令执行完先放入aof缓冲区，每隔一秒将缓冲区文件写入到aof文件，默认方案<br>appendfsync everysec<br><br>#写命令执行完先放入aof缓冲区，由系统决定何时将缓冲区内容写回磁盘<br>appendfsync no<br><br>#AOF文件比上次文件增长超过多少百分比则触发重写<br>auto-aof-rewrite-percentage 100<br><br>#aof文件体积最小多大以上才触发重写<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure>



<h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><blockquote>
<p>本次实验准备3个实例，1主2从,主从需要开启rdb</p>
</blockquote>
<p>先创建3个文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入/tmp目录</span><br>cd /tmp<br><span class="hljs-meta">#</span><span class="bash"> 创建目录</span><br>mkdir 7001 7002 7003<br></code></pre></td></tr></table></figure>



<p>将redis.conf文件复制到这三个目录,前提是先将redis-6.2.4也放到当前目录，否则需要修改下redis的路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 方式一：逐个拷贝</span><br>cp redis-6.2.4/redis.conf 7001<br>cp redis-6.2.4/redis.conf 7002<br>cp redis-6.2.4/redis.conf 7003<br><br><span class="hljs-meta">#</span><span class="bash"> 方式二：管道组合命令，一键拷贝</span><br>echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf<br></code></pre></td></tr></table></figure>



<p>修改3个实例的端口号和RDB文件保存的地址,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sed -i -e &#x27;s/6379/7001/g&#x27; -e &#x27;s/dir .\//dir \/tmp\/7001\//g&#x27; 7001/redis.conf<br>sed -i -e &#x27;s/6379/7002/g&#x27; -e &#x27;s/dir .\//dir \/tmp\/7002\//g&#x27; 7002/redis.conf<br>sed -i -e &#x27;s/6379/7003/g&#x27; -e &#x27;s/dir .\//dir \/tmp\/7003\//g&#x27; 7003/redis.conf<br></code></pre></td></tr></table></figure>



<p>修改每个实例的ip信息，如果不是虚拟机，可以不做这个操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 逐一执行</span><br>sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7001/redis.conf<br>sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7002/redis.conf<br>sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7003/redis.conf<br><span class="hljs-meta">#</span><span class="bash"> 或者一键修改</span><br>printf &#x27;%s\n&#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第1个</span><br>redis-server 7001/redis.conf<br><span class="hljs-meta">#</span><span class="bash"> 第2个</span><br>redis-server 7002/redis.conf<br><span class="hljs-meta">#</span><span class="bash"> 第3个</span><br>redis-server 7003/redis.conf<br></code></pre></td></tr></table></figure>



<h2 id="开启主从"><a href="#开启主从" class="headerlink" title="开启主从"></a>开启主从</h2><p>在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p>
<p>有临时和永久两种模式：</p>
<ul>
<li><p>修改配置文件（永久生效）</p>
<ul>
<li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
</ul>
</li>
<li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">slaveof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p>
<p>通过redis-cli命令连接7002，执行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 连接 7002</span><br>redis-cli -p 7002<br><span class="hljs-meta">#</span><span class="bash"> 执行slaveof</span><br>slaveof 192.168.150.101 7001<br></code></pre></td></tr></table></figure>

<p>其他结点操作一样。</p>
<p><strong>在主节点中使用info replication 可以查看从节点的状态</strong></p>
<h1 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h1><blockquote>
<p>哨兵可以实现监控、故障转移、通知等功能</p>
<p>配置3个哨兵结点</p>
</blockquote>
<h2 id="创建实例-1"><a href="#创建实例-1" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入/tmp目录</span><br>cd /tmp<br><span class="hljs-meta">#</span><span class="bash"> 创建目录</span><br>mkdir s1 s2 s3<br></code></pre></td></tr></table></figure>



<p>在s1 s2 s3目录里面创建sentinel.conf文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs ini">port 27001<br>sentinel announce-ip 192.168.217.4<br>sentinel monitor mymaster 192.168.217.4 2<br>sentinel down-after-milliseconds mymaster 5000<br>sentinel failover-timeout mymaster 60000<br>dir &quot;/tmp/s1&quot;<br></code></pre></td></tr></table></figure>

<p>解读：</p>
<ul>
<li><p><code>port 27001</code>：是当前sentinel实例的端口</p>
</li>
<li><pre><code>sentinel monitor mymaster 192.168.150.101 7001 2
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><br>  ：指定主节点信息<br><br>  - `mymaster`：主节点名称，自定义，任意写<br>  - `<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">150</span>.<span class="hljs-number">101</span> <span class="hljs-number">7001</span>`：主节点的<span class="hljs-built_in">ip</span>和端口<br>  - `<span class="hljs-number">2</span>`：选举master时的quorum值<br><br>然后将<span class="hljs-built_in">s1</span>/sentinel.conf文件拷贝到<span class="hljs-built_in">s2</span>、<span class="hljs-built_in">s3</span>两个目录中（在/tmp目录执行下列命令）：<br><br>```sh<br><span class="hljs-comment"># 方式一：逐个拷贝</span><br><span class="hljs-symbol">cp</span> <span class="hljs-built_in">s1</span>/sentinel.conf <span class="hljs-built_in">s2</span><br><span class="hljs-symbol">cp</span> <span class="hljs-built_in">s1</span>/sentinel.conf <span class="hljs-built_in">s3</span><br><span class="hljs-comment"># 方式二：管道组合命令，一键拷贝</span><br><span class="hljs-symbol">echo</span> <span class="hljs-built_in">s2</span> <span class="hljs-built_in">s3</span> <span class="hljs-title">| xargs -t -n 1 cp s1/sentinel.conf</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf<br>sed -i -e <span class="hljs-string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf<br></code></pre></td></tr></table></figure>



<h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第1个</span><br>redis-sentinel s1/sentinel.conf<br><span class="hljs-meta">#</span><span class="bash"> 第2个</span><br>redis-sentinel s2/sentinel.conf<br><span class="hljs-meta">#</span><span class="bash"> 第3个</span><br>redis-sentinel s3/sentinel.conf<br></code></pre></td></tr></table></figure>



<h2 id="springboot整合哨兵集群"><a href="#springboot整合哨兵集群" class="headerlink" title="springboot整合哨兵集群"></a>springboot整合哨兵集群</h2><p>引入redis的starter依赖</p>
<p>配置yml文件，<strong>只需要配置哨兵集群的信息，不需要配置redis实例的信息，因为客户端是通过找哨兵结点，然后获取实例的地址，这样当发生故障转移的时候，客户端仍然知道需要去哪里获取数据</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span>   <span class="hljs-comment"># 指定master名称</span><br>      <span class="hljs-attr">nodes:</span>   <span class="hljs-comment">#指定redis-sentinel集群信息</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:27001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:27002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:27003</span><br></code></pre></td></tr></table></figure>



<p>配置读写分离</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220518161857091.png" alt="image-20220518161857091"></p>
<h1 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h1><blockquote>
<p>主从和哨兵可以解决高可用、高并发读的问题，但是仍然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
</blockquote>
<p>分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可以有多个slave结点</li>
<li>master之前通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确结点</li>
</ul>
<h2 id="创建实例-2"><a href="#创建实例-2" class="headerlink" title="创建实例"></a>创建实例</h2><blockquote>
<p>此处创建6个实例，7001 7002 7003为master，8001 8002 8003为slave</p>
</blockquote>
<p>创建目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建目录</span><br>mkdir 7001 7002 7003 8001 8002 8003<br></code></pre></td></tr></table></figure>



<p>自己创建一个新的redis.conf文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs ini">port 6379<br><span class="hljs-comment"># 开启集群功能</span><br>cluster-enabled yes<br><span class="hljs-comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span><br>cluster-config-file /tmp/6379/nodes.conf<br><span class="hljs-comment"># 节点心跳失败的超时时间</span><br>cluster-node-timeout 5000<br><span class="hljs-comment"># 持久化文件存放目录</span><br>dir /tmp/6379<br><span class="hljs-comment"># 绑定地址</span><br>bind 0.0.0.0<br><span class="hljs-comment"># 让redis后台运行</span><br>daemonize yes<br><span class="hljs-comment"># 注册的实例ip</span><br>replica-announce-ip 192.168.217.4<br><span class="hljs-comment"># 保护模式</span><br>protected-mode no<br><span class="hljs-comment"># 数据库数量</span><br>databases 1<br><span class="hljs-comment"># 日志</span><br>logfile /tmp/6379/run.log<br></code></pre></td></tr></table></figure>



<p>将文件拷贝到每个目录下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 执行拷贝</span><br><span class="hljs-built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf<br></code></pre></td></tr></table></figure>



<p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改配置文件</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="hljs-string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure>



<h2 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h2><p>因为配置了后台启动，所以可以直接启动服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 一键启动所有服务</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure>



<p>如果要关闭所有进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<br></code></pre></td></tr></table></figure>

<h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><blockquote>
<p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联,我们需要执行命令来创建集群.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">redis-cli --cluster create --cluster-replicas 1 192.168.217.4:7001 192.168.217.4:7002 192.168.217.4:7003 192.168.217.4:8001 192.168.217.4:8002 192.168.217.4:8003<br></code></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</li>
<li><code>create</code>：代表是创建集群</li>
<li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220518165636805.png" alt="image-20220518165636805"></p>
<p>通过命令可以查看集群状态：<code>redis-cli -p 7001 cluster nodes</code>,端口可以是集群中的任意一个结点</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220518165535210.png" alt="image-20220518165535210"></p>
<h2 id="给集群添加一个结点"><a href="#给集群添加一个结点" class="headerlink" title="给集群添加一个结点"></a>给集群添加一个结点</h2><p>重新创建一个实例，然后将集群的配置文件放到目录下，修改好路径，启动实例。</p>
<p>使用<code>redis-cli --cluster add-node 要添加结点的ip端口号  集群中任意一个结点ip端口号</code>将结点添加到集群中。</p>
<h2 id="分配插槽"><a href="#分配插槽" class="headerlink" title="分配插槽"></a>分配插槽</h2><p>使用<code>redis-cli --cluster reshard 集群任意一个ip端口</code>分配插槽，根据提示信息即可完成</p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>master宕机后，会自动完成故障转移。</p>
<p>在一个slave结点中，使用<code>cluster failover</code>命令可以实现手动故障转移，他的master会变成slave，他自己变成master</p>
<h2 id="springboot整合分片集群"><a href="#springboot整合分片集群" class="headerlink" title="springboot整合分片集群"></a>springboot整合分片集群</h2><blockquote>
<p>1.引入redis的starter依赖</p>
<p>2.配置yml文件</p>
<p>3.配置读写分离</p>
</blockquote>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>配置yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">cluster:</span><br>      <span class="hljs-attr">nodes:</span>   <br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:7001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:7002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:7003</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:8001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:8002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:8003</span><br></code></pre></td></tr></table></figure>



<p>配置读写分离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="hljs-title">clientConfigurationBuilderCustomizer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Springboot 整合 mybatis generator 逆向生成工程</title>
    <url>/2021/07/22/springboot%E6%95%B4%E5%90%88mybatis%20generator%20/</url>
    <content><![CDATA[<h3 id="Springboot-整合-mybatis-generator-逆向生成工程"><a href="#Springboot-整合-mybatis-generator-逆向生成工程" class="headerlink" title="Springboot 整合 mybatis generator 逆向生成工程"></a>Springboot 整合 mybatis generator 逆向生成工程</h3><h4 id="1-先新创建一个springboot项目，引入相关的骨架"><a href="#1-先新创建一个springboot项目，引入相关的骨架" class="headerlink" title="1.先新创建一个springboot项目，引入相关的骨架"></a>1.先新创建一个springboot项目，引入相关的骨架</h4><h4 id="2-在pom-xml文件中引入相关依赖"><a href="#2-在pom-xml文件中引入相关依赖" class="headerlink" title="2.在pom.xml文件中引入相关依赖"></a>2.在pom.xml文件中引入相关依赖</h4><ol>
<li><p>引入sqlserver的依赖</p>
<a id="more"></a>

</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mssql-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4.1.jre8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>或者引入mysql的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>引入mybatis-generator依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>添加插件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                   <span class="hljs-comment">&lt;!--configurationFile对应着generator配置文件的路径--&gt;</span><br>             <span class="hljs-comment">&lt;!--需要在src/main/resources创建generator/generatorConfig.xml文件--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>               <span class="hljs-comment">&lt;!--数据库驱动好像是要在这里引入，在上面引入可能会出现问题，没有试过--&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mssql-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4.1.jre8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>                   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>配置generatorConfig.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Tables&quot;</span>  <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 是否去除自动生成的注释 true：是,false:否 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库连接驱动类,URL,用户名,密码 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:sqlserver://172.22.224.60:1433;DatabaseName=GXKH2021&quot;</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;jxkh&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;Jxkh-22183305&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成(实体)模型的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.hut.jsj.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;./src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成XML映射文件的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;./src/main/resources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成DAO接口的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.hut.jsj.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;./src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 关联自动生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span><br>        <span class="hljs-comment">&lt;!--如果是要生成数据库中的所有的表，那么tablename处填%--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;UserData&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;UserData&quot;</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableUpdateByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableDeleteByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableSelectByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">selectByExampleQueryId</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ol>
<p>上面的是sqlserver的，mysql和这个相差无几</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span>  <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库链接URL，用户名、密码 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sell?serverTimezone=Asia/Shanghai&quot;</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成实体类的包名和位置 ，targetPackage指的是包名,targetProject值得是路径位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.model&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成映射文件的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成DAO的包名和位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.dao&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;seller_info&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;SellerInfo&quot;</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableUpdateByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableDeleteByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableSelectByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">selectByExampleQueryId</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li>再运行mvn mybatis-generator:generate即可自动生成代码</li>
</ol>
<p><img src="/.com//笔记\img\image-20210322204729417.png" alt="image-20210322204729417"></p>
<h4 id="pom-xml文件总览"><a href="#pom-xml文件总览" class="headerlink" title="pom.xml文件总览"></a>pom.xml文件总览</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.hut<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>jsj<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--configurationFile对应着generator配置文件的路径--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mssql-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4.1.jre8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合日志框架</title>
    <url>/2020/09/15/springboot%E6%95%B4%E5%90%88%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>在项目的开发中，日志是必不可少的一个记录事件的组件，所以也会相应的在项目中实现和构建我们所需要的日志框架。</p>
<p>而市面上常见的日志框架有很多，比如：JCL、SLF4J、Jboss-logging、jUL、log4j、log4j2、logback等等，我们该如何选择呢？</p>
<p>通常情况下，日志是由一个抽象层+实现层的组合来搭建的。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>日志-抽象层</th>
<th>日志-实现层</th>
</tr>
</thead>
<tbody><tr>
<td>JCL、SLF4J、jboss-logging</td>
<td>jul、log4j、log4j2、logback</td>
</tr>
</tbody></table>
<p><strong>springboot选择了SLF4J和logback</strong></p>
<h2 id="1-如何使用SLF4J"><a href="#1-如何使用SLF4J" class="headerlink" title="1.如何使用SLF4J"></a>1.如何使用SLF4J</h2><p>在以后的开发中，日志记录方法的调用，不应该来直接调用日志的实现层，而是调用日志抽象层的方法。</p>
<p>SLF4J就是日志抽象层，而logback就是日志的实现层。</p>
<p>给项目中导入slf4j和logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger log = LoggerFactory.getLogger(HelloWorld.class);<br>        log.info(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要先生成一个log的对象</p>
<p>但在实际开发中，我们一般使用**@Slf4j**注解。</p>
<p>导入**@Slf4j**的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后还要设置的Plugins里面安装Lombok插件。</p>
<p>在类的前面写上**@Slf4j**，就不用通过<code>LoggerFactory</code>创建Logger对象了，可以直接使用log。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-配置logback"><a href="#2-配置logback" class="headerlink" title="2.配置logback"></a>2.配置logback</h2><p>使用logback需要导入<strong>spring-boot-starter-logging</strong>依赖</p>
<p>但在实际开发中，我们不需要导入这个依赖，因为<strong>spring-boot-starter</strong>依赖中已经包含了<strong>spring-boot-starter-logging</strong>。因此可以不用引依赖，直接用就行了。</p>
<p>官方推荐使用的xml名字格式是：<code>logback-spring.xml</code>。</p>
<p>为什么是<code>logback-spring.xml</code> 而不是<code>logback.xml</code>呢？因为带spring后缀的可以使用<code>&lt;springProfile&gt;</code>标签</p>
<hr>
<p>在resource目录下新建一个：<code>logback-spring.xml</code>文件</p>
<p>配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--输出文件位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span>&gt;</span>../crm-admin-log/server-debug.log<span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--编码--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd.HH:mm:ss&#125; [%5p] %c&#123;50&#125; %3L %M %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--日志级别--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--滚动输出策略，归档文件名字--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>../crm-admin-log/server-debug.log.%d&#123;yyyy-MM-dd&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span>&gt;</span>../crm-admin-log/server-info.log<span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd.HH:mm:ss&#125; [%5p] %c&#123;50&#125; %3L %M %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>../crm-admin-log/server-info.log.%d&#123;yyyy-MM-dd&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span>&gt;</span>../crm-admin-log/server-warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd.HH:mm:ss&#125; [%5p] %c&#123;50&#125; %3L %M %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>../crm-admin-log/server-warn.log.%d&#123;yyyy-MM-dd&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;consoleApp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--输出样式--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span><br>                %date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level[%thread]%logger&#123;56&#125;.%method:%L -%msg%n<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置某个包或者类使用哪个appende name属性值定义到mapper所在的目录--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.example.druid&quot;</span>  <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;info&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;warn&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;consoleApp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--全局日志级别--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在<strong>application.yml</strong>中配置logging config信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">config:</span> <span class="hljs-string">classpath:logback-spring.xml</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>日志框架</tag>
      </tags>
  </entry>
  <entry>
    <title>typore图床</title>
    <url>/2021/07/22/typora%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p>我都是使用typora来记笔记，在写笔记的时候，难免会需要贴一些图片，而这些图片都是保存到本地的，如果你需要把这个文章分享给别人的话，就必须将图片也传给他，并且他还需要将图片保存到和你一样的位置，非常麻烦。在将文章部署到github上的博客时，图片的问题也是很麻烦。</p>
<a id="more"></a>

<p>因此这篇博客就是将图片上传到网上，这样图片就变成了网上的地址，分享给别人也同样能访问。</p>
<h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><blockquote>
<p>Typora的版本要求：0.9.86以上</p>
</blockquote>
<p>点击”帮助=》关于”可以查看现在使用的版本。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626004000242.png" alt="image-20210626004000242"></p>
<blockquote>
<p>这个版本是写这篇博客时的最新版，如果不想麻烦，直接打开软件后提示更新时就顺手更新了吧</p>
</blockquote>
<h3 id="安装Picgo"><a href="#安装Picgo" class="headerlink" title="安装Picgo"></a>安装Picgo</h3><p>地址  <code>https://github.com/Molunerfinn/PicGo/releases</code></p>
<p>windows安装.exe文件，mac下载dmg。</p>
<h3 id="修改Typora图片功能设置"><a href="#修改Typora图片功能设置" class="headerlink" title="修改Typora图片功能设置"></a>修改Typora图片功能设置</h3><p>点击“文件=》偏好设置=》图像”</p>
<p>修改成如图所示的样子，然后点击<strong>下载更新</strong></p>
<p><img src="https://i.loli.net/2021/06/24/zPHtVyN5jYoIm2l.png" alt="image-20210624192713102"></p>
<h3 id="使用SMMS作为图床"><a href="#使用SMMS作为图床" class="headerlink" title="使用SMMS作为图床"></a>使用SMMS作为图床</h3><p>因为需要将图片上传到网上，所以我们需要使用一个可以存储图片的服务器，这里我们使用smms作为图床。</p>
<p>打开网址，注册账号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">https://sm.ms/home/apitoken<br></code></pre></td></tr></table></figure>

<p>注册登录完以后，会自动跳转到一个页面。<img src="https://i.loli.net/2021/06/24/2JglLwH3eQm5hCj.png" alt="image-20210624193204516"></p>
<p>不用管这个页面，再次请求之前的网址：<code>https://sm.ms/home/apitoken</code></p>
<p><img src="https://i.loli.net/2021/06/24/3m2lcfU9MRdeWrB.png" alt="image-20210624193624367"></p>
<p>复制这里的token，后面会用到。</p>
<h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>进入偏好设置=》图像，点击打开配置文件。</p>
<p><img src="https://i.loli.net/2021/06/24/afcipPZCYyzwQ9O.png" alt="image-20210624193813749"></p>
<p>修改配置文件，复制下面的代码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;picBed&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;uploader&quot;</span>: <span class="hljs-string">&quot;smms&quot;</span>, <span class="hljs-comment">// 代表当前的默认上传图床为 SM.MS,</span><br>    <span class="hljs-attr">&quot;smms&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span>: <span class="hljs-string">&quot;这里面的token换成你上个页面的申请的token&quot;</span> <span class="hljs-comment">//一定要换</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;picgoPlugins&quot;</span>: &#123;&#125; <span class="hljs-comment">// 为插件预留</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>记得换token</strong>，保存配置文件，就可以了。</p>
<h3 id="使用阿里云作为图床"><a href="#使用阿里云作为图床" class="headerlink" title="使用阿里云作为图床"></a>使用阿里云作为图床</h3><p>之前使用SMMS作为图床，但是太不稳定了，今天一直上传不上去，搞得我很心烦，就决定用阿里云作为图床了，虽然要钱，但是还好不是很贵。</p>
<p>1.首先登陆阿里云，然后点击控制台。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626000813980.png" alt="image-20210626000813980"></p>
<p>2.然后选择对象存储OSS，并开通服务。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626000813980.png" alt="image-20210626000813980"></p>
<p>3.点击概况，创建Bucket</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626001410912.png" alt="image-20210626001410912"></p>
<p>4.填写相关信息，<strong>注意读写权限一定要选公共读</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626001700913.png" alt="image-20210626001700913"></p>
<p>5.创建完成之后，可以购买一个资源包。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626001915803.png" alt="image-20210626001915803"></p>
<p>6.购买40G，一年差不多了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626002022599.png" alt="image-20210626002022599"></p>
<p>7.获取个人ACCESSkey</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626002417044.png" alt="image-20210626002417044"></p>
<p>8.创建AccessKey</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210626002446884.png" alt="image-20210626002446884"></p>
<p>9.打开typora的偏好设置，打开配置文件，修改文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;picBed&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;uploader&quot;</span>: <span class="hljs-string">&quot;aliyun&quot;</span>,<br>    <span class="hljs-attr">&quot;aliyun&quot;</span>: &#123;<br>  	<span class="hljs-attr">&quot;accessKeyId&quot;</span>: <span class="hljs-string">&quot;LTAI5tMPmnRuSjU3wmEC13TH&quot;</span>,   <span class="hljs-comment">//上述创建的AccessKey的id</span><br> 	<span class="hljs-attr">&quot;accessKeySecret&quot;</span>: <span class="hljs-string">&quot;60w1Stbt3qSUw6ABilXLeCvSWuFw10&quot;</span>,  <span class="hljs-comment">//上述创建的密码</span><br>  	<span class="hljs-attr">&quot;bucket&quot;</span>: <span class="hljs-string">&quot;pety&quot;</span>, <span class="hljs-comment">// 存储空间名，即你创建的BUcket的名字</span><br>  	<span class="hljs-attr">&quot;area&quot;</span>: <span class="hljs-string">&quot;oss-cn-shenzhen&quot;</span>, <span class="hljs-comment">// 存储区域代号</span><br>  	<span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;img/&quot;</span>, <span class="hljs-comment">// 自定义存储路径</span><br> 	 <span class="hljs-attr">&quot;customUrl&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 自定义域名，注意要加 http://或者 https://</span><br> 	 <span class="hljs-attr">&quot;options&quot;</span>: <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span><br>	&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大功完成！！！！！！！！！</p>
]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>windows端口命令</title>
    <url>/2022/05/29/window%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在控制台输入<code>netstat</code> 可以查看所有端口占用情况</p>
<a id="more"></a>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503110733768.png" alt="image-20220503110733768"></p>
<p>输入<code>netstat -ano</code>可以查看所有端口占用详细信息，包括父进程的pid</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503110720513.png" alt="image-20220503110720513"></p>
<p>输入<code>netstat -ano|findstr &quot;端口号&quot;</code>可以查看到具体的端口占用情况，有点类似于linux的 <code>grep</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503110919357.png" alt="image-20220503110919357"></p>
<p>使用<code>tasklist</code>可以查看所有进程的情况</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503111010735.png" alt="image-20220503111010735"></p>
<p>使用<code>tasklist|findstr &quot;进程号&quot;</code>可以查看具体进程的情况</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503111115078.png" alt="image-20220503111115078"></p>
<p>使用<code>taskkill /pid 进程号</code>可以杀死一个进程</p>
<p>使用<code>taskkill /F /pid 进程号</code>可以强制杀死一个进程</p>
]]></content>
  </entry>
  <entry>
    <title>使用优先队列实现对hashmap的排序</title>
    <url>/2022/05/29/%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AF%B9hashmap%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="根据hashmap的value值进行排序"><a href="#根据hashmap的value值进行排序" class="headerlink" title="根据hashmap的value值进行排序"></a>根据hashmap的value值进行排序</h1><blockquote>
<p>在一些场景下，我们使用hashmap进行统计，然后根据hashmap中value的值进行排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//模拟数据</span><br>        map.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>);<br>        map.put(<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-number">6</span>);<br>        map.put(<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-number">5</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br>		<br>        <span class="hljs-comment">//创建优先队列并设置排序规则， </span><br>        PriorityQueue&lt;Map.Entry&lt;String,Integer&gt;&gt;  queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((e1,e2) -&gt;  e2.getValue() - e1.getValue());<br>        <br>        <span class="hljs-comment">//将map的Entry加入到优先队列中</span><br>        queue.addAll(map.entrySet());<br>		<span class="hljs-comment">//获取到优先队列的长度，由于下面使用poll来拿到栈顶元素，使用poll方法后长度会减1，因此循环次数需要固定</span><br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <br>        <span class="hljs-comment">//优先队列使用堆来维护的，因此不能够直接遍历优先队列，你会发现直接遍历取出来的值不一定是按顺序</span><br>        <span class="hljs-comment">//这里需要使用取出栈顶元素，取出一个元素后，优先队列会自动维护堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            System.out.println(queue.poll());<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="根据hashmap的key值进行排序"><a href="#根据hashmap的key值进行排序" class="headerlink" title="根据hashmap的key值进行排序"></a>根据hashmap的key值进行排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        map.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>);<br>        map.put(<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-number">6</span>);<br>        map.put(<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-number">5</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//和上面不同的是这里排序规则是比较key的</span><br>        PriorityQueue&lt;Map.Entry&lt;String,Integer&gt;&gt;  queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((e1,e2) -&gt;  e1.getKey().compareTo(e2.getKey()));<br>        queue.addAll(map.entrySet());<br><br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            System.out.println(queue.poll());<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>关闭应用询问</title>
    <url>/2021/07/22/%E5%85%B3%E9%97%AD%E5%BA%94%E7%94%A8%E8%AF%A2%E9%97%AE/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>电脑重装系统之后，每次安装一个应用都会弹出一个提示框，要我们确认是否安装，这个提示框非常烦人，因此我们想要把他给去掉。</p>
<a id="more"></a>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>1.搜索控制面板，进入控制面板</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210703143202924.png" alt="image-20210703143202924"></p>
<p>2.点击用户账户</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210703143314496.png" alt="image-20210703143314496"></p>
<p>3.点击更改用户账户控制设置</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210703143417130.png" alt="image-20210703143417130"></p>
<p>4.设置为从不通知</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210703143523120.png" alt="image-20210703143523120"></p>
<h3 id="连接鼠标关闭触摸板"><a href="#连接鼠标关闭触摸板" class="headerlink" title="连接鼠标关闭触摸板"></a>连接鼠标关闭触摸板</h3><p>1.搜索设置，点击设备</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210703144047546.png" alt="image-20210703144047546"></p>
<p>2.点击触摸板，将连接鼠标时让触摸板保持打开状态关闭即可</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210703144124044.png" alt="image-20210703144124044"></p>
]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>基于自定义注解实现拦截器</title>
    <url>/2022/09/01/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Target</span> 标识该注解可以使用的位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Retention</span> 标识该注解的作用域</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoginRequired &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>元注解：</strong></p>
<ul>
<li><strong>@Target</strong>：**<em>用来限定某个自定义注解能够被应用在哪些Java元素上面。它的可选值是枚举类来定义的**</em>，通常使用在method或type(类)上</li>
<li><strong>@Retention</strong>：<strong>用来修饰自定义注解的作用域。可选值是在RetentionPolicy 枚举类中定义的</strong></li>
</ul>
<h1 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a>编写拦截器</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequiredInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-comment">//里面保存了用户的信息，根据自己的业务修改</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HostHolder hostHolder;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>			<span class="hljs-comment">//将handler转为 HandlerMethod 对象</span><br>            HandlerMethod handler1 = (HandlerMethod) handler;<br>            <span class="hljs-comment">//获取 HandlerMethod 的 Method属性</span><br>            Method method = handler1.getMethod();<br>            <span class="hljs-comment">//获取方法上对应的注解。</span><br>        	<span class="hljs-comment">//有注解说明该方法需要登录之后才能使用(业务逻辑，根据自己的修改)</span><br>            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);<br>        	<span class="hljs-comment">//判断注解是否存在，根据业务逻辑执行相应操作</span><br>            <span class="hljs-comment">//如果有注解并且没有user信息，说明没有登录</span><br>            <span class="hljs-keyword">if</span>(loginRequired != <span class="hljs-keyword">null</span> &amp;&amp; hostHolder.getUser() == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">//重定向</span><br>                response.sendRedirect(request.getContextPath()+<span class="hljs-string">&quot;/login&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面实现的效果是，如果方法上使用了<code>LoginRequired</code>注解，那么必须要登录之后才能访问该方法。</p>
<h1 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>   <br>        registry.addInterceptor(loginRequiredInterceptor)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>, <span class="hljs-string">&quot;/**/*.js&quot;</span>, <span class="hljs-string">&quot;/**/*.png&quot;</span>, <span class="hljs-string">&quot;/**/*.jpg&quot;</span>, <span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>实现 <code>WebMvcConfigurer</code>接口，重写<code>addInterceptors</code>方法。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>springboot发送邮箱验证</title>
    <url>/2020/09/15/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>在实际开发中，我们通常需要登录和注册用户。在登录的时候我们可以使用验证码来进行验证，但在注册的时候我们看到更多的是使用邮箱验证，即给你发送的邮箱发送一个验证码，然后你将这个验证码输在页面。</p>
<a id="more"></a>

<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li><p>我们使用qq邮箱进行邮件发送，需要开启QQ邮箱的POP3/SMTP服务和IMAP/SMTP服务</p>
<ul>
<li>进入QQ邮箱首页，找到设置<img src="/images/blog/qqemail.png" alt="qq邮箱"></li>
<li>进入设置后点击账户，往下拉找到<strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</strong></li>
</ul>
<p><img src="/images/blog/pop3.png" alt="pop3"></p>
<ul>
<li>开启POP3和IMAP服务（只开启一个好像也行）</li>
<li>开始这两项服务后各自会生成一串密文密码，把这个保存起来，以后会用到。</li>
<li>我的两个密码分别是  POP3:cplcsiqntwidfgib    IMAP:zxisvqcbpucmiifb</li>
</ul>
</li>
<li><p>springboot配置邮箱服务</p>
<ul>
<li>导入支持邮箱的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>一个小插曲：</p>
<blockquote>
<p>在后面写代码的时候需要用到<code>JavaMailSenderImpl</code>这个类。</p>
</blockquote>
<blockquote>
<p>但是我导入这个包以后找不到这个类，我以为是还需要添加其他的依赖，百度了一下，导入了<code>spring-context-support</code>这个依赖。然后我点进<code>spring-boot-starter-mail</code>后发现里面已经引入了<code>spring-context-support</code>，所以应该是我最开始没有导入好。</p>
</blockquote>
<ul>
<li>在application.yml中配置邮箱信息</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span> <br>	<span class="hljs-attr">mail:</span><br>		<span class="hljs-attr">username:</span> <span class="hljs-number">1219002685</span><span class="hljs-string">@qq.com</span>  <span class="hljs-comment">#发件人账号</span><br>		<span class="hljs-attr">password:</span> <span class="hljs-string">zxisvqcbpucmiifb</span>  <span class="hljs-comment">#这里的password不是填你的qq密码，而是你开去那两个服务后生成的密码</span><br>		<span class="hljs-attr">host:</span> <span class="hljs-string">smtp.qq.com</span>        	<span class="hljs-comment">#邮箱服务器</span><br>		<span class="hljs-attr">default-encoding:</span> <span class="hljs-string">utf-8</span>		<span class="hljs-comment">#默认编码</span><br></code></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，发送邮箱验证的前期准备工作都已经做完了，接下来就是写代码了！！！！</p>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ol>
<li>Controller层</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    EmailService emailService;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/email&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">sendEmail</span><span class="hljs-params">(String emailAdress)</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            emailService.sendEmail(emailAdress);  <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送邮件成功&quot;</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;邮件发送失败&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>Service层</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JavaMailSenderImpl javaMailSender;<br><br>    <span class="hljs-keyword">private</span> String code; <span class="hljs-comment">//验证码</span><br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String sender;   <span class="hljs-comment">//发送邮件的地址</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">(String emailAddress)</span></span>&#123;<br>        code= VerifyCode.getVerifyCode();   <br>        SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();<br>        message.setSubject(<span class="hljs-string">&quot;验证码&quot;</span>);   <br>        message.setText(<span class="hljs-string">&quot;尊敬的用户你好：\n&quot;</span>+<br>                <span class="hljs-string">&quot;\n本次请求的邮件验证码为：&quot;</span>+code+<span class="hljs-string">&quot;,本次验证码5分钟内有效，请及时输入。&quot;</span>);<br>        message.setTo(emailAddress);<br>        message.setFrom(sender);<br>        javaMailSender.send(message);    <span class="hljs-comment">//发送邮件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>@Value()注解：<code> @Value(&quot;$&#123;spring.mail.username&#125;&quot;)</code> 从配置文件中读取username的数据。</li>
<li><code> SimpleMailMessage message = new SimpleMailMessage();</code>创建一个简单的邮件对象。</li>
<li><code>message.setSubject()</code>设置邮件的标题</li>
<li><code>message.setText()</code>设置邮件的内容</li>
<li><code>message.setTo()</code>设置收件人的地址</li>
<li><code>message.setFrom()</code>设置发件人的地址</li>
</ul>
<ol start="3">
<li>随机生成6位数的验证码</li>
</ol>
<p>使用SecureRandom生成随机数。</p>
<blockquote>
<p>Math.random生成的是一般随机数，采用的是类似于统计学的随机数生成规则，其输出结果很容易预测，因此可能导致被攻击者击中。而SecureRandom是真随机数，采用的是类似于密码学的随机数生成规则，其输出结果较难预测，若想要预防被攻击者攻击，最好做到使攻击者根本无法，或不可能鉴别生成的随机值和真正的随机值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCode</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SYMBOLS=<span class="hljs-string">&quot;0123456789&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Random RANDOM = <span class="hljs-keyword">new</span> SecureRandom();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getVerifyCode</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">char</span> [] verifycode = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];   <span class="hljs-comment">//生成一个长度为6的字符数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; verifycode.length; i++) &#123;<br>            <span class="hljs-comment">//SYMBOLS.charAt()：返回目标索引下的字符</span><br>            <span class="hljs-comment">//RANDOM.nextInt(xx)：生成0~xx-1的随机数</span><br>            <span class="hljs-comment">//每次随机生成一个数x，并将SYMBOLS中的第n+1个数字返回给verifycode</span><br>            verifycode[i]=SYMBOLS.charAt(RANDOM.nextInt(SYMBOLS.length()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(verifycode);   <span class="hljs-comment">//将字符数组转成字符串</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程打印</title>
    <url>/2022/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<blockquote>
<p>在cvte一面的时候，面试官让我使用两个线程，模拟消费队列里面的消息，当时写不出来，现在来记录一下</p>
</blockquote>
<h3 id="实现Runable接口，使用synchronize加锁"><a href="#实现Runable接口，使用synchronize加锁" class="headerlink" title="实现Runable接口，使用synchronize加锁"></a>实现Runable接口，使用synchronize加锁</h3><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumbers</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-comment">//定义一个全局变量</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//循环遍历</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-comment">//加锁，锁的是当前对象</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-comment">//随机唤醒当前锁对象上的一个等待线程</span><br>                notify();<br>                <span class="hljs-keyword">if</span>(i &lt;=<span class="hljs-number">100</span>)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>                    i++;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程等待，wait()会释放锁，让其他进程可以得到锁向下执行</span><br>                        wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//退出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用synchronized加锁</span><br><span class="hljs-comment"> * 两个线程交替打印1-100</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : pety</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2022/6/30 23:32</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlternatePrint1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        PrintNumbers numbers = <span class="hljs-keyword">new</span> PrintNumbers();<br>        <span class="hljs-keyword">new</span> Thread(numbers,<span class="hljs-string">&quot;线程1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(numbers,<span class="hljs-string">&quot;线程2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>定时任务</title>
    <url>/2022/09/01/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><blockquote>
<p>定时任务：在固定的时候自动执行任务，不需要人为操纵</p>
<p>spring task：spring task是spring3以上版本自带的定时任务，实现定时任务的功能时，需要引入spring-context包</p>
</blockquote>
<ul>
<li><p>在项目的启动类上添加<code>@EnableScheduling</code>注解</p>
</li>
<li><p>创建定时任务类，使用<code>@Scheduled(cron =&quot;xxx&quot;)</code>注解编写定时规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定时任务类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : pety</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2022/5/4 19:54</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTask</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StatisticsDailyService staservice;<br><br>    <span class="hljs-comment">//每天的一点自动执行这个方法,</span><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 0 1 * * ? &quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span>&#123;<br>        staservice.registerCount(DateUtil.yesterday().toString());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



</li>
</ul>
<p>定时规则网上有生成工具，直接使用工具生成即可 </p>
]]></content>
  </entry>
  <entry>
    <title>秒杀项目</title>
    <url>/2022/09/01/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="秒杀项目"><a href="#秒杀项目" class="headerlink" title="秒杀项目"></a>秒杀项目</h1><h2 id="Redis前置知识"><a href="#Redis前置知识" class="headerlink" title="Redis前置知识"></a>Redis前置知识</h2><blockquote>
<p>缓存是护具交换的缓冲区，存储数据的临时地方，一般读写性能较高</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505192541978.png" alt="image-20220505192541978"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505195649566.png" alt="image-20220505195649566"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505201135930.png" alt="image-20220505201135930"></p>
<h3 id="缓存穿透的解决方法"><a href="#缓存穿透的解决方法" class="headerlink" title="缓存穿透的解决方法"></a>缓存穿透的解决方法</h3><ul>
<li>缓存null值</li>
<li>布隆过滤器</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505202606835.png" alt="image-20220505202606835"></p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505203604211.png" alt="image-20220505203604211"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505203633467.png" alt="image-20220505203633467"></p>
<h2 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a>全局唯一ID生成策略</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506102712210.png" alt="image-20220506102712210"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//1.生成时间戳</span><br>   LocalDateTime now = LocalDateTime.now();<br>   <span class="hljs-keyword">long</span> nowSecond = now.toEpochSecond(ZoneOffset.UTC);<br>   <span class="hljs-keyword">long</span> timestamp = nowSecond - BEGIN_TIMESTART;<br><br>   <span class="hljs-comment">//2.生成序列号</span><br>   <span class="hljs-comment">//2.1获取当前日期，精确到天</span><br>   String date = now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br><br>   <span class="hljs-comment">//2.2自增长，如果没有会自动生成</span><br>   <span class="hljs-keyword">long</span> count = redisUtil.incr(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date, <span class="hljs-number">1L</span>);<br><br>   <span class="hljs-comment">//时间戳左移32位与序列号做或运算</span><br>  <span class="hljs-keyword">return</span> timestamp&lt;&lt;<span class="hljs-number">32</span> | count;<br></code></pre></td></tr></table></figure>



<h2 id="秒杀基本步骤"><a href="#秒杀基本步骤" class="headerlink" title="秒杀基本步骤"></a>秒杀基本步骤</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506121646213.png" alt="image-20220506121646213"></p>
<h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><h4 id="为什么会出现超卖"><a href="#为什么会出现超卖" class="headerlink" title="为什么会出现超卖"></a>为什么会出现超卖</h4><p>在高并发的情况下，可能多个请求同时来查询数据库，此时查询到数据库的库存均为1，这时大家都认为库存充足，会进行下单操作。</p>
<p>在高并发的场景下，如果只是使用上面的步骤，那么出现超卖的问题，即商品的数量会成为负数，因此需要解决超卖问题。</p>
<p>可以使用悲观锁和乐观锁进行解决，悲观锁锁的粒度太大，降低程序并发性，因此我们选择乐观锁。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。如：Synchronized、Lock都属于悲观锁</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据的时候去判断有没有其他线程对数据做了修改。</p>
<ul>
<li>如果没有修改则认为是安全的，自己才更新数据。</li>
<li>如果已经被其他数据修改说明发生了安全问题，此时可以重试或异常。</li>
<li><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506121928226.png" alt="image-20220506121928226"></li>
</ul>
<p>在扣减库存的时候，判断数据库中的库存数量是否大于0。如果大于0，则进行修改并生成订单，如果小于等于0，直接返回失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//扣减库存</span><br><span class="hljs-comment">//修改数据的时候判断库存是否大于0</span><br><span class="hljs-keyword">boolean</span> success = seckillService.update().setSql(<span class="hljs-string">&quot;stock=stock-1&quot;</span>)<br>    									 .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>,voucherId)<br>    									 .gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>)<br>    									 .update();<br><span class="hljs-keyword">if</span>(!success)&#123;<br>    <span class="hljs-comment">//扣减失败</span><br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220513160417865.png" alt="image-20220513160417865"></p>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><blockquote>
<p>修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506122931656.png" alt="image-20220506122931656"></p>
<p>==根据优惠券id和用户id查询订单来判断该用户是否已经购买过此商品==</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220513161324381.png" alt="image-20220513161324381"></p>
<p>先判断用户是否已经购买，然后再进行扣减库存操作。<strong>但是可能存在一个用户在一开始多次请求，导致多个请求都查询到没有订单，多个请求都进行扣减库存</strong></p>
<p>单体系统可以使用加Synchronized锁来解决该问题，保证在同一时刻只会有一个用户能够去查询数据库。<strong>使用用户的id号作为锁对象，将id号转为String类型，然后调用intern()方法，将String放到字符串常量池，能够保证多个相同用户进来，锁的是同一个对象。jdk1.8后，使用intern()方法，如果字符串常量池没有该字符串，将这个字符串的引用保存到字符串常量池，如果有，直接返回值</strong></p>
<p>但是在分布式系统下，由于部署到多个服务器上，每个服务器上有一个锁监视器，锁监视器不共享，导致仍然可能出现同一个用户会购买到多个商品。==多个服务器锁住的不是同一个对象==，因此需要使用分布式锁来解决。 </p>
<p>上面的流程图是针对于加锁来实现的，其实可以给用户id和商品id加一个唯一的联合索引，创建订单时，如果用户id和商品id的组合在数据库中已经存在，则创建失败。成功之后再扣减库存。</p>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><blockquote>
<p>满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506180248864.png" alt="image-20220506180248864"></p>
<p><strong>由于set 和 expire 是两条语句，不具有原子性，因此使用set nx ex 同时设置值和过期时间，保证原子性</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506180327623.png" alt="image-20220506180327623"></p>
<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX = <span class="hljs-string">&quot;lock:&quot;</span>;<br><span class="hljs-comment">//uuid</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ID_PREFIX = UUID.randomUUID().toString(<span class="hljs-keyword">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutSec)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取线程标示</span><br>        String threadId = ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        Boolean success = stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="防止误删"><a href="#防止误删" class="headerlink" title="防止误删"></a>防止误删</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220506183318766.png" alt="image-20220506183318766"></p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 获取线程标示</span><br>        String threadId = ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁中的标示</span><br>        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-comment">// 判断标示是否一致</span><br>        <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            stringRedisTemplate.delete(KEY_PREFIX + name);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上面这个释放锁的代码有问题，因为获取锁标识和删除不是原子操作，可能会出现线程安全问题。</p>
<h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><blockquote>
<p>Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 执行redis命令，redis.call(&#x27;命令名称&#x27;，&#x27;key&#x27;,&#x27;其他参数&#x27;)</span><br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;jack&#x27;</span>)<br><br><span class="hljs-comment">-- 先执行set name jack</span><br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;jack&#x27;</span>)<br><span class="hljs-comment">-- 再执行get name</span><br><span class="hljs-keyword">local</span> name = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>)<br><span class="hljs-comment">-- 返回</span><br><span class="hljs-keyword">return</span> name<br><br><span class="hljs-comment">-- 可以传参，key类型参数放入KEYS数组，其他参数放入ARGV数组，下标从1开始</span><br></code></pre></td></tr></table></figure>



<h3 id="使用lua脚本改造分布式锁"><a href="#使用lua脚本改造分布式锁" class="headerlink" title="使用lua脚本改造分布式锁"></a>使用lua脚本改造分布式锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeckillApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DefaultRedisScript  script;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        ValueOperations valueOperations = redisTemplate.opsForValue();<br>        String s = UUID.randomUUID().toString();<br>        <span class="hljs-comment">//设置锁，相当于setnx指令。值不存在则设置成功，否则失败。并给锁设置一个值，用来检验当前锁是否是自己的锁</span><br>        <span class="hljs-comment">// 设置过期时间，防止程序出现异常时锁无法释放导致整个程序阻塞</span><br>        Boolean isLock = valueOperations.setIfAbsent(<span class="hljs-string">&quot;k1&quot;</span>, s, <span class="hljs-number">120</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//如果获取锁成功</span><br>        <span class="hljs-keyword">if</span>(isLock)&#123;<br>            valueOperations.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;xxxx&quot;</span>);<br>            String name = (String) valueOperations.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;name:&quot;</span>+name);<br>            System.out.println(valueOperations.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>            <span class="hljs-comment">//判断目前锁是否是自己的锁。可能存在线程执行时间长，当锁已经过期自动释放后才执行完，</span><br>            <span class="hljs-comment">//这个时候需要判断锁是否为自己锁，直接删除锁可能会删掉其他线程的锁。</span><br>            <span class="hljs-comment">//由于获取锁，判断锁，删除锁三个语句不是原子性操作，因此使用lua脚本，保证三个语句的原子性</span><br>            Boolean result = (Boolean) redisTemplate.execute(script, Collections.singletonList(<span class="hljs-string">&quot;k1&quot;</span>), s);<br>            System.out.println(result);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;有线程在使用，请稍后&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>lua脚本</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span>   <span class="hljs-comment">--从redis中查询 key为keys[1]的值是否和ARGV[1]相等，相等就删除keys[1]</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])			<span class="hljs-comment">--keys[1]和ARGV[1]是从后端传过来的值</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><strong>配置<code>DefaultRedisScript</code></strong></p>
<p>在<code>RedisConfig</code>中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultRedisScript&lt;Boolean&gt; <span class="hljs-title">script</span><span class="hljs-params">()</span></span>&#123;<br>    DefaultRedisScript&lt;Boolean&gt; script = <span class="hljs-keyword">new</span> DefaultRedisScript&lt;&gt;();<br>    <span class="hljs-comment">//lock.lua脚本位置和application.yml同级目录</span><br>    script.setLocation(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;lock.lua&quot;</span>));<br>    script.setResultType(Boolean.class);<br>    <span class="hljs-keyword">return</span> script;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><blockquote>
<p>Redisson是在Redis基础上实现的Java驻内存数据网格，不仅提供了一系列的分布式的java常用对象，还提供了许多分布式服务，其中包含了各种分布式锁的实现</p>
</blockquote>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>配置Redisson客户端，写一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedissonConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient</span><span class="hljs-params">()</span></span>&#123;<br>        Config config = <span class="hljs-keyword">new</span> Config();<br>        <span class="hljs-comment">//useSingleServer表示目前是单节点的redis，然后设置地址和密码</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.217.4:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;asd789142&quot;</span>);<br>        <span class="hljs-comment">//创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>使用Redisson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>      <span class="hljs-comment">//获取锁，指定锁名称</span><br>      RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>      <span class="hljs-comment">//尝试获取锁，第一个参数是重试时间，在设置时间内获取失败会重试，如果超过设置时间则直接返回，不设置为-1，不重试</span><br>      <span class="hljs-comment">//第二个参数是锁自动释放时间，不释放默认是30秒</span><br>      <span class="hljs-comment">//第三个参数是是简单</span><br>      <span class="hljs-keyword">boolean</span> isLock = lock.tryLock(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>      <span class="hljs-comment">//判断锁是否获取成功</span><br>      <span class="hljs-keyword">if</span>(isLock)&#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);<br>          &#125;<span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-comment">//释放锁</span><br>              lock.unlock();<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><blockquote>
<p>将数据放到redis中，提高系统的并发能力，在redis中进行判断，如果不符合购买资格==库存不足或已经购买过==，则直接返回。如果有购买资格，则返回给用户订单编号，使用消息队列进行异步下单处理。</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220516170336478.png" alt="image-20220516170336478"></p>
<h2 id="Redis预减库存"><a href="#Redis预减库存" class="headerlink" title="Redis预减库存"></a>Redis预减库存</h2><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>在controlle层实现<code>InitializingBean</code>接口，接着实现<code>afterPropertiesSet</code>方法。</p>
<blockquote>
<p>sping启动后，初始化Bean时，若该bean实现InitializingBean接口，会自动调用afterPropertiesSet()方法，完成用户自定义的初始化操作</p>
</blockquote>
<p>在<code>afterPropertiesSet</code>方法中，查询数据库，将商品的信息保存到redis中，并且设置一个map保存每个商品的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">//初始化容器的时候执行的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;GoodsVo&gt; list = service.findGoodsVo();<br>        <span class="hljs-keyword">if</span>(list.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//在初始化容器的时候，将数据放到redis里面，直接在redis进行数量的增减</span><br>        <span class="hljs-comment">//数据预热</span><br>        list.forEach(goodsVo -&gt;&#123;<br>            redisUtil.set(<span class="hljs-string">&quot;seckillGoods:&quot;</span>+goodsVo.getId(),goodsVo.getStockCount());<br>            EmptyStockMap.put(goodsVo.getId(), <span class="hljs-keyword">false</span>);<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="商品抢购"><a href="#商品抢购" class="headerlink" title="商品抢购"></a>商品抢购</h3><p>在下单的时候，不需要直接访问数据库，而是访问redis。通过内存标记，减少redis的访问。每次抢购成功，将商品数量减1，然后使用rabbitmq进行异步操作，发布消息去操作数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否重复抢购</span><br>     SeckillOrder seckillOrder = (SeckillOrder) redisUtil.get(<span class="hljs-string">&quot;user:&quot;</span> + user.getId() + <span class="hljs-string">&quot;:&quot;</span> + goodsId);<br>     <span class="hljs-keyword">if</span>(seckillOrder != <span class="hljs-keyword">null</span>)&#123;<br>         <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.REPATE_ERROR);<br>     &#125;<br><br>     <span class="hljs-comment">//通过内存标记，减少redis的访问，在初始化容器的时候，将商品数量存入redis，并设置一个map来保存每个商品的状态</span><br>     <span class="hljs-comment">//当商品库存为0时，将状态设置为true，之后每次进来判断状态，如果</span><br>     <span class="hljs-keyword">if</span> (EmptyStockMap.get(goodsId))&#123;<br>         <span class="hljs-keyword">return</span>  RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>     &#125;<br><br>     <span class="hljs-comment">//预减库存</span><br>     <span class="hljs-keyword">long</span> stock = redisUtil.decr(<span class="hljs-string">&quot;seckillGoods&quot;</span> + goodsId, <span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">if</span>(stock &lt; <span class="hljs-number">0</span>)&#123;<br>         EmptyStockMap.put(goodsId,<span class="hljs-keyword">true</span>);<br>         redisUtil.incr(<span class="hljs-string">&quot;seckillGoods&quot;</span>+goodsId,<span class="hljs-number">1</span>);<br>         <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>     &#125;<br><br>     SeckillMessage seckillMessage = <span class="hljs-keyword">new</span> SeckillMessage(user, goodsId);<br><br>     mqSender.sendSeckillMessage(JSON.toJSONString(seckillMessage));<br><br></code></pre></td></tr></table></figure>



<h2 id="RabbitMQ秒杀操作"><a href="#RabbitMQ秒杀操作" class="headerlink" title="RabbitMQ秒杀操作"></a>RabbitMQ秒杀操作</h2><blockquote>
<p>Rabbitmq主要是用来实现异步和流量消峰</p>
</blockquote>
<p>消费者用来接收消息，然后去操作数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;seckillqueue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-comment">//将消息转成原来的对象</span><br>        SeckillMessage seckillMessage = JSON.parseObject(message, SeckillMessage.class);<br><br>        Long goodsId = seckillMessage.getGoodsId();<br><br>        User user = seckillMessage.getUser();<br>        <span class="hljs-comment">//判断数据库中商品的库存， 如果商品数量小于1，直接返回</span><br>        GoodsVo goodsVo = goodsService.findGoodsVoByGoodsId(goodsId);<br>        <span class="hljs-keyword">if</span>(goodsVo.getStockCount()&lt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断是否重复抢购</span><br>        SeckillOrder seckillOrder = (SeckillOrder) redisUtil.get(<span class="hljs-string">&quot;user:&quot;</span> + user.getId() + <span class="hljs-string">&quot;:&quot;</span> + goodsId);<br>        <span class="hljs-keyword">if</span>(seckillOrder != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//下单操作</span><br>        iOrderService.seckill(user,goodsVo);<br><br>    &#125;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>今年一定过四级</title>
    <url>/2020/10/12/%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<ol>
<li><p><strong>stability：</strong> n  稳定（性）、稳固（性）</p>
<ul>
<li>social stability          社会稳定</li>
<li>stable        adj  稳定的    n 马厩，牛棚</li>
</ul>
<a id="more"></a></li>
<li><p><strong>trace：</strong> n   痕迹、踪迹、足迹、微量、追查；v   仔细寻找、追踪、研究….的历史、探究…..的发展;  v 描绘</p>
<ul>
<li>trace back       追溯</li>
<li>a trace of   少量的，一丝的</li>
<li>without trace  了无踪迹</li>
</ul>
</li>
<li><p><strong>admission：</strong> n  允许加入，许可；入场费；承认</p>
<ul>
<li>admit   vt  承认，允许进入；vi 承认，容许</li>
<li>admission office     招生办</li>
<li>permission   n    允许，许可</li>
</ul>
</li>
<li><p><strong>arrival：</strong>  n    到达，抵达，到达者</p>
<ul>
<li>cash on arrival   货到付款</li>
<li>with the arrival of    随着…的到来</li>
<li>arrive  vi 到达</li>
</ul>
</li>
<li><p><strong>fifty：</strong>   n   五十几，五十年代；num  五十 ；adj 许多的</p>
<ul>
<li>fiftieth    第五十的，五十分之一的</li>
</ul>
</li>
<li><p><strong>pollution：</strong> n 污染，污染物，垃圾</p>
<ul>
<li>to reduce levels of environmental pollution    降低环境污染的程度</li>
<li>environmental pollution   环境污染</li>
<li>popular  n   流行</li>
<li>population  n  人口</li>
</ul>
</li>
<li><p><strong>mile：</strong> n  英里，很远的距离 </p>
<ul>
<li>meter   n  米</li>
<li>mile better  好得多  ： she’s felling mile better today.   她今天觉得好多了</li>
<li>stand out a mile 显而易见</li>
<li>kilometer  公里</li>
</ul>
</li>
<li><p><strong>glove：</strong>  n   手套 ；  v  给戴手套</p>
<ul>
<li>a pair of gloves   一副手套</li>
<li>fit…..like a glove    恰当，合身,对….来说很合适</li>
<li>as right as my glove  完全正确</li>
</ul>
</li>
<li><p><strong>romantic：</strong>  adj  浪漫的，爱情的；n 浪漫的人，耽于幻想的人</p>
<ul>
<li>I‘m not interested in a romantic relationship   我对谈情说爱不感兴趣</li>
<li>romantic notions    异想天开的念头</li>
<li>romance   浪漫史，爱情小说，恋爱关系</li>
<li>romantic movement  n  浪漫主义运动</li>
</ul>
</li>
<li><p><strong>angle：</strong> n  角，角度，观点，斜角   v.钓鱼</p>
<ul>
<li>eye angle    视野</li>
<li>angle for  谋取   angle for promotion   谋求升职</li>
<li>triangle   三角形</li>
<li>anger  生气；  angel  天使</li>
</ul>
</li>
<li><p><strong>lawn：</strong> n  草坪，草地，上等细棉布</p>
<ul>
<li>He spent a whole afternoon mowing the lawn in front of his house  他花了一下午的时间修剪门前的草坪</li>
<li>lawn mower  割草机</li>
<li>meadow  草原</li>
</ul>
</li>
<li><p><strong>bite：</strong>  v  咬，叮； n  咬，少量食物</p>
<ul>
<li>Stop biting your nails   别咬指甲了</li>
<li>bite the dust  碰瓷了</li>
</ul>
</li>
<li><p><strong>brilliant：</strong> adj  聪颖的，才华横溢的，优秀的，卓越的；  n  钻石</p>
<ul>
<li>a brilliant performance  精彩的表演</li>
<li>a brilliant culture  灿烂的文化</li>
<li>a brilliant sunshine  灿烂的阳光</li>
<li>brilliant idea 高招，绝妙的主意   He came up a brilliant idea. 他想出了一个绝妙的主意。</li>
</ul>
</li>
<li><p><strong>vital：</strong> adj  重要的，必不可少的，生机勃勃的</p>
<ul>
<li>The police play a vital role in our society   警察在我们的社会中扮演着重要的角色。</li>
<li>vitality   n  精神，活力，力量，生命力</li>
<li>vital issue  至关重要的问题</li>
</ul>
</li>
<li><p><strong>convert：</strong>  v  （使）转变，（使）改变信仰 ;   n  皈依者</p>
<ul>
<li>convert…into   将…改变成   convert stocks into cash   将股票兑换成现金</li>
<li>unconverted   adj  不改变的</li>
<li>converter  转换器</li>
<li>conversation  交谈</li>
</ul>
</li>
<li><p><strong>comprehensive：</strong> adj  综合的，全面的，有理解力的</p>
<ul>
<li>They did a comprehensive study on leanring styles  他们对学习方式做了全面的研究</li>
<li>comprehension  n  理解力，理解</li>
<li>comprehensive university  综合性大学</li>
<li>comprehensive  quality  综合素质</li>
<li>prehensive  adj  握住的，抓住的</li>
</ul>
</li>
<li><p><strong>prominent：</strong> adj 杰出的，显著的，突出的</p>
<ul>
<li>As the leader,he played a prominent part in the team’s victory.  作为队长，他在小组的胜利中发挥了重要的作用</li>
<li>prominently  显著的，明显的</li>
</ul>
</li>
<li><p><strong>load：</strong> v  装填，装载  n  负荷，负担</p>
<ul>
<li>The trucks watied at the warehouse to pick up their loads.货车在仓库等着装载货物。</li>
<li>a load of 大量，许多</li>
<li>study load 学习任务</li>
</ul>
</li>
<li><p><strong>introduction：</strong> n  引入，引进，采用，介绍，入门</p>
<ul>
<li>the introduction of new manufacturing methods 新制造方法的采用</li>
<li>recommend  vt  推荐，介绍，劝告 </li>
<li>letter of introduction   介绍信</li>
<li>brief introduction  简介，简短介绍</li>
<li>introduce  vt 提出 介绍</li>
</ul>
</li>
<li><p><strong>pretend：</strong> v 假装 佯装 自称 模拟；  adj 假装的，想象的</p>
<ul>
<li>I’m tired of having to pretend all the time  我厌倦了一直假装</li>
<li>pretend to 假装 </li>
<li>pretend anger 假装生气 </li>
<li>pretend to be   假装是</li>
<li>pretend to do sth   假装做某事</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>单词</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2021/07/22/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>和前端进行对接，我将产生的token值传给前端，然后前端将这个token值设置在请求头中传给我，当他请求的时候，就报了一个跨域的错误。</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2021/06/25/mvMYFTxkbOB82gA.png" alt="bedbcfe80d7aa55080abad3c9cd417c0"></p>
<p>解决跨域问题，我在网上找了很多博客，都是说添加一个过滤器来过滤前端发起的请求，然后上次学姐说她是在拦截器中做了设置，目前还不知道在拦截器中如何设置，所以我写的这篇文章是添加一个过滤器。</p>
<h4 id="实现Filter接口，重写doFilter方法"><a href="#实现Filter接口，重写doFilter方法" class="headerlink" title="实现Filter接口，重写doFilter方法"></a>实现Filter接口，重写doFilter方法</h4><p><strong>这是出现了问题，然后学姐说是因为OPTIONS方法的问题，然后做了一个判断，但是好像出错的原因并不是因为这个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许跨域访问过滤器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;<br>        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, httpRequest.getHeader(<span class="hljs-string">&quot;Origin&quot;</span>));<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, httpRequest.getMethod());<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>);<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, httpRequest.getHeader(<span class="hljs-string">&quot;Access-Control-Request-Headers&quot;</span>));<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-keyword">if</span> (httpRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            filterChain.doFilter(servletRequest, servletResponse);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这是最初的版本</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许跨域访问过滤器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;<br>        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, httpRequest.getHeader(<span class="hljs-string">&quot;Origin&quot;</span>));<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, httpRequest.getMethod());<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>);<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, httpRequest.getHeader(<span class="hljs-string">&quot;Access-Control-Request-Headers&quot;</span>));<br>        httpResponse.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="添加对应的配置类"><a href="#添加对应的配置类" class="headerlink" title="添加对应的配置类"></a>添加对应的配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.hutbbs.interceptor.CorsFilter;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    CorsFilter corsFilter;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">CorsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        FilterRegistrationBean registrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>        <span class="hljs-comment">//注入过滤器</span><br>        registrationBean.setFilter(corsFilter);<br>        <span class="hljs-comment">//过滤器名称</span><br>        registrationBean.setName(<span class="hljs-string">&quot;CorsFilter&quot;</span>);<br>        <span class="hljs-comment">//拦截规则</span><br>        registrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-comment">//过滤器顺序</span><br>        registrationBean.setOrder(FilterRegistrationBean.HIGHEST_PRECEDENCE);<br><br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="为什么有跨域问题"><a href="#为什么有跨域问题" class="headerlink" title="为什么有跨域问题"></a>为什么有跨域问题</h2><p>前后端服务中，协议、域名、端口号只要有一个不相同，那么就是不同源的，这样就会产生跨域问题</p>
<h2 id="解决跨域问题的三种方法"><a href="#解决跨域问题的三种方法" class="headerlink" title="解决跨域问题的三种方法"></a>解决跨域问题的三种方法</h2><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>可以在类名或者方法上添加<code>@CrossOrigin</code>注解</p>
<h3 id="添加过滤器"><a href="#添加过滤器" class="headerlink" title="添加过滤器"></a>添加过滤器</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : pety</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2022/5/29 21:36</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span></span>&#123;<br><br>        CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();<br>        <span class="hljs-comment">//添加允许访问的请求体</span><br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//添加允许访问的方法</span><br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//允许访问的源列表</span><br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>,corsConfiguration);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>实现接口 WebCMvcConfigure接口，重写addCorsMapping方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : pety</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2022/5/29 21:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;PUT&quot;</span>,<span class="hljs-string">&quot;DELETE&quot;</span>,<span class="hljs-string">&quot;HEAD&quot;</span>,<span class="hljs-string">&quot;OPTIONS&quot;</span>)<br>                .allowCredentials(<span class="hljs-keyword">true</span>)<br>                <span class="hljs-comment">//配置缓存时间</span><br>                .maxAge(<span class="hljs-number">3600</span>)<br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2022/07/31/Go/</url>
    <content><![CDATA[<h2 id="结构程序化"><a href="#结构程序化" class="headerlink" title="结构程序化"></a>结构程序化</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><blockquote>
<p>必须以字母或者下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</p>
</blockquote>
<p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p>
<blockquote>
<p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> 变量名字 类型 = 表达式<br></code></pre></td></tr></table></figure>

<p>其中“<em>类型</em>”或“*= 表达式*”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p>
<h4 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h4><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">1.2</span><br></code></pre></td></tr></table></figure>

<p>请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。</p>
<p>简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。</p>
<p>在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go">in, err := os.Open(infile)<br><span class="hljs-comment">// ...</span><br>out, err := os.Create(outfile)<br></code></pre></td></tr></table></figure>



<p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go">f, err := os.Open(infile)<br><span class="hljs-comment">// ...</span><br>f, err := os.Create(outfile) <span class="hljs-comment">// compile error: no new variables</span><br></code></pre></td></tr></table></figure>

<p>解决的方法是第二个简短变量声明语句改用普通的多重赋值语句。</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。</p>
<p>如果用<code>var x int</code>声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go">x := <span class="hljs-number">1</span><br>p := &amp;x         <span class="hljs-comment">// p, of type *int, points to x</span><br>fmt.Println(*p) <span class="hljs-comment">// &quot;1&quot;</span><br>*p = <span class="hljs-number">2</span>          <span class="hljs-comment">// equivalent to x = 2</span><br>fmt.Println(x)  <span class="hljs-comment">// &quot;2&quot;</span><br></code></pre></td></tr></table></figure>



<p>任何类型的指针的零值都是nil。如果p指向某个有效变量，那么<code>p != nil</code>测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x, y <span class="hljs-keyword">int</span><br>fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// &quot;true false false&quot;</span><br></code></pre></td></tr></table></figure>



<h4 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h4><p><strong>变量的生命周期指的是在程序运行期间变量有效存在的时间段。</strong>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：<strong>每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。</strong>函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p>
<p>Go的垃圾收集器判断一个变量是否可以回收的基本思路：从每个包级的变量和每个当前的运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的。也就是说它是否存在并不影响程序后续的计算结果。</p>
<p><strong>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</strong></p>
<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> global *<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><br>    x = <span class="hljs-number">1</span><br>    global = &amp;x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>    y := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>    *y = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><strong>反转数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        s[i], s[j] = s[j], s[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go">a := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>reverse(a[:])<br>fmt.Println(a) <span class="hljs-comment">// &quot;[5 4 3 2 1 0]&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>将元素循环向左旋转n个元素</strong>：三次调用reverse反转函数，第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。（如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go">s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// Rotate s left by two positions.</span><br>reverse(s[:<span class="hljs-number">2</span>])<br>reverse(s[<span class="hljs-number">2</span>:])<br>reverse(s)<br>fmt.Println(s) <span class="hljs-comment">// &quot;[2 3 4 5 0 1]&quot;</span><br></code></pre></td></tr></table></figure>





<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><blockquote>
<p>defer语句 后紧跟随到语句会被延迟处理。</p>
<p>在defer所属函数返回时，将被defer修饰的语句逆序执行。</p>
<p>也就是最下面的defer语句最先执行。可以用来做资源清理：数据库连接释放、锁资源释放、关闭文件</p>
</blockquote>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote>
<p>先于main函数自动执行，不可以被其他函数调用。</p>
<p>init函数既没有参数也没有返回值，一个包可以有多个init函数，</p>
<p>可以用来做一些初始化操作：初始化顺序：<strong>变量初始化-&gt;init-&gt;main</strong></p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   name <span class="hljs-keyword">string</span><br>   age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">//定义构造方法 ，返回两个参数，第一个是一个指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*Person, error)</span></span> &#123;<br>   <span class="hljs-comment">// 字符串可以直接比较</span><br>   <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;姓名不能为空&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;age 不能小于0&quot;</span>)<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> &amp;Person&#123;name, age&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//接受两个参数，第一个是一个指针类型</span><br>   person, err := newPerson(<span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-number">-1</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, *person)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote>
<p>创建一个协程非常容易，在语句前面加上 go 即可</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>      fmt.Println(msg)<br>      <span class="hljs-comment">//休眠100ms</span><br>      time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;java&quot;</span>) <span class="hljs-comment">//go 启动了一个协程来执行</span><br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;golang&quot;</span>)<br>   fmt.Println(<span class="hljs-string">&quot;end...&quot;</span>) <span class="hljs-comment">//主函数退出，程序就结束了，会发现并不会打印5次java 和5次 go</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><blockquote>
<p>通道用于在协程之前共享数据</p>
<ol>
<li>对于一个通道，发送操作之间是互斥的，接受操作之间也是互斥的</li>
<li>发送操作和接受操作中对元素值的处理都是不可分割的</li>
<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li>
</ol>
</blockquote>
<p>根据数据交换的行为，有两种类型的通道：无缓冲通道和缓冲通道。无缓冲通道用于执行通道之间的同步通信，而缓冲通道用于执行异步通信。无缓冲通道保证在发送和接收发生的瞬间执行两个协程之间的交换，缓冲通道没有这样的保证。</p>
<p>语法：由make函数创建，制定chan关键字和通道的元素类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">unbuffered := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)  <span class="hljs-comment">//创建无缓冲的int型通道</span><br>buffered :=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span> <span class="hljs-number">10</span>) <span class="hljs-comment">//创建有缓冲的int型通道</span><br></code></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;math/rand&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//创建一个无缓冲的通道</span><br><span class="hljs-keyword">var</span> values = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-comment">//向通道中添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span> &#123;<br>   rand.Seed(time.Now().UnixNano())<br>   <span class="hljs-comment">//返回[0,n)的伪随机数</span><br>   value := rand.Intn(<span class="hljs-number">10</span>)<br>   <span class="hljs-built_in">println</span>(value)<br>   <span class="hljs-comment">//休眠5s，5s之后向通道放入数据</span><br>   time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>   <span class="hljs-comment">//将value 写入到 values中（通道）</span><br>   values &lt;- value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//程序运行结束的之前关闭通道</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(values)<br>   <span class="hljs-comment">//启动一个协程</span><br>   <span class="hljs-keyword">go</span> send()<br>   fmt.Println(<span class="hljs-string">&quot;wait...&quot;</span>)<br>   <span class="hljs-comment">//会一直阻塞，直到通道中被放入数据</span><br>   value := &lt;-values<br>   fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="waitgroup"><a href="#waitgroup" class="headerlink" title="waitgroup"></a>waitgroup</h3><blockquote>
<p>有点像java的countdownlanch，用于实现同步</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showMessage</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-comment">//表示任务完成，计数器减1</span><br>   <span class="hljs-keyword">defer</span> wg.Done()<br>   <span class="hljs-built_in">println</span>(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>      <span class="hljs-comment">//计数器加1</span><br>      wg.Add(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">go</span> showMessage(i)<br>   &#125;<br>   <span class="hljs-comment">//阻塞，直到计数器的值为0</span><br>   wg.Wait()<br>   <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;end...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><h4 id="Gosched"><a href="#Gosched" class="headerlink" title="Gosched()"></a>Gosched()</h4><blockquote>
<p>主动让出cpu时间，重新等待安排任务</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;runtime&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>      <span class="hljs-built_in">println</span>(s)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;java&quot;</span>)<br><br>  <span class="hljs-comment">//主协程</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>      <span class="hljs-comment">//让出cpu时间片，等待重新分配任务</span><br>      runtime.Gosched()<br>      <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;golang&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的例子会先打印两遍java，再打印两遍golang。</p>
<p>虽然主协程和开启的协程会异步运行，但是由于使用了<code>runtime.Gosched()</code>,主协程会自动让出cpu，让其他协程运行，因此会等到没有其他协程运行才开始运行，实现了同步。</p>
<h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><blockquote>
<p>退出当前协程</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;runtime&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      <span class="hljs-comment">//如果i&gt;=5，直接退出协程</span><br>      <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">5</span> &#123;<br>         runtime.Goexit()<br>      &#125;<br>      <span class="hljs-built_in">println</span>(s)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;java&quot;</span>)<br>   time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><blockquote>
<p>设置最大的可执行的cpu数量</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;runtime&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;a:%v\n&quot;</span>, i)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;b:%v\n&quot;</span>, i)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//获取当前机器的cpu数量</span><br>   cpu := runtime.NumCPU()<br>   <span class="hljs-comment">//设置当前最大的执行cpu数量</span><br>   runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">go</span> a()<br>   <span class="hljs-keyword">go</span> b()<br>   <span class="hljs-built_in">println</span>(cpu)<br><br>   time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Metux"><a href="#Metux" class="headerlink" title="Metux"></a>Metux</h3><blockquote>
<p>加互斥锁</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> wt sync.WaitGroup<br><span class="hljs-comment">//定义互斥锁变量</span><br><span class="hljs-keyword">var</span> lock sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">defer</span> wt.Done()<br>   lock.Lock()<br>   i++<br>   fmt.Println(<span class="hljs-string">&quot;add&quot;</span>, i)<br>   lock.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">defer</span> wt.Done()<br>  <span class="hljs-comment">//加锁</span><br>   lock.Lock()<br>   time.Sleep(time.Millisecond * <span class="hljs-number">2</span>)<br>   i--<br>   fmt.Println(<span class="hljs-string">&quot;sub&quot;</span>, i)<br>  <span class="hljs-comment">//解锁 </span><br>   lock.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>      wt.Add(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">go</span> add()<br>      wt.Add(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">go</span> sub()<br>   &#125;<br><br>   wt.Wait()<br>   fmt.Println(<span class="hljs-string">&quot;end:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="select-switch"><a href="#select-switch" class="headerlink" title="select switch"></a>select switch</h3><blockquote>
<p>并发中的控制语句，类似于switch。用于处理异步io。</p>
<p>select会监听case中channel的读写操作，当case中的读写操作为非阻塞操作时，会触发响应的动作</p>
<p>select中的case语句必须是一个channel操作</p>
<p>select中的default语句总是可以运行</p>
</blockquote>
<ul>
<li>如果有多个case可以运行，select会公平的随机选择一个执行，其他的不执行</li>
<li>如果没有可运行的case，且有default语句，那么就会执行default语句</li>
<li>如果没有可运行的case，且没有default语句,select会阻塞，直到某个case通信可以运行</li>
</ul>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><blockquote>
<p>定时器，可以实现一些定时操作，内部通过channel实现</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个2s的定时器</span><br>   timer := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, time.Now())<br>   <span class="hljs-comment">//会一直阻塞，直到定时器的时间过了</span><br>   t := &lt;-timer.C<br>   fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, t)<br><br>   <span class="hljs-comment">//创建一个定时器，又阻塞两秒，</span><br>   timer2 := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>   &lt;-timer2.C<br><br>   <span class="hljs-comment">//可以使用Sleep实现阻塞功能</span><br>   time.Sleep(time.Second * <span class="hljs-number">2</span>)<br><br>   <span class="hljs-comment">//after也可以实现阻塞，after返回的就是 chan Time</span><br>   &lt;-time.After(time.Second * <span class="hljs-number">2</span>)<br><br>   timer3 := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      &lt;-timer3.C<br>      fmt.Println(<span class="hljs-string">&quot;hhh&quot;</span>)<br>   &#125;()<br>   <span class="hljs-comment">//上面定义了一个2s的定时器timer3，但是调用stop会立即停止等待,后面的打印也不会执行</span><br>   timer3.Stop()<br><br>   <span class="hljs-comment">//定义一个5s的定时器</span><br>   timer4 := time.NewTimer(time.Second * <span class="hljs-number">5</span>)<br>   <span class="hljs-comment">//修改定时器的时间为2s</span><br>   timer4.Reset(time.Second * <span class="hljs-number">2</span>)<br>   <span class="hljs-comment">//只阻塞2s</span><br>   &lt;-timer.C<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h3><blockquote>
<p>ticker周期性的执行</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个ticker，周期性的执行一次</span><br>   ticker := time.NewTicker(time.Second)<br>   <span class="hljs-comment">/*count := 1</span><br><span class="hljs-comment">   for _ = range ticker.C &#123;</span><br><span class="hljs-comment">      println(&quot;ticker&quot;)</span><br><span class="hljs-comment">      count++</span><br><span class="hljs-comment">      if count &gt;= 5 &#123;</span><br><span class="hljs-comment">         ticker.Stop()</span><br><span class="hljs-comment">         break</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">   &#125;*/</span><br><br>   chanInt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br>   <span class="hljs-comment">//创建一个协程，周期性的向channel中写入数据，后面加（）是让匿名函数自己调用自己</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">for</span> _ = <span class="hljs-keyword">range</span> ticker.C &#123;<br>         <span class="hljs-keyword">select</span> &#123;<br>         <span class="hljs-keyword">case</span> chanInt &lt;- <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;发送1&quot;</span>)<br>         <span class="hljs-keyword">case</span> chanInt &lt;- <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;发送2&quot;</span>)<br>         <span class="hljs-keyword">case</span> chanInt &lt;- <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;发送3&quot;</span>)<br>         &#125;<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-comment">//从channel中读取数据</span><br>   <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> chanInt &#123;<br>      <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;收到：&quot;</span>, v)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><blockquote>
<p>sycn下的atomic是一个原子包，可以保证操作的原子性</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;sync/atomic&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int32</span> = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//使用原子操作：cas，compare and swap 保证线程安全</span><br>   <span class="hljs-comment">//第一个是变量的地址，第二个是增加的值</span><br>   atomic.AddInt32(&amp;i, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span></span> &#123;<br>   atomic.AddInt32(&amp;i, <span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>      <span class="hljs-keyword">go</span> add()<br>      <span class="hljs-keyword">go</span> sub()<br>   &#125;<br>   time.Sleep(time.Second)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;结果为：&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;io/ioutil&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">//创建文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createFile</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建文件，传入文件名称</span><br>   <span class="hljs-comment">//返回文件和错误信息，如果没发生错误，err=nil</span><br>   file, err := os.Create(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, file.Name())<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeDir</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建目录，第一个是目录名，第二个是权限，ModePerm表示最高权限</span><br>   err := os.Mkdir(<span class="hljs-string">&quot;a&quot;</span>, os.ModePerm)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125;<br>   <span class="hljs-comment">//MkdirAll 创建多级目录</span><br>   err1 := os.MkdirAll(<span class="hljs-string">&quot;b/c/d&quot;</span>, os.ModePerm)<br>   <span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err1)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//删除单个文件，可以是文件也可以是目录</span><br>   err := os.Remove(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125;<br><br>   err1 := os.RemoveAll(<span class="hljs-string">&quot;b&quot;</span>)<br>   <span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err1)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 工作目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wd</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//获取当前工作目录</span><br>   dir, err := os.Getwd()<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//打印当前目录</span><br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, dir)<br>   &#125;<br>   <span class="hljs-comment">//修改当前工作目录</span><br>   os.Chdir(<span class="hljs-string">&quot;Users/didi/&quot;</span>)<br>   dir, _ = os.Getwd()<br>   <span class="hljs-comment">//打印当前目录</span><br>   fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, dir)<br>   <span class="hljs-comment">//临时目录</span><br>   tempDir := os.TempDir()<br>   fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, tempDir)<br>&#125;<br><br><span class="hljs-comment">//重命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rename</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//重命名，1.旧文件名 2.新文件名</span><br>   err := os.Rename(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;b.txt&quot;</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//使用ioutil.ReadFile读取，直接输入文件名</span><br>   file, _ := ioutil.ReadFile(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, <span class="hljs-keyword">string</span>(file[:]))<br><br>   <span class="hljs-comment">//先创建句柄再读取</span><br>   open, _ := os.Open(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   bytes, _ := ioutil.ReadAll(open)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bytes[:]))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeFile</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//ioutil.WriteFile 写入：文件名、字节数组、权限</span><br>   <span class="hljs-comment">//会覆盖之前的内容</span><br>   ioutil.WriteFile(<span class="hljs-string">&quot;a.txt&quot;</span>, []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>), os.ModePerm)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   createFile()<br>   makeDir()<br>   remove()<br>   wd()<br>   readFile()<br>   writeFile()<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="File文件读操作"><a href="#File文件读操作" class="headerlink" title="File文件读操作"></a>File文件读操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;io&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openclose</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//打开文件，使用open方法文件只读，如果文件不存在则报错</span><br>   <span class="hljs-comment">//底层还是调用OpenFile方法</span><br>   file, _ := os.Open(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   <span class="hljs-built_in">println</span>(file.Name())<br><br>   <span class="hljs-comment">//O_RDWR：读写权限，O_CREATE：如果文件不存在则创建一个</span><br>   file, _ = os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="hljs-number">0755</span>)<br>   <span class="hljs-built_in">println</span>(file.Name())<br><br>   <span class="hljs-comment">//关闭文件</span><br>   file.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//等价于OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)</span><br>   file, _ := os.Create(<span class="hljs-string">&quot;a1.txt&quot;</span>)<br>   <span class="hljs-built_in">println</span>(file.Name())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> &#123;<br>   file, _ := os.Open(<span class="hljs-string">&quot;a.txt&quot;</span>)<br><br>   <span class="hljs-comment">//循环读取</span><br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-comment">//创建一个字符数组</span><br>      bufer := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">10</span>)<br>      <span class="hljs-comment">//将文件的数据读取到字符数组</span><br>      read, err := file.Read(bufer)<br>      <span class="hljs-comment">//如果读到文件末尾，退出循环</span><br>      <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>         <span class="hljs-keyword">break</span><br>      &#125;<br>      <span class="hljs-built_in">println</span>(read)<br>      <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bufer[:]))<br>   &#125;<br><br>   <span class="hljs-comment">//从某个地方开始读取</span><br>   bufer := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">5</span>)<br>   <span class="hljs-comment">//从第二个字节开始读取5个字节</span><br>   n, _ := file.ReadAt(bufer, <span class="hljs-number">2</span>)<br>   <span class="hljs-built_in">println</span>(n)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bufer))<br><br>   <span class="hljs-comment">//定位</span><br>   <span class="hljs-comment">//相对于文件头偏移2个单位</span><br>   file.Seek(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>   n, _ = file.Read(bufer)<br>   <span class="hljs-built_in">println</span>(n)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bufer))<br><br>   file.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   readFile()<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="File写操作"><a href="#File写操作" class="headerlink" title="File写操作"></a>File写操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//打开文件，O_APPEND 追加到文件末尾 O_TRUNC:清空</span><br>   file, _ := os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR|os.O_APPEND, <span class="hljs-number">0777</span>)<br>   file.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello golang!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeString</span><span class="hljs-params">()</span></span> &#123;<br>   file, _ := os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR|os.O_TRUNC, <span class="hljs-number">0777</span>)<br>   <span class="hljs-comment">//直接写字符串</span><br>   file.WriteString(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeAt</span><span class="hljs-params">()</span></span> &#123;<br>   file, _ := os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR, <span class="hljs-number">0777</span>)<br>   <span class="hljs-comment">//在指定位置开始写入</span><br>   file.WriteAt([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hha&quot;</span>), <span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   write()<br>   writeString()<br>   writeAt()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java生成Pdf文档</title>
    <url>/2021/04/28/Java%E7%94%9F%E6%88%90Pdf%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="Java生成Pdf文档"><a href="#Java生成Pdf文档" class="headerlink" title="Java生成Pdf文档"></a>Java生成Pdf文档</h3><h4 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h4><p>​        在做填报系统的时候，有一个需求是将用户填报的信息生成一个pdf文档，本来是打算前端来做这个pdf的，但是后面前端说他生成的文档显示不全，于是我就被迫接受这个任务。</p>
<p>​        然后在百度了一两个小时后，就开始着手画pdf文档了，注意是画，不是生成，就和html一样需要自己一个一个的堆盒子。而且刚开始画的时候，出现了很多问题，比如说表格不出现，不能控制列宽……第一天搞了3个多小时，就写出了个标题，好在第二天有了第一天的教训，摸清楚了使用方法，花了一个下午给画好了。</p>
<a id="more"></a>

<p>​            写下这篇博客，来记录下，顺便做个工具类，万一以后还需要使用。</p>
<h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itext-asian<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>需要导入以上两个依赖。</p>
<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ul>
<li>创建document对象 </li>
<li>获取PdfWriter实例</li>
<li>打开document文档</li>
<li>向文档写入内容</li>
<li>关闭文档</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pdf.pty;<br><br><span class="hljs-keyword">import</span> com.itextpdf.text.Document;<br><span class="hljs-keyword">import</span> com.itextpdf.text.DocumentException;<br><span class="hljs-keyword">import</span> com.itextpdf.text.Paragraph;<br><span class="hljs-keyword">import</span> com.itextpdf.text.pdf.PdfWriter;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pdf</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, DocumentException </span>&#123;<br>        <span class="hljs-comment">//创建document对象</span><br>        Document document = <span class="hljs-keyword">new</span> Document();<br><br>        <span class="hljs-comment">//获取Pdfwriter实例，将生成的pdf写入 D:\hello.pdf</span><br>        PdfWriter.getInstance(document,<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:\\hello.pdf&quot;</span>));<br><br>        <span class="hljs-comment">//打开文档</span><br>        document.open();<br><br>        <span class="hljs-comment">//向文档添加内容</span><br>        document.add(<span class="hljs-keyword">new</span> Paragraph(<span class="hljs-string">&quot;helloworld&quot;</span>));<br>        <br>        <span class="hljs-comment">//关闭文档</span><br>        document.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述是一个简单的生成pdf的程序，向<code>D:\hello.pdf</code>写入了helloworld内容。</p>
<p>但是一般我们生成的pdf并不会这么简单，还需要表格等信息。</p>
<h4 id="itext常用API"><a href="#itext常用API" class="headerlink" title="itext常用API"></a>itext常用API</h4><h5 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//xxx为段落的实际内容，fontchina18是字体，这个是之前代码已经设置好的，不能通用，要自己设置</span><br>Paragraph paragraph = <span class="hljs-keyword">new</span> Paragraph(<span class="hljs-string">&quot;xxxx&quot;</span>,fontChina18);<br><span class="hljs-comment">//设置文字对齐方式 0靠左对齐，1居中对齐，2靠右对齐</span><br>paragraph.setAlignment(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//设置左边缩进几个字符</span><br>paragraph.setIndentationLeft(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//设置右边缩进几个字符</span><br>paragraph.setIndentationRight(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//设置首行缩进几个字符</span><br>paragraph.setFirstLineIndent(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//行间距</span><br>paragraph.setLeading(<span class="hljs-number">20f</span>);<br><span class="hljs-comment">//设置段落上空白</span><br>paragraph.setSpacingBefore(<span class="hljs-number">5f</span>); <br><span class="hljs-comment">//设置段落下空白</span><br>paragraph.setSpacingAfter(<span class="hljs-number">10f</span>); <br><br><span class="hljs-comment">//将段落添加到文档</span><br>document.addd(paragraph);<br></code></pre></td></tr></table></figure>

<p><strong>标题一般直接居中显示，同时可以设置一个空的段落，从而实现空一行的操作  Paragraph paragraph = new Paragraph(“ “);  ,注意引号之间有个空格，没有空格好像并不能表示一个空的段落,设置完段落后，别忘了加入到文档</strong></p>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建指定列的表格，下面代码为创建列数为3的表格</span><br>PdfPTable table = <span class="hljs-keyword">new</span> PdfPTable(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//创建指定列宽的表格，需要传入一个数组，数组的个数就是列的个数，数组的数字就是列宽</span><br><span class="hljs-comment">//自定义列宽的时候要设置LockedWidth为true，将宽度锁定</span><br>PdfPTable table = <span class="hljs-keyword">new</span> PdfPTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[] &#123;<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">70</span>,<span class="hljs-number">190</span>,<span class="hljs-number">70</span>,<span class="hljs-number">190</span>,<span class="hljs-number">120</span>&#125;);<br>table.setLockedWidth(<span class="hljs-keyword">true</span>);<br><br><span class="hljs-comment">//设置表格的总宽度</span><br>table.setTotalWidth(maxWidth);<br><br><span class="hljs-comment">//设置表格的边框宽度？</span><br>table.getDefaultCell().setBorder(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//设置表格占页面的多少，如图设置为100%</span><br>table.setWidthPercentage(<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">//将表格添加到文档中</span><br>document.add(table);<br></code></pre></td></tr></table></figure>



<h5 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个单元格</span><br>PdfPCell cell = <span class="hljs-keyword">new</span> PdfPCell();<br><br><span class="hljs-comment">//设置单元格跨几列</span><br>cell.setColspan(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">//设置单元格跨几行</span><br>cell.setRowspan(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">//设置单元格边框宽度</span><br>cell.setBorderWidth(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//设置水平居中</span><br>cell.setHorizontalAlignment(Element.ALIGN_CENTER);<br><br><span class="hljs-comment">//设置垂直居中</span><br>cell.setVerticalAlignment(Element.ALIGN_MIDDLE);<br><br><span class="hljs-comment">//设置单元格内容</span><br>cell.setPhrase(<span class="hljs-keyword">new</span> Paragraph(<span class="hljs-string">&quot;xxx&quot;</span>,字体));<br><br><span class="hljs-comment">//将单元格加入到表格中</span><br>table.addcell(cell)<br></code></pre></td></tr></table></figure>

<p><strong>如果你创建了一个有7列的表格，但是你只添加了6个单元格，那么表格的内容是不会在页面中显示出来，只有当添加的单元格的数量大于列数，才会显示出来表格内容，没满一行的表格不显示</strong></p>
<h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解决中文不显示问题</span><br>BaseFont bfChinese = BaseFont.createFont(<span class="hljs-string">&quot;STSong-Light&quot;</span>,<span class="hljs-string">&quot;UniGB-UCS2-H&quot;</span>, BaseFont.NOT_EMBEDDED);<br>Font fontChina18 = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">18</span>);<br>Font fontChina12 = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">12</span>);<br><br><br><br><br><span class="hljs-comment">//这里也是设置字体，定义全局都可以使用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font titlefont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font headfont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font keyfont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font textfont;<br>    <span class="hljs-comment">// 最大宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxWidth = <span class="hljs-number">520</span>;<br>    <span class="hljs-comment">// 静态代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不同字体（这里定义为同一种字体：包含不同字号、不同style）</span><br>            BaseFont bfChinese = BaseFont.createFont(<span class="hljs-string">&quot;STSong-Light&quot;</span>, <span class="hljs-string">&quot;UniGB-UCS2-H&quot;</span>, BaseFont.NOT_EMBEDDED);<br>            titlefont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">16</span>, Font.BOLD);<br>            headfont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">14</span>, Font.BOLD);<br>            keyfont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">10</span>, Font.BOLD);<br>            textfont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">10</span>, Font.NORMAL);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>





<h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><p>附上这一次画pdf的成果，以后也可以直接拿这个做一些调整即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pdf.pty;<br><br><br><span class="hljs-keyword">import</span> com.itextpdf.text.*;<br><span class="hljs-keyword">import</span> com.itextpdf.text.pdf.BaseFont;<br><span class="hljs-keyword">import</span> com.itextpdf.text.pdf.PdfPCell;<br><span class="hljs-keyword">import</span> com.itextpdf.text.pdf.PdfPTable;<br><span class="hljs-keyword">import</span> com.itextpdf.text.pdf.PdfWriter;<br><br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">chapter</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font titlefont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font headfont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font keyfont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Font textfont;<br>    <span class="hljs-comment">// 最大宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxWidth = <span class="hljs-number">520</span>;<br>    <span class="hljs-comment">// 静态代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不同字体（这里定义为同一种字体：包含不同字号、不同style）</span><br>            BaseFont bfChinese = BaseFont.createFont(<span class="hljs-string">&quot;STSong-Light&quot;</span>, <span class="hljs-string">&quot;UniGB-UCS2-H&quot;</span>, BaseFont.NOT_EMBEDDED);<br>            titlefont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">16</span>, Font.BOLD);<br>            headfont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">14</span>, Font.BOLD);<br>            keyfont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">10</span>, Font.BOLD);<br>            textfont = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">10</span>, Font.NORMAL);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, DocumentException </span>&#123;<br>        <span class="hljs-comment">//创建document对象</span><br>        Document document = <span class="hljs-keyword">new</span> Document();<br>        <span class="hljs-comment">//获取PdfWriter实例</span><br>        PdfWriter.getInstance(document,<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:\\hello1.pdf&quot;</span>));<br>        <span class="hljs-comment">//打开文档</span><br>        document.open();<br><br>        <span class="hljs-comment">//解决中文不显示问题</span><br>        BaseFont bfChinese = BaseFont.createFont(<span class="hljs-string">&quot;STSong-Light&quot;</span>,<span class="hljs-string">&quot;UniGB-UCS2-H&quot;</span>, BaseFont.NOT_EMBEDDED);<br>        Font fontChina18 = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">18</span>);<br>        Font fontChina12 = <span class="hljs-keyword">new</span> Font(bfChinese, <span class="hljs-number">12</span>);<br><br><br><br>        <span class="hljs-comment">//标题</span><br>        Paragraph paragraph = <span class="hljs-keyword">new</span> Paragraph(<span class="hljs-string">&quot;湖南工业大学2021-2023年岗位定级申请表&quot;</span>,fontChina18);<br>        paragraph.setAlignment(<span class="hljs-number">1</span>);<span class="hljs-comment">//居中</span><br>        document.add(paragraph);<br><br>        Paragraph blank = <span class="hljs-keyword">new</span> Paragraph(<span class="hljs-string">&quot; &quot;</span>);<br>        document.add(blank);<br><br><br>        chapter chapter = <span class="hljs-keyword">new</span> chapter();<br><br>        <span class="hljs-comment">//表格</span><br>        PdfPTable table = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[] &#123;<span class="hljs-number">30</span>,<span class="hljs-number">120</span>,<span class="hljs-number">100</span>,<span class="hljs-number">120</span>,<span class="hljs-number">100</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>&#125;);<br><br>        <span class="hljs-comment">// 个人信息</span><br>        table.addCell(chapter.createCell(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;个人信息&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;姓名&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;张三&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;性别&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;男&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;归口单位&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;计算机学院&quot;</span>));<br><br><br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;现任专业技术职务&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;教授&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;取得时间&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot; &quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;专业技术证书编号&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;&quot;</span>));<br><br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;申请岗位类别&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;专业技术岗位&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;申请岗位等级&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;教授四级&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;教师资格证书编号&quot;</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;&quot;</span>));<br><br><br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;工作业绩取得的年度&quot;</span>,<span class="hljs-number">2</span>));<br>        table.addCell(chapter.createCell(<span class="hljs-string">&quot;2017年   2018年   2019年   2020年&quot;</span>,<span class="hljs-number">4</span>));<br><br>        document.add(table);<br>        document.add(blank);<br><br>        <span class="hljs-comment">//必选条件</span><br>        PdfPTable table1 = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[] &#123;<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">70</span>,<span class="hljs-number">190</span>,<span class="hljs-number">70</span>,<span class="hljs-number">190</span>,<span class="hljs-number">120</span>&#125;);<br><br>        table1.addCell(chapter.createCell(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;必选条件&quot;</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;发表中心核心期刊论文3篇&quot;</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;序号&quot;</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;发表时间&quot;</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;论文标题（书名）&quot;</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;排名&quot;</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;刊物名称&quot;</span>));<br>        table1.addCell(chapter.createCell(<span class="hljs-string">&quot;审核人签字盖章&quot;</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            String s = Integer.toString(i+<span class="hljs-number">1</span>);<br>            table1.addCell(chapter.createCell(s));<br>            table1.addCell(chapter.createCell(<span class="hljs-string">&quot;2017&quot;</span>));<br>            table1.addCell(chapter.createCell(<span class="hljs-string">&quot; &quot;</span>));<br>            table1.addCell(chapter.createCell(<span class="hljs-string">&quot; &quot;</span>));<br>            table1.addCell(chapter.createCell(<span class="hljs-string">&quot; &quot;</span>));<br>            table1.addCell(chapter.createCell(<span class="hljs-string">&quot; &quot;</span>));<br><br>        &#125;<br>        document.add(table1);<br>        document.add(blank);<br><br>        <span class="hljs-comment">//任选条件</span><br>        PdfPTable table2 = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[] &#123;<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">70</span>,<span class="hljs-number">190</span>,<span class="hljs-number">70</span>,<span class="hljs-number">190</span>,<span class="hljs-number">120</span>&#125;);<br><br><br>        <span class="hljs-comment">//TODO 这里跨几行应该根据前端传过来的数据动态变化，先写死</span><br>        table2.addCell(chapter.createCell(<span class="hljs-number">3</span>*<span class="hljs-number">4</span>,<span class="hljs-string">&quot;任选条件&quot;</span>));<br>        <span class="hljs-comment">//TODO 这里的名字应该也是动态的，先写死</span><br>        chapter.createTable(table2,<span class="hljs-string">&quot;D01 湖南省普通高校学科带头人培养对象或入选省“思想政治教育中青年杰出人才支持计划”、或省文艺人才扶持“三百工程&quot;</span>,<span class="hljs-string">&quot;荣誉称号&quot;</span>);<br>        chapter.createTable(table2,<span class="hljs-string">&quot;D05 省部级教学成果一等级前5名、或二等奖前4名、或三等奖前2名&quot;</span>,<span class="hljs-string">&quot;奖项名称&quot;</span>);<br>        chapter.createTable(table2,<span class="hljs-string">&quot;D10 国家级教学工程项目的前6名&quot;</span>,<span class="hljs-string">&quot;项目(专利名称)&quot;</span>);<br>        chapter.createTable(table2,<span class="hljs-string">&quot;D16 一等刊期、或CSSCI/CSCD期刊论文1篇，或国外专业学术期刊论文1篇，或三大检索收录论文1篇，或被《新华文橘》/《中国社会科学文摘》/《人大复印资料》全文收录论文1篇&quot;</span>,<span class="hljs-string">&quot;论文标题（书名）&quot;</span>);<br>        document.add(table2);<br><br>        document.add(blank);<br>        <span class="hljs-comment">//教学情况</span><br>        PdfPTable table3 = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[] &#123;<span class="hljs-number">30</span>,<span class="hljs-number">80</span>,<span class="hljs-number">120</span>,<span class="hljs-number">160</span>,<span class="hljs-number">160</span>,<span class="hljs-number">160</span>&#125;);<br>        table3.addCell(chapter.createCell(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;教学情况&quot;</span>));<br>        table3.addCell(chapter.createCell(<span class="hljs-string">&quot;序号&quot;</span>));<br>        table3.addCell(chapter.createCell(<span class="hljs-string">&quot;时间&quot;</span>));<br>        table3.addCell(chapter.createCell(<span class="hljs-string">&quot;课程名称&quot;</span>));<br>        table3.addCell(chapter.createCell(<span class="hljs-string">&quot;工作完成量(积分)&quot;</span>));<br>        table3.addCell(chapter.createCell(<span class="hljs-string">&quot;审核人签字盖章&quot;</span>));<br><br>        <span class="hljs-comment">//TODO 这里循环次数和年份也应该动态变化</span><br>        <span class="hljs-keyword">int</span> year = <span class="hljs-number">2017</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            String s = Integer.toString(i + <span class="hljs-number">1</span>);<br>            chapter.createTable(table3,s,year++);<br>        &#125;<br>        document.add(table3);<br>        document.add(blank);<br><br>        <span class="hljs-comment">//个人承诺</span><br>        PdfPTable table4 = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;<span class="hljs-number">30</span>, <span class="hljs-number">680</span>&#125;);<br>        table4.addCell(chapter.createCell(<span class="hljs-string">&quot;个人承诺&quot;</span>));<br>        table4.addCell(chapter.createCell(<span class="hljs-string">&quot;\n\n\n\n\n本人保证本表所填内容情况属实，否则愿意承担一切后果和责任。\n\n&quot;</span>+<br>                                               <span class="hljs-string">&quot;                                                        本人签字：&quot;</span>+<span class="hljs-string">&quot;\n\n&quot;</span>+<br>                                               <span class="hljs-string">&quot;                                                        年      月     日\n\n\n\n\n&quot;</span>,<span class="hljs-keyword">true</span>));<br>        document.add(table4);<br>        document.add(blank);<br><br>        <span class="hljs-comment">//所在单位推荐意见</span><br>        PdfPTable table5 = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;<span class="hljs-number">30</span>, <span class="hljs-number">680</span>&#125;);<br>        table5.addCell(chapter.createCell(<span class="hljs-string">&quot;所在单位推荐意见&quot;</span>));<br>        table5.addCell(chapter.createCell(<span class="hljs-string">&quot;\n\n\n\n\n经本单位评议，该同志在本次考核定级中， 符合岗位的聘任条件，同意推荐上报\n\n&quot;</span>+<br>                                            <span class="hljs-string">&quot;                                                        单位负责人签字（单位公章）\n\n&quot;</span>+<br>                                            <span class="hljs-string">&quot;                                                        年      月       日\n\n\n\n\n&quot;</span>,<span class="hljs-keyword">true</span>));<br>        document.add(table5);<br>        document.add(blank);<br><br>        PdfPTable table6 = chapter.creteTable(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;<span class="hljs-number">30</span>, <span class="hljs-number">680</span>&#125;);<br>        table6.addCell(chapter.createCell(<span class="hljs-string">&quot;学校岗位定级工作领导小组意见&quot;</span>));<br>        table6.addCell(chapter.createCell(<span class="hljs-string">&quot;\n\n\n\n\n经审核，同意核准该同志聘用到 岗位 级，聘期为2020年1月1日至2023年12月31日。\n\n&quot;</span>+<br>                <span class="hljs-string">&quot;                                                        签字（公章）\n\n&quot;</span>+<br>                <span class="hljs-string">&quot;                                                        年      月       日\n\n\n\n\n\n\n&quot;</span>,<span class="hljs-keyword">true</span>));<br>        document.add(table6);<br>        <span class="hljs-comment">//关闭</span><br>        document.close();<br>    &#125;<br><br><br>    <span class="hljs-comment">//简单的单元格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PdfPCell <span class="hljs-title">createCell</span><span class="hljs-params">(String value)</span></span>&#123;<br>        PdfPCell cell = <span class="hljs-keyword">new</span> PdfPCell();<br>        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);<br>        cell.setBorderWidth(<span class="hljs-number">1</span>);<br>        cell.setHorizontalAlignment(Element.ALIGN_CENTER);<br>        cell.setPhrase(<span class="hljs-keyword">new</span> Paragraph(value,textfont));<br>        cell.setFixedHeight(<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">return</span>  cell;<br>    &#125;<br><br><br>    <span class="hljs-comment">//简单的单元格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PdfPCell <span class="hljs-title">createCell</span><span class="hljs-params">(String value,<span class="hljs-keyword">boolean</span> a)</span></span>&#123;<br>        PdfPCell cell = <span class="hljs-keyword">new</span> PdfPCell();<br>        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);<br>        cell.setBorderWidth(<span class="hljs-number">1</span>);<br>        cell.setHorizontalAlignment(Element.ALIGN_CENTER);<br>        cell.setPhrase(<span class="hljs-keyword">new</span> Paragraph(value,textfont));<br>        <span class="hljs-keyword">return</span>  cell;<br>    &#125;<br><br>    <span class="hljs-comment">//跨列的单元格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PdfPCell <span class="hljs-title">createCell</span><span class="hljs-params">(String value,<span class="hljs-keyword">int</span> col)</span></span>&#123;<br>        PdfPCell cell = <span class="hljs-keyword">new</span> PdfPCell();<br>        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);<br>        cell.setColspan(col);<br>        cell.setBorderWidth(<span class="hljs-number">1</span>);<br>        cell.setHorizontalAlignment(Element.ALIGN_CENTER);<br>        cell.setPhrase(<span class="hljs-keyword">new</span> Paragraph(value,textfont));<br>        cell.setFixedHeight(<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">return</span>  cell;<br>    &#125;<br><br>    <span class="hljs-comment">//跨行的单元格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PdfPCell <span class="hljs-title">createCell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,String value)</span></span>&#123;<br>        PdfPCell cell = <span class="hljs-keyword">new</span> PdfPCell();<br>        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);<br>        cell.setRowspan(row);<br>        cell.setBorderWidth(<span class="hljs-number">1</span>);<br>        cell.setHorizontalAlignment(Element.ALIGN_CENTER);<br>        cell.setPhrase(<span class="hljs-keyword">new</span> Paragraph(value,textfont));<br>        cell.setFixedHeight(<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">return</span>  cell;<br>    &#125;<br><br>    <span class="hljs-comment">//跨列的 自定义对齐方式单元格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PdfPCell <span class="hljs-title">createCell</span><span class="hljs-params">(String value,<span class="hljs-keyword">int</span> col,<span class="hljs-keyword">int</span> alin)</span></span>&#123;<br>        PdfPCell cell = <span class="hljs-keyword">new</span> PdfPCell();<br>        cell.setVerticalAlignment(Element.ALIGN_MIDDLE);<br>        cell.setColspan(col);<br>        cell.setBorderWidth(<span class="hljs-number">1</span>);<br>        cell.setHorizontalAlignment(alin);<br>        cell.setPhrase(<span class="hljs-keyword">new</span> Paragraph(value,textfont));<br>        cell.setFixedHeight(<span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">return</span>  cell;<br>    &#125;<br><br>    <span class="hljs-comment">//创建表格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PdfPTable <span class="hljs-title">creteTable</span><span class="hljs-params">(<span class="hljs-keyword">float</span>[] cols)</span></span>&#123;<br>        PdfPTable table = <span class="hljs-keyword">new</span> PdfPTable(cols);<br>        table.setTotalWidth(maxWidth);<br>        table.setLockedWidth(<span class="hljs-keyword">true</span>);<br>        table.getDefaultCell().setBorder(<span class="hljs-number">1</span>);<br>        table.setWidthPercentage(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> table;<br>    &#125;<br><br><br>    <span class="hljs-comment">//创建任选条件时的表格</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTable</span><span class="hljs-params">(PdfPTable table,String title,String name)</span></span>&#123;<br>        table.addCell(createCell(title,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;序号&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;发表时间&quot;</span>));<br>        table.addCell(createCell(name));<br>        table.addCell(createCell(<span class="hljs-string">&quot;排名&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;授予组织&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;审核人签字盖章&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;1&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;2017&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot;&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot; &quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot; &quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//教学情况</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTable</span><span class="hljs-params">(PdfPTable table,String t,<span class="hljs-keyword">int</span> year)</span></span>&#123;<br>        table.addCell(createCell(t));<br>        table.addCell(createCell(Integer.toString(year)));<br>        table.addCell(createCell(<span class="hljs-string">&quot;&quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot; &quot;</span>));<br>        table.addCell(createCell(<span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2020/10/14/Springboot/</url>
    <content><![CDATA[<h2 id="第一个SpringBoot程序"><a href="#第一个SpringBoot程序" class="headerlink" title="第一个SpringBoot程序"></a>第一个SpringBoot程序</h2><p>官方提供了一个快速生成的网站，idea集成了这个网站。</p>
<a id="more"></a>

<p><img src="images/blog/image-20200927194923490.png" alt="image-20200927194923490"></p>
<h3 id="Hello-SpringBoot程序"><a href="#Hello-SpringBoot程序" class="headerlink" title="Hello,SpringBoot程序"></a>Hello,SpringBoot程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.helloworld;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">//程序的主入口</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(HelloworldApplication.class, args);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.helloworld.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-comment">//接口：http://localhost:8080/hello</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello，SpringBoot!&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--web依赖：tomcat,dispatcherServlet,xml--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--spring-boot-starter 所有的springboot依赖都是使用这个开头的--&gt;</span><br><br>        <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--打jar包插件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="springboot程序打包"><a href="#springboot程序打包" class="headerlink" title="springboot程序打包"></a>springboot程序打包</h3><p>首先需要引入打jar包的插件（springboot打成jar包，之前是war包）</p>
<p>在maven中的Lifecycle中点击package</p>
<p><img src="images/blog/image-20200927201339226.png" alt="image-20200927201339226"></p>
<p>当控制台出现<code>BUILD SUCCESS</code>说明打包成功</p>
<p>在该项目的target目录下会出现一个jar文件。在dos窗口中使用<code>java -jar jar包的名字.jar</code>运行这个springboot程序</p>
<p>使用dos窗口运行的时候，必须先定位到jar包所在得到目录下。</p>
<p><strong>小插曲</strong></p>
<ul>
<li><p>在dos窗口中，直接输入盘符和冒号就可以切换盘符</p>
<p><img src="images/blog/image-20200927202308137.png" alt="image-20200927202308137"></p>
</li>
<li><p>切换盘符后使用cd 目录名称可以切换工作目录</p>
<p><img src="images/blog/image-20200927202619592.png" alt="image-20200927202619592"></p>
</li>
</ul>
<h3 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h3><ol>
<li><p>修改端口号</p>
<p>在application.properties中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">server.port=8081<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改控制台的spring启动标志</p>
</li>
</ol>
<p><img src="images/blog/image-20200927203905671.png" alt="image-20200927203905671"></p>
<ul>
<li>百度在线搜索springbanner : <a href="https://www.bootschool.net/ascii/">springbanner</a>，然后复制自己想要的。<pre><code>- 在springboot的resource下面新建一个banner.txt,粘贴复制的内容
- 重启springboot</code></pre>
</li>
</ul>
<h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><h3 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h3><ul>
<li>形如<code>spring-boot-starter-xxx</code>这样的就是启动器，启动器说白了就是springboot的启动场景。</li>
<li>比如<code>spring-boot-starte-web</code>，它就会帮我们导入web环境所有的依赖！</li>
<li>springboot会将所有的功能场景都变成一个个的启动器。</li>
<li>我们要是用什么功能，就只需要找到对应的启动器就可以了。</li>
</ul>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.helloworld;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">//程序的主入口</span><br><span class="hljs-comment">//@SpringBootApplication：标注这个类是一个Springboot的主配置类，Springboot就应该运行这个类的main方法来启动springboot应用。</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//将springboot应用启动</span><br>        SpringApplication.run(HelloworldApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br></code></pre></td></tr></table></figure>

<p><strong>@SpringBootConfiguration：</strong>SpringBoot的配置类；   </p>
<p>​                标注在某个类上，表示这是一个SpringBoot的配置类；</p>
<p>​                @<strong>Configuration：</strong>配置类上来标注这个注解；</p>
<p>​                            配置类——配置文件；配置类也是容器中的一个组件；@Component</p>
<p>@<strong>EnableAutoConfiguration：</strong>开启自动配置功能</p>
<p>​            以前我们需要配置的东西，SpringBoot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉springboot开启自动配置功能，这样自动配置才能生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br></code></pre></td></tr></table></figure>

<p>@<strong>AutoConfigurationPackage：</strong>自动配置包</p>
<p>​        @Import(AutoConfigurationPackages.Registrar.class)：</p>
<p>​        Spring的底层注解@Import，给容器中导入一个组件。</p>
<p>​        <strong>AutoConfigurationPackage的作用：将主配置类（@SpringBootApplication标注的类）的所在包及下面所有的子包里面的所有组件扫描到Spring容器</strong></p>
<p>@<strong>Import</strong>({AutoConfigurationImportSelector.class})</p>
<p>​    给容器中导入组件</p>
<p>​    AutoConfigurationImportSelector:导入哪些组件的选择器；</p>
<p>​    将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。</p>
<p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration）,就是给容器中导入这个场景需要的所有组件，并配置好这些组件。</p>
<p><img src="images/blog/image-20201005220032627.png" alt="image-20201005220032627"></p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等工作。</p>
<p>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值。将这些值作为自动配置类导入到容器中，自动配置类就生效了，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们配置好了。</p>
<p>J2EE的整体整合解决方案和自动配置都在<code>spring-boot-autoconfigure-2.3.3.RELEASE</code>  META-INF/spring.factories</p>
<p>结论：springboot所有自动配置都是在启动的时候扫描并加载：<code>spring.factories</code>所有的自动配置类都在这里面，但是不一定所有的配置都会生效，要判断条件是否成立。只要导入了相应的star，就会有对应的启动器，有了启动器，我们的自动装配就会生效，然后就配置成功。</p>
<h2 id="yaml语法讲解"><a href="#yaml语法讲解" class="headerlink" title="yaml语法讲解"></a>yaml语法讲解</h2><p>Springboot使用一个全局的配置文件，配置文件名称是固定的：application.properties或者application.yml</p>
<ul>
<li>application.properties<ul>
<li>语法结构：key=value</li>
</ul>
</li>
<li>application.yml<ul>
<li>语法结构：key:（空格）value</li>
</ul>
</li>
</ul>
<p><strong>配置文件的作用</strong>：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了，我们可以通过写配置文件来修改默认配置。</p>
<h3 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h3><p><strong>对空格的要求十分要求，不能乱写空格！！！！</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#普通的key-value</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">pty</span><br><br><br><br><span class="hljs-comment">#对象</span><br><span class="hljs-attr">student:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pty</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">12</span><br>  <span class="hljs-attr">sex:</span> <span class="hljs-string">M</span><br><br><span class="hljs-comment">#对象的行内写法</span><br><span class="hljs-attr">student:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">pty</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">12</span>,<span class="hljs-attr">sex:</span> <span class="hljs-string">M</span>&#125;<br><br><br><span class="hljs-comment">#数组</span><br><span class="hljs-attr">pets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span><br>    <br><span class="hljs-comment">#数组的行内写法</span><br><span class="hljs-attr">pets:</span> [<span class="hljs-string">cat</span>,<span class="hljs-string">dog</span>,<span class="hljs-string">pig</span>]<br></code></pre></td></tr></table></figure>



<h3 id="yaml给实体类赋值"><a href="#yaml给实体类赋值" class="headerlink" title="yaml给实体类赋值"></a>yaml给实体类赋值</h3><p>spring中赋值的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将这个类注册到ioc容器里面，相当于写了个&lt;bean class=&quot;&quot; id=&quot;&quot;/&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;旺财&quot;)</span>   <span class="hljs-comment">//使用@Value注解给参数注入值，@Value可以写在set方法上，</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;14&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用yaml赋值</p>
<ul>
<li>在application.yml中写上属性对应的值</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dog:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">胜利</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">4</span><br>  <span class="hljs-comment">#注意语法，冒号后面有空格</span><br></code></pre></td></tr></table></figure>

<ul>
<li>在实体类上写上<code>@ConfigurationProperties（prefix=&quot;&quot;）</code>注解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册到ioc容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-comment">//prefix中写上该实体类属性在yml文件中的对象名，并且prefix中的参数不能写大写，如不能写Dog</span><br><span class="hljs-comment">//但是在application.yml中可以可以写大写：Dog</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;dog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中，告诉SpringBoot将本类中的所有属性和配置文件中的相关配置进行绑定，参数<code>prefix=&quot;dog&quot;</code>：将配置文件中的dog下面的属性与实体类的属性一一对应。</p>
<p>@Value:还可以使用@Value进行赋值。</p>
<ul>
<li>语法：  ${key}  #{SpEL},从环境变量、配置文件中获取值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-meta">@Value(&quot;#&#123;11*2&#125;&quot;)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span>    <span class="hljs-comment">#这里可以写大写，但是在prefix=&quot;&quot;里面不能写大写</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pty</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">12</span><br>  <span class="hljs-attr">dog:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">胜利</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">4</span><br>  <span class="hljs-attr">list:</span> [<span class="hljs-string">lq</span>,<span class="hljs-string">ppq</span>,<span class="hljs-string">zq</span>]<br>  <span class="hljs-attr">map:</span><br>    <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span><br></code></pre></td></tr></table></figure>



<p>@Value和@ConfigurationProperties为属性注值对比</p>
<table>
<thead>
<tr>
<th></th>
<th>@Value</th>
<th>@ConfigurationProperties</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>一个个指定注入</td>
<td>批量注入配置文件中的属性</td>
</tr>
<tr>
<td>松散绑定</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>SpEl</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>JSR-303数据校验</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h3 id="JSR-303"><a href="#JSR-303" class="headerlink" title="JSR-303"></a>JSR-303</h3><p>JSR-303是用来对数据的格式进行校验的。</p>
<p>虽然说前端可以数据进行校验，但最好是前后端都进行检验，这样会更加安全</p>
<ul>
<li>在springboot.2.3.0以后，需要导入坐标才能够使用。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.17.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>在实体类上面写上<code>@Validata</code>注解</li>
<li>在需要检验格式的属性上面写上对应格式的注解</li>
</ul>
<p>参考这篇博客：<a href="https://blog.csdn.net/qq_28867949/article/details/78922520">JSR-303</a></p>
<h3 id="多环境配置及配置文件位置"><a href="#多环境配置及配置文件位置" class="headerlink" title="多环境配置及配置文件位置"></a>多环境配置及配置文件位置</h3><h4 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h4><p>Application属性文件，按优先级顺序排序，位置高的将覆盖位置低的</p>
<ol>
<li>当前项目目录下的一个/config子目录</li>
<li>当前项目目录</li>
<li>项目的resources即一个classpath下的/config包</li>
<li>项目的resources即classpath根路径（root）</li>
</ol>
<p><img src="images/blog/image-20200928174407131.png" alt="image-20200928174407131"></p>
<p><strong>如果在不同的目录中存在多个配置文件，它的读取顺序是：</strong></p>
<ol>
<li>config/application.properties（项目根目录中config目录下）</li>
<li>config/application.yml</li>
<li>application.properties（项目根目录下）application.yml</li>
<li>resources/config/application.properties（项目resources目录中config目录下）</li>
<li>resources/config/application.yml</li>
<li>resources/application.properties（项目的resources目录下）</li>
<li>resources/application.yml</li>
</ol>
<p>即：在同一目录下，先加载.properties文件，再加载.yml文件。</p>
<h4 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h4><p>yaml文件中通过—（3条杠）来区分多个环境配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#默认使用最上面的这个配置文件</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>    <span class="hljs-comment">#使用名字叫dev的配置文件</span><br><br><span class="hljs-string">---</span>     <span class="hljs-comment">#使用三条杠隔开，表示是另一个配置文件。这里配置了3个配置文件</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span>  <span class="hljs-comment">#给这个配置文件取名字</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure>



<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ul>
<li>配置yml和配置properties都可以获取到指，强烈推荐yml</li>
<li>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用@value</li>
<li>如果我们专门编写了一个JavaBean来和配置文件进行映射，就直接使用@configurationProperties，不要犹豫。</li>
</ul>
<h2 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h2><h3 id="加载静态资源"><a href="#加载静态资源" class="headerlink" title="加载静态资源"></a>加载静态资源</h3><ol>
<li>在Springboot中，我们可以使用以下方式处理静态资源<ul>
<li>webjars   <code>localhost:8080/webjars/</code></li>
<li>public、static、/**、resources    <code>localhost:8080/</code></li>
</ul>
</li>
<li>优先级：resources&gt;static&gt;public</li>
<li>templates目录下的文件不能够直接访问，只能通过controller来跳转。</li>
</ol>
<h2 id="SpringBoot-扩展SpringMvc"><a href="#SpringBoot-扩展SpringMvc" class="headerlink" title="SpringBoot 扩展SpringMvc"></a>SpringBoot 扩展SpringMvc</h2><p>在spring boot中 MVC这部分也有默认自动配置，也就是说我们不用做任何配置，那么也是OK的，这个配置类就是 WebMvcAutoConfiguration，但是也时候我们想设置自己的springMvc配置怎么办呢 。</p>
<p>我们也可以写个自己的配置类，实现 WebMvcConfigurer接口，重写需要的配置方法 。在spring boot 早期是继承WebMvcConfigurerAdapter ，但是高版已标上注解@Deprecated，<strong>注意：在配置类中不要标注：@EnableWebMvc，否则，spring boot的配置全部失效，只留自己扩展配置。</strong></p>
<p>Springboot在自动配置的时候，先看容器中有没有用户自己配置的，如果有，就用用户自己配置的，没有才自动配置。如果有些组件可以有多个（ViewResolver)将用户配置的和springboot默认的组合起来。    </p>
<p>自定义视图跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>   <span class="hljs-comment">//标志这个类是一个spring的配置类</span><br><span class="hljs-comment">//实现WebMvcConfigurer接口，重写里面的方法，实现功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfiig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">//当浏览器请求/hello时，跳转到test页面</span><br>        registry.addViewController(<span class="hljs-string">&quot;/hello&quot;</span>).setViewName(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>自定义视图解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 标注这个类是一个配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-comment">// 将视图解析器配置到容器中</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title">myViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyViewResolver();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义一个视图解析器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewResolver</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>通常我们在首页使用自定义视图跳转，当用户只输入主机+ip时也能够访问到我们的项目。</p>
<p>我之前是将所有的静态文件放在static目录下，经过测试发现addviewControllers无法映射到static目录下的文件，可以映射到templates目录下。</p>
<p>其次当映射成功了以后，我发现页面的CSS样式等都无法加载。查看以后发现这些文件请求的地址是<code>localhost:8080/static/css/...</code>，但是默认访问css的地址是<code>localhost:8080/css/...</code>,所以需要在页面中修改引入css样式的地址，由<code>&quot;../static/css/login.css&quot;</code>修改为<code>&quot;/css/login.css&quot;</code>。</p>
<p>经过测试发现，上述方法需要导入thymeleaf。springboot默认static用来放静态资源，templates用来放动态资源，使用试图跳转后的页面应该属于动态的，所以访问不了static目录下的页面。</p>
<p>但是我们可以自己来设置视图解析器的前后缀来实现跳转到static目录下。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#properties写法</span><br><span class="hljs-meta">spring.mvc.view.prefix</span>=<span class="hljs-string">/</span><br><span class="hljs-meta">spring.mvc.view.suffix</span>=<span class="hljs-string">.html</span><br><br><span class="hljs-comment">#yaml写法</span><br><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">mvc</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">view</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">prefix</span>: <span class="hljs-string">/</span><br>      <span class="hljs-attr">suffix</span>: <span class="hljs-string">.html</span><br></code></pre></td></tr></table></figure>

<p>由于springboot会默认在static下找静态资源，所以访问static目录下的地址是<code>localhost:8080/</code>,因此我们的前缀只要是一个<code>/</code>即可，而后缀就是.html (我一开始没设置后缀跳转不成功，找不到文件)，这种方法不需要导入thymeleaf。</p>
<h2 id="SpringBoot推荐添加组件的方式"><a href="#SpringBoot推荐添加组件的方式" class="headerlink" title="SpringBoot推荐添加组件的方式"></a>SpringBoot推荐添加组件的方式</h2><p>我们可以通过使用<code>@ImportResource(locations=&#123;&quot;classpath:xxxxz&quot;&#125;)</code>来引入自己写的spring的配置文件</p>
<p>但是springboot推荐我们使用全注解的方式：</p>
<ol>
<li>配置类========Spring的配置文件</li>
<li>使用@Bean给容器添加组件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Configuration</span>:  指明当前类是一个配置类，就是用来替代之前的Spring的配置文件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签来添加组件</span><br><span class="hljs-comment"> * 在配置类中使用<span class="hljs-doctag">@Bean</span>来添加组件</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfiig</span> </span>&#123;<br>    <span class="hljs-comment">//将方法的返回值添加到容器中，容器中的这个组件默认的id就是方法名。</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/09/17/spring/</url>
    <content><![CDATA[<h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h2><h3 id="1-1优点"><a href="#1-1优点" class="headerlink" title="1.1优点"></a>1.1优点</h3><ul>
<li>Spring是一个开源的免费的框架(容器)</li>
<li>Spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC),面向切面编程（AOP）</li>
<li>支持事务的处理，对框架的整合的支持</li>
</ul>
<a id="more"></a>

<p>**总结：Spring是一个轻量级的控制反转（IOC) 和面向切面编程（AOP）的框架 **</p>
<h3 id="1-2组成"><a href="#1-2组成" class="headerlink" title="1.2组成"></a>1.2组成</h3><p><img src="/images/blog/image-20200915210338148.png" alt="image-20200915210338148"></p>
<h3 id="1-3拓展"><a href="#1-3拓展" class="headerlink" title="1.3拓展"></a>1.3拓展</h3><ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架</li>
<li>基于springboot可以快速的开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>Spring Cloud是基于springboot实现的</li>
</ul>
</li>
</ul>
<p>学习springboot的前提是需要完全掌握Spring及SpringMVC。承上启下</p>
<h2 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2.IOC理论推导"></a>2.IOC理论推导</h2><p>原来的步骤：</p>
<ol>
<li>UserDao的接口</li>
<li>UserDaoImpl实现类</li>
<li>UserService 业务接口</li>
<li>UserServiceImpl业务实现类</li>
</ol>
<p>在我们之前的业务中，用户的需求可能会影响到我们原来的代码，我们需要根据用户的需求去修改源代码。如果程序代码量十分大，修改一次的成本代价很昂贵。</p>
<p>IOC的思想，从本质上解决了这个问题，我们不用再去管理对象的创建。系统的耦合性大大降低，可以更加专注于业务的实现。</p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p>控制反转是一种设计思想，DI(依赖注入)是实现IOC的一种方法。在没有IOC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。个人认为所谓的控制反转就是：获得对象的方式反转了。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从ioc容器取出需要的对象。</p>
<p>采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者结合在一起，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的。</p>
<p><strong>控制反转是一种通过描述(xml或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入(DI)</strong></p>
<h2 id="3-初识Spring"><a href="#3-初识Spring" class="headerlink" title="3.初识Spring"></a>3.初识Spring</h2><h3 id="3-1-配置ApplicationContext-xml"><a href="#3-1-配置ApplicationContext-xml" class="headerlink" title="3.1 配置ApplicationContext.xml"></a>3.1 配置ApplicationContext.xml</h3><p>applicationContext.xml用来配置对象信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--applicationContext.xml的约束--&gt;</span><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!--使用spring来创建对象，在spring中这些都被称为Bean</span><br><span class="hljs-comment">		类型 变量名 = new 类型();</span><br><span class="hljs-comment">		Hello hello = new Hello();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		id = 变量名</span><br><span class="hljs-comment">		class = new 的对象</span><br><span class="hljs-comment">		property 相当于对象中的属性设置一个值</span><br><span class="hljs-comment">	--&gt;</span><br>    <br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--ref引用spring中创建的对象</span><br><span class="hljs-comment">			value是具体的值</span><br><span class="hljs-comment">			给name为xxx的属性赋值</span><br><span class="hljs-comment">			--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>  <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">publlic <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    <br>    <span class="hljs-comment">//获取ApplicationContext,拿到spring容器。</span><br>     ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationcontext.xml&quot;</span>);<br>    <span class="hljs-comment">//用来创建具体的对象，xxx为配置的bean的id或者别名。</span><br>     Obeject object= <span class="hljs-function">context <span class="hljs-title">getBean</span><span class="hljs-params">(xxx)</span></span>;  <span class="hljs-comment">//可以进行强转</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-IOC创建对象的方式"><a href="#4-IOC创建对象的方式" class="headerlink" title="4.IOC创建对象的方式"></a>4.IOC创建对象的方式</h2><ol>
<li><p>使用无参构造创建对象，默认！</p>
</li>
<li><p>假如我们要用有参构造创建对象（需要给bean中写一个有参构造）</p>
<ol>
<li>下标赋值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>= <span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;狂神说java1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;狂神说java2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--给User类的第一个属性赋值为狂神说java1，给第二个属性赋值为狂神说java2--&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>类型</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种方式：通过类型创建，不建议使用，且type必须填类型的全限定类名，不能像mybatis写别名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>参数名</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第三种：直接通过参数名构造--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ol>
<p>总结：在spring加载配置文件的时候，配置文件中所配置的bean对象就已经被实例化了（即调用了相关的构造方法，bean被加载进了容器内），<code>getBean</code>再从容器中找到具体的bean对象。</p>
<h2 id="5-Spring配置"><a href="#5-Spring配置" class="headerlink" title="5.Spring配置"></a>5.Spring配置</h2><h3 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1 别名"></a>5.1 别名</h3><p><code>&lt;alias name=&quot;&quot; alias=&quot;&quot;&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--设置别名，给bean中的id设置别名，设置别名后，使用getBean时，也可以通过别名来获取对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user1&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="5-2bean的配置"><a href="#5-2bean的配置" class="headerlink" title="5.2bean的配置"></a>5.2bean的配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">       id：bean的唯一标识符，也就是相当于我们以前学的变量名，用于在getBean是找到对应的对象</span><br><span class="hljs-comment">       class：需要创建的bean对象的全限定类名：报名+类型</span><br><span class="hljs-comment">       name：也就是别名，而且name可以同时取多个别名,设置的别名都可以在getBean获取到对象       </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user2,u1,u3&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="5-3-import"><a href="#5-3-import" class="headerlink" title="5.3 import"></a>5.3 import</h3><p>这个import,一般用于团队开发，可以将多个配置文件合并为一个。</p>
<p>假设，现在项目中有多个人开发，这三个人负责不同的类的开发，不同的类需要注册不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li>张三</li>
<li>李四</li>
<li>王五</li>
<li>applicationContext.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans1.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans2.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans3.xml&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>使用的时候，直接使用总的配置就可以了。</p>
<h2 id="6-依赖注入"><a href="#6-依赖注入" class="headerlink" title="6.依赖注入"></a>6.依赖注入</h2><h3 id="6-1-构造注入"><a href="#6-1-构造注入" class="headerlink" title="6.1 构造注入"></a>6.1 构造注入</h3><p>就是前面的有参构造</p>
<h3 id="6-2-Set注入【重点】"><a href="#6-2-Set注入【重点】" class="headerlink" title="6.2 Set注入【重点】"></a>6.2 Set注入【重点】</h3><ul>
<li>依赖注入：Set注入<ul>
<li>依赖：Bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Adress&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;adress&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;湘西州&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Student&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--第一种，普通值注入，value--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br>     <span class="hljs-comment">&lt;!--第二种，Bean注入，ref--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;adress&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>     <span class="hljs-comment">&lt;!--第三种，数组注入，array--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>红楼梦<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>西游记<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>三国演义<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>水浒传<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--第四种，list注入，list--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbys&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>网球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--第五种，map注入，map--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;122333&quot;</span>/&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1111111&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--第六种，set注入，set--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;game&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>LOL<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>COC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>DOD<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <br>     <span class="hljs-comment">&lt;!--设置为null--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <br>     <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     properties</span><br><span class="hljs-comment">     键值对 key:value  value写在两个尖括号之间</span><br><span class="hljs-comment">     --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>111111<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;性别&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="6-3拓展注入"><a href="#6-3拓展注入" class="headerlink" title="6. 3拓展注入"></a>6. 3拓展注入</h3><p>我们可以使用p命名空间和c命名空间进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--p命名空间注入，可以直接注入属性的值，相当于property--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">p:username</span>=<span class="hljs-string">&quot;pty&quot;</span> <span class="hljs-attr">p:password</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br> <span class="hljs-comment">&lt;!--c命名空间注入，通过构造器，相当于construct-args，前提是bean必须要有有参构造--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">c:username</span>=<span class="hljs-string">&quot;pty&quot;</span> <span class="hljs-attr">c:password</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>注意点</strong>：P命名和C命名不能直接使用，需要导入xml约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;<br></code></pre></td></tr></table></figure>



<h3 id="6-4-bean的作用域"><a href="#6-4-bean的作用域" class="headerlink" title="6.4 bean的作用域"></a>6.4 bean的作用域</h3><ol>
<li>单例模式（Spring默认机制）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>设置 为singleton后，在getBean时生成一个对象，接下来如果再次使用getBean生成同一个id的对象，则两个对象是一样的，即一个bean只生成一个对象。</p>
<ol start="2">
<li>原型模式：每次从容器中get的时候，都会产生一个新对象！</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>其余的request、session、application这些只能在web开发中使用。</li>
</ol>
<h2 id="7-Bean的自动装配"><a href="#7-Bean的自动装配" class="headerlink" title="7.Bean的自动装配"></a>7.Bean的自动装配</h2><ul>
<li>自动装配是Spring满足bean依赖的一种方式。</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种装配方式</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配bean  【重要】</li>
</ol>
<p>这是我们之前学过的配置方式</p>
<p>cat和dog为两个对象，需要使用ref来引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Cat&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Dog&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;cat&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dog&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="7-1-ByName自动装配"><a href="#7-1-ByName自动装配" class="headerlink" title="7.1 ByName自动装配"></a>7.1 ByName自动装配</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Cat&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Dog&quot;</span>/&gt;</span><br>  <br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">ByName: 会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid！</span><br><span class="hljs-comment">不需要在自己手动的配置引用的对象。</span><br><span class="hljs-comment">但是如果beanid与自己对象set方法后面的值不同，就会报空指针异常。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="7-2-ByType"><a href="#7-2-ByType" class="headerlink" title="7.2 ByType"></a>7.2 ByType</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Cat&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Dog&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">ByType: 会自动在容器上下文中查找，和自己对象属性类型相同的bean！</span><br><span class="hljs-comment">不需要在自己手动的配置引用的对象。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pty&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>byname的时候，需要保证所有bean的id唯一，并且这个beanid需要和自动注入的属性的set方法的值相同。</li>
<li>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
</ul>
<h3 id="7-3使用注解实现自动装配"><a href="#7-3使用注解实现自动装配" class="headerlink" title="7.3使用注解实现自动装配"></a>7.3使用注解实现自动装配</h3><p>要使用注解须知：</p>
<ol>
<li>导入约束,context约束</li>
<li><strong>配置注解的支持：<a href="context:annotation-config/">context:annotation-config/</a></strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>	<br>    <span class="hljs-comment">&lt;!--配置注解的支持--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>@Autowried</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/c&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Cat&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.Dog&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.druid.bean.User&quot;</span> /&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;           <span class="hljs-comment">//使用@Autowried注解，不需要在配置文件中手动或者Byname,Bytype的注入属性</span><br>    						    <span class="hljs-comment">//在对应的属性上面加上这个注解，可以自动注入。</span><br>    <span class="hljs-keyword">private</span> String name;<br>&#125;    <br></code></pre></td></tr></table></figure>

<p>直接在属性上使用！也可以在set方法上使用！</p>
<p>使用Autowried我们可以不用再写set方法，前提是你这个自动装配的属性在IOC容器中存在。根据Bytype查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>	<span class="hljs-comment">//如果显示定义了Autowried的required属性为false，说明这个对象可以为null，否则不允许为null</span><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>科普：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Nullable   字段标记这个注解，说明这个字段可以为null；</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCat</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Cat cat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cat = cat;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>由于Autowried注解是根据type查找的，当配置文件中同时配置了多个类型相同的bean,那么使用Autowried注解就不能够自动注入了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bean.Dog&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bean.Dog&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bean.Cat&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bean.Cat&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bean.User&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>例如这个配置文件，cat1和cat2的类型都是一样的，Autowried是根据type查找，出现了相同类型，就不知道要注入哪一个了，这个时候我们就需要使用<code>@Qualifier</code>注解和<code>@Autowried</code>注解</p>
<p>先使用Autowried定位到需要注入的属性的类型<code>@Qualifier(value=&quot;xxx&quot;)</code>会在配置文件中找到id值为xxx的bean对象，再将它注入进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value=&quot;cat2&quot;)</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span>  String  name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是好像最新版的idea就算没用使用Qualifier注解也不会报错。</p>
<p><strong>@Resource注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name=&quot;cat2&quot;)</span><br><span class="hljs-keyword">private</span> Cat cat<br><span class="hljs-comment">//会在配置文件中找id为cat2的bean</span><br></code></pre></td></tr></table></figure>



<p>小结：</p>
<p> @Resource和@Autowried的区别</p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上。</li>
<li>@Autowried 通过ByType的方式实现，通过配合@Qualifier注解，先ByType查找，在Byname查找。</li>
<li>@Resource默认通过byname的方式实现，如果找不到名字，就通过bytype实现。</li>
</ul>
<h2 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8.使用注解开发"></a>8.使用注解开发</h2><p>在Spring4之后，要使用注解开发，必须要保证aop的包导入了。</p>
<p>使用注解需要导入context约束，增加注解的支持！</p>
<ol>
<li>bean</li>
<li>属性如何注入</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span>   <span class="hljs-comment">//将类注册到Spring容器内，getBean时的参数是小写的类名。</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-comment">//给name属性值注入值，相当于 &lt;property name=&quot;name&quot; value=&quot;pty&quot;&gt;</span><br>      <span class="hljs-meta">@Value(&quot;pty&quot;)</span><br>      <span class="hljs-keyword">public</span> String name ;<br>  &#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>衍生的注解</li>
</ol>
<p>@Component有几个衍生的注解，我们在web开发中，会按照mvc三层架构分层</p>
<ul>
<li>dao 【@Repository】</li>
<li>service 【@Service】</li>
<li>controller 【@Controller】</li>
</ul>
<p>这四个注解的功能都是一样的，都是代表将某个类注入到Spring容器中，装配Bean。</p>
<ol start="4">
<li>自动装配</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">- @Autowried ：自动装配通过类型<br>	如果Autowried不能唯一自动装配上属性，则需要通过@Qualifier(value=&quot;xxx&quot;)<br>- @Nullable  字段标记这个注解，说明这个字段可以为null<br>- @Resource  自动装配通过名字，类型。<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>作用域</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>              <span class="hljs-comment">//将User类注入到Spring容器内</span><br><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span>    <span class="hljs-comment">//设置bean的作用域</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;pty&quot;)</span><br>    <span class="hljs-keyword">public</span> String name ;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="6">
<li><p>小结</p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合，维护简单方便</li>
<li>注解，不是自己类是用不了，维护相对复杂。</li>
</ul>
<p>xml和注解最佳实践：</p>
<ul>
<li>xml用来管理bean</li>
<li>注解只负责完成属性的注入</li>
<li>我们在使用的过程中只需要注意一个问题：必须要注解生效。</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-comment">&lt;!--指定扫描的包，这个包下的注解就会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;bean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="9-使用Java的方式配置Spring"><a href="#9-使用Java的方式配置Spring" class="headerlink" title="9.使用Java的方式配置Spring"></a>9.使用Java的方式配置Spring</h2><p>我们现在要完全不使用Spring的xml配置了，全权交给Java来做了。</p>
<p>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能。</p>
<p><strong>User类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bean;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-comment">//属性注入值</span><br>        <span class="hljs-meta">@Value(&quot;xxx&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>Config类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> config;<br><br><br><span class="hljs-keyword">import</span> bean.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<br><br><span class="hljs-comment">//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个Component。</span><br><span class="hljs-comment">// @Configuration代表这是一个配置类，就和我们之前的applicationContext.xml一样</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;bean&quot;)</span>   <span class="hljs-comment">//扫描包，该包下的注解就会生效</span><br><span class="hljs-meta">@Import(&#123;Userconfig2.class&#125;)</span>  <span class="hljs-comment">//引入另一类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Userconfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//注册一个Bean,就相当于我们之前写的bean标签</span><br>    <span class="hljs-comment">//这个方法的名字：getUser就相当于bean标签中的id属性</span><br>    <span class="hljs-comment">//这个方法的返回值 User 就相当于bean标签中的class属性</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();  <span class="hljs-comment">//返回要注入到bean的对象。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> bean.User;<br><span class="hljs-keyword">import</span> config.Userconfig;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//如果完全使用了配置类方式去做，我们就只能通过AnootationConfig上下文来获取容器，通过配置类的class对象加载</span><br>       ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(Userconfig.class);<br>        User user = (User) context.getBean(<span class="hljs-string">&quot;getUser&quot;</span>);<br>        System.out.println(user.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种纯java的配置方式，在SpringBoot中随处可见。</p>
<h2 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10. 代理模式"></a>10. 代理模式</h2><p>为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h3 id="10-1静态代理"><a href="#10-1静态代理" class="headerlink" title="10.1静态代理"></a>10.1静态代理</h3><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人！</li>
</ul>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li>
<li>公共业务就交给代理角色，实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍<del>开发效率变低</del></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot整合redis</title>
    <url>/2021/07/22/springboot%E6%95%B4%E5%90%88redis/</url>
    <content><![CDATA[<h3 id="一、pom"><a href="#一、pom" class="headerlink" title="一、pom"></a>一、pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="二、application-yml"><a href="#二、application-yml" class="headerlink" title="二、application.yml"></a>二、application.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">redis:</span><br>    <span class="hljs-comment">#redis服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.102</span>  <br>    <span class="hljs-comment">#redis连接端口号</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#redis连接密码</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-comment">#redis连接超时时间（毫秒）</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">18000</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment"># 连接池最小空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 连接池最大空闲连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<h3 id="三、自定义redisTemplate"><a href="#三、自定义redisTemplate" class="headerlink" title="三、自定义redisTemplate"></a>三、自定义redisTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>		RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>		StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>这是springboot自动配置的redisTemplate，可以看到他的泛型是&lt;object,object&gt;,但我们用的最多的是string，所以在使用的时候就会要多次强制转换，并且默认使用的是Jdk的序列化方式。会存在乱码情况</p>
<p>所以我们自己编写一个redisTemplate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>      RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();<br>      <span class="hljs-comment">//配置连接工厂</span><br>      template.setConnectionFactory(factory);<br>      <span class="hljs-comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化</span><br>      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>      ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>      <span class="hljs-comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span><br>      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>      <span class="hljs-comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span><br>      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>      jackson2JsonRedisSerializer.setObjectMapper(om);<br>      StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br><br>      <span class="hljs-comment">// key采用String的序列化方式</span><br>      template.setKeySerializer(stringRedisSerializer);<br>      <span class="hljs-comment">// hash的key也采用String的序列化方式</span><br>      template.setHashKeySerializer(stringRedisSerializer);<br>      <span class="hljs-comment">// value序列化方式采用jackson</span><br>      template.setValueSerializer(jackson2JsonRedisSerializer);<br>      <span class="hljs-comment">// hash的value序列化方式采用jackson</span><br>      template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>      template.afterPropertiesSet();<br><br>      <span class="hljs-keyword">return</span> template;<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="四、redis工具类"><a href="#四、redis工具类" class="headerlink" title="四、redis工具类"></a>四、redis工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtil</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-comment">// =============================common============================</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定缓存失效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                redisTemplate.expire(key, time, TimeUnit.SECONDS);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key 获取过期时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断key是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasKey</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.hasKey(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 可以传一个值 或多个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String... key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span> &amp;&amp; key.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (key.length == <span class="hljs-number">1</span>) &#123;<br>                redisTemplate.delete(key[<span class="hljs-number">0</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                redisTemplate.delete(CollectionUtils.arrayToList(key));<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// ============================String=============================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存获取</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : redisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存放入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForValue().set(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通缓存放入并设置时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false 失败</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递增</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要增加几(大于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递增因子必须大于0&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, delta);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递减</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要减少几(小于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">decr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;递减因子必须大于0&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);<br>    &#125;<br><br><br>    <span class="hljs-comment">// ================================Map=================================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashGet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hget</span><span class="hljs-params">(String key, String item)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().get(key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取hashKey对应的所有键值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对应的多个键值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Object, Object&gt; <span class="hljs-title">hmget</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().entries(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashSet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 对应多个键值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().putAll(key, map);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashSet 并设置时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map  对应多个键值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().putAll(key, map);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                expire(key, time);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().put(key, item, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForHash().put(key, item, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;<br>                expire(key, time);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除hash表中的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 可以使多个 不能为null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hdel</span><span class="hljs-params">(String key, Object... item)</span> </span>&#123;<br>        redisTemplate.opsForHash().delete(key, item);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断hash表中是否有该项的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hHasKey</span><span class="hljs-params">(String key, String item)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要增加几(大于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hincr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash递减</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要减少记(小于0)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hdecr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);<br>    &#125;<br><br><br>    <span class="hljs-comment">// ============================set=============================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key获取Set中的所有值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">sGet</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().members(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据value从一个set中查询,是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sHasKey</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(key, value);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将数据放入set缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSet</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().add(key, values);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将set数据放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time   时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSetAndTime</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long count = redisTemplate.opsForSet().add(key, values);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取set缓存的长度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sGetSetSize</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除值为value的</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">setRemove</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long count = redisTemplate.opsForSet().remove(key, values);<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ===============================list=================================</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取list缓存的内容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 开始</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   结束 0 到 -1代表所有值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">lGet</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().range(key, start, end);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取list缓存的长度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lGetListSize</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().size(key);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过索引 获取list中的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">lGetIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForList().index(key, index);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPush(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPush(key, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPushAll(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将list放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().rightPushAll(key, value);<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)<br>                expire(key, time);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引修改list中的某条数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lUpdateIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisTemplate.opsForList().set(key, index, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除N个值为value</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 移除多少个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lRemove</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> count, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Long remove = redisTemplate.opsForList().remove(key, count, value);<br>            <span class="hljs-keyword">return</span> remove;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>通常情况下一个进程中包含若干个线程，一个进程中至少有一个线程。线程是cpu调度和执行的单位。</p>
<p>很多多线程是模拟出来的，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所有就有同时执行的错觉。</p>
<a id="more"></a>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210331194428311.png" alt="image-20210331194428311"></p>
<h4 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h4><h5 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h5><h6 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h6><ul>
<li>继承Thread类</li>
<li>重写run()方法</li>
<li>调用start开启线程  <strong>注意：调用的是start方法，不是run方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;哈哈哈&quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//main线程  主线程</span><br><br>        <span class="hljs-comment">//创建一个线程对象</span><br>        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();<br><br>        <span class="hljs-comment">//调用start()方法，开启多线程</span><br>        testThread.start();<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;嘻嘻嘻&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程不一定立即执行，有cpu安排调度。</p>
<h5 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h5><h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><ul>
<li>实现Runnable接口</li>
<li>重写run()方法</li>
<li>创建Runnable接口的实现类对象</li>
<li>创建Thread线程对象，将上面创建的实现类对象作为参数传入构造函数中，通过线程对象开启多线程，代理模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThred2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;哈哈哈&quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//mian线程  主线程</span><br>        <br>        <span class="hljs-comment">//创建实现Runnable接口的实现类对象</span><br>        TestThred2 testThred2 = <span class="hljs-keyword">new</span> TestThred2();<br>        <span class="hljs-comment">//创建线程对象，并调用start()方法开启多线程</span><br>        <span class="hljs-keyword">new</span> Thread(testThred2).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;嘻嘻嘻&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210331204653399.png" alt="image-20210331204653399"></p>
<h5 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h5><h6 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h6><ul>
<li>实现Callable接口，需要返回值类型</li>
<li>重写call方法，需要抛出异常</li>
<li>创建实现接口的实现类对象</li>
<li>创建执行服务</li>
<li>提交执行</li>
<li>获取结果</li>
<li>关闭服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThred2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//这里的泛型可以自己定义 影响到call方法的返回值</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;哈哈哈&quot;</span>+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;多线程结束&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        TestThred2 testThred2 = <span class="hljs-keyword">new</span> TestThred2();<br><br>        <span class="hljs-comment">//创建执行服务，创建固定数量的线程池</span><br>        ExecutorService ser = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//提交执行</span><br>        Future&lt;String&gt; r1 = ser.submit(testThred2);<br>        Future&lt;String&gt; r2 = ser.submit(testThred2);<br>        <br>        <span class="hljs-comment">//获取返回值</span><br>        String s = r1.get();<br>        String s1 = r2.get();<br>        System.out.println(s);<br>        System.out.println(s1);<br>        <br>        <span class="hljs-comment">//关闭服务</span><br>        ser.shutdownNow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初识并发问题"><a href="#初识并发问题" class="headerlink" title="初识并发问题"></a>初识并发问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThred2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num =<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//让当前线程延时</span><br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//Thread.currentThread() 得到当前线程对象的实例，</span><br>            <span class="hljs-comment">//getName()得到此线程的名字</span><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了第&quot;</span>+num--+<span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThred2 testThred2 = <span class="hljs-keyword">new</span> TestThred2();<br>		<span class="hljs-comment">//创建一个线程，并生成名字</span><br>        <span class="hljs-keyword">new</span> Thread(testThred2,<span class="hljs-string">&quot;小明&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(testThred2,<span class="hljs-string">&quot;小红&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(testThred2,<span class="hljs-string">&quot;小花&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210331211534734.png" alt="image-20210331211534734"></p>
<p>可以看到输出的结果紊乱，多个人拿到同一张票。</p>
<p>多个线程操作同一个资源的情况下，线程不安全，数据紊乱</p>
<h4 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h4><h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><p>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口，对于函数式接口，我们可以通过lamda表达式来创建该接口的对象。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210401142922082.png" alt="image-20210401142922082"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210401143008686.png" alt="image-20210401143008686"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210401143112018.png" alt="image-20210401143112018"></p>
<h5 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h5><ul>
<li>不推荐使用jdk提供的stop方法和destory方法</li>
<li>推荐线程自己停下来</li>
<li>建议使用一个标志位作为终止变量，当flag=false时，终止线程运行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mp.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">//终止变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag=<span class="hljs-keyword">true</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag)<br>        System.out.println(<span class="hljs-string">&quot;hahahah&quot;</span>+i++);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();<br><br>        <span class="hljs-keyword">new</span> Thread(testThread).start();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-comment">//当i==900的时候，停止上面开启的线程</span><br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">900</span>)<br>                testThread.stop();<br>            System.out.println(<span class="hljs-string">&quot;xixi&quot;</span>+i);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="线程休眠-sleep"><a href="#线程休眠-sleep" class="headerlink" title="线程休眠 sleep"></a>线程休眠 sleep</h5><h5 id="线程礼让-yield"><a href="#线程礼让-yield" class="headerlink" title="线程礼让 yield"></a>线程礼让 yield</h5><p>礼让线程，让当前正在执行的线程<strong>暂停</strong>，但是不阻塞，将线程由运行状态转为就绪状态，等待cpu的调度，但是下次被调度的不一定不是礼让的线程，还是由cpu随机调度。</p>
<h5 id="线程强制执行-Join"><a href="#线程强制执行-Join" class="headerlink" title="线程强制执行 Join"></a>线程强制执行 Join</h5><p>Join合并线程，待此线程完成后，再执行其他线程，可以想象成插队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;vip用户&quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(testThread);<br>        thread.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br><br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">150</span>)<br>                <span class="hljs-comment">//插队，让thread线程先运行，运行完以后再运行该线程</span><br>                thread.join();<br>            System.out.println(<span class="hljs-string">&quot;mian&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="观察线程的状态-Thread-State"><a href="#观察线程的状态-Thread-State" class="headerlink" title="观察线程的状态  Thread.State"></a>观察线程的状态  Thread.State</h5><p>线程状态。线程可以处于以下状态之一：</p>
<ul>
<li><p>NEW<br>尚未启动的线程处于此状态。 </p>
</li>
<li><p>RUNNABLE<br>在Java虚拟机中执行的线程处于此状态。</p>
</li>
<li><p>BLOCKED</p>
<p>被阻塞等待监视器锁定的线程处于此状态。</p>
</li>
<li><p>WAITING<br>正在等待另一个线程执行特定动作的线程处于此状态。 </p>
</li>
<li><p>TIMED_WAITING<br>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 </p>
</li>
<li><p>TERMINATED</p>
<p>已退出的线程处于此状态。</p>
<p>一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。 </p>
</li>
</ul>
<p>死亡后的线程不能再次被启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//lamda表达式</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;多线程&quot;</span>);<br>        &#125;);<br><br><br>        <span class="hljs-comment">//观察状态</span><br>        Thread.State state = thread.getState();<br>        System.out.println(state);  <span class="hljs-comment">//NEW</span><br><br>        <span class="hljs-comment">//启动线程</span><br>        thread.start();<br>        System.out.println(thread.getState()); <span class="hljs-comment">//RUNNABLE</span><br><br>        <span class="hljs-keyword">while</span>(state!=Thread.State.TERMINATED)&#123;  <span class="hljs-comment">//只要线程没结束，就输出线程状态</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(state);<br>            state=thread.getState();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有进程，线程调度器按照优先级决定应该调度哪个线程来执行。</p>
<p>优先级用数字来表示，范围为1~10</p>
<p>使用<code>getPriority()</code>获取优先级，使用<code>setPriority(int xxx)</code>设置优先级</p>
<p>设置了优先级，也不一定优先级高调度先执行。优先级低只是说获得调度的概率低，终究还是一个概率问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span>   <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());<br>        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(testThread);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(testThread);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(testThread);<br>        Thread t4 = <span class="hljs-keyword">new</span> Thread(testThread);<br>        Thread t5 = <span class="hljs-keyword">new</span> Thread(testThread);<br>        Thread t6 = <span class="hljs-keyword">new</span> Thread(testThread);<br>        <span class="hljs-comment">// 先设置优先级在启动线程</span><br>        t1.start();<br><br>        t2.setPriority(<span class="hljs-number">1</span>);<br>        t2.start();<br><br>        t3.setPriority(<span class="hljs-number">4</span>);<br>        t3.start();<br><br>        t4.setPriority(<span class="hljs-number">10</span>);<br>        t4.start();<br><br>        t5.setPriority(Thread.MAX_PRIORITY);<br>        t5.start();<br><br>        t6.setPriority(Thread.NORM_PRIORITY);<br>        t6.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程(daemon)"></a>守护线程(daemon)</h5><p>线程分为用户线程和守护线程，<strong>虚拟机必须确保用户线程执行完毕，但是不同等待守护线程执行完毕</strong>，也就是说，如果用户线程没有执行完毕，那么程序将不会结束，只用当用户线程结束后，程序才会结束。而如果守护线程没有执行完，但是用户线程执行完毕，程序仍然结束。</p>
<p><strong>守护线程可以用来后台记录操作日志，监控内存，垃圾回收等待等工作</strong></p>
<p>通过设置<code>setDaemon()</code>方法设置是否为守护线程，传入布尔值，默认是false，表示是用户线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        You you = <span class="hljs-keyword">new</span> You();<br>        God god = <span class="hljs-keyword">new</span> God();<br><br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(god);<br>        thread1.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程</span><br>        thread1.start();<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(you);<br>        thread.start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;有按时长大&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;goodbye，world&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">God</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)   <span class="hljs-comment">//永远执行，但是由于上面被设置为守护线程，因此程序不会管该线程是否结束。</span><br>            System.out.println(<span class="hljs-string">&quot;上帝与你同在&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多线程进阶"><a href="#多线程进阶" class="headerlink" title="多线程进阶"></a>多线程进阶</h3><h4 id="多线程同步机制"><a href="#多线程同步机制" class="headerlink" title="多线程同步机制"></a>多线程同步机制</h4><p>并发：多线程访问同一个对象</p>
<p><img src="/.com//笔记\img\Linux部署环境\image-20210407214450499.png" alt="image-20210407214450499"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210407214624523.png" alt="image-20210407214624523"></p>
<p>线程同步的安全性需要<strong>队列+锁</strong> </p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210407215013532.png" alt="image-20210407215013532"></p>
<p>确保了程序的安全性，但是降低了性能</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210408144045258.png" alt="image-20210408144045258"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210408144134205.png" alt="image-20210408144134205"></p>
<p>线程同步代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.SneakyThrows;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThred2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BuyTicket buyTicket = <span class="hljs-keyword">new</span> BuyTicket();<br>        <span class="hljs-keyword">new</span> Thread(buyTicket,<span class="hljs-string">&quot;小明&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(buyTicket,<span class="hljs-string">&quot;小红&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(buyTicket,<span class="hljs-string">&quot;小朱&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuyTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            buy();<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">//synchroized 同步方法，锁的是对象。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">0</span>)&#123;<br>            flag=<span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  &quot;</span>+num--);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210408150604377.png" alt="image-20210408150604377"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.SneakyThrows;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span>  </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account account = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">150</span>,<span class="hljs-string">&quot;基金&quot;</span>);<br>        Drawing me = <span class="hljs-keyword">new</span> Drawing(account, <span class="hljs-number">50</span>, <span class="hljs-string">&quot;me&quot;</span>);<br>        Drawing you = <span class="hljs-keyword">new</span> Drawing(account, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;you&quot;</span>);<br>        me.start();<br>        you.start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//账户</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br>    <span class="hljs-keyword">int</span> money;  <span class="hljs-comment">//卡里的钱</span><br>    String name; <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//银行，模拟取款</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>   Account account;<br>   <span class="hljs-keyword">int</span> drawingMoney;  <span class="hljs-comment">//取的钱</span><br>   <span class="hljs-keyword">int</span> nowMoney;   <span class="hljs-comment">//手中的钱</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Drawing</span><span class="hljs-params">(Account account,<span class="hljs-keyword">int</span> drawingMoney,String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.account=account;<br>        <span class="hljs-keyword">this</span>.drawingMoney=drawingMoney;<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (account)&#123;<br><br>            <span class="hljs-keyword">if</span>(account.money-drawingMoney&lt;<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.getName()+<span class="hljs-string">&quot;钱不够了，取不了&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            account.money=account.money-drawingMoney;<br>            nowMoney=nowMoney+drawingMoney;<br>            System.out.println(account.name+<span class="hljs-string">&quot;余额为：&quot;</span>+account.money);<br>            System.out.println(<span class="hljs-keyword">this</span>.getName()+<span class="hljs-string">&quot;  &quot;</span>+nowMoney);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>可以看到上面两个例子有不同的地方，第一个例子是模拟买票，第二个例子是模拟用同一个账户去取钱。由于车票余下的数量是在车站里面的，因此我们锁住了取票这个方法，那么久可以保证线程的安全，A买完票以后B才能买。所以我们使用<code>synchronized</code>方法。但是第二个例子中，我们的余额是在账户中，如果我们锁了run方法（因为synchronized锁的是对象，所以锁的也就是Drawing这个对象），只是锁住了取钱这一个操作，但是没有锁住账户中的余额，也就是说我们可能同时看到了100元，同时去取，但是因为加锁了，取钱这个操作要排队，我取完50，你再取，但是你取的时候账户余额还是100，因为没有锁住余额，不是要等上一次操作完余额发生变化之后才能进行操作</strong> 。 ==总而言之，锁的对象就是变化的量，需要增删改的对象，也就是共享资源==</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210408153422016.png" alt="image-20210408153422016"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210408154021123.png" alt="image-20210408154021123"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.SneakyThrows;<br><br><span class="hljs-comment">//死锁：多个线程互相抱着对方需要的资源，然后形成僵持</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Makeup g1 = <span class="hljs-keyword">new</span> Makeup(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;小红&quot;</span>);<br>        Makeup g2 = <span class="hljs-keyword">new</span> Makeup(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        g1.start();<br>        g2.start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//口红</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lipstick</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//镜子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mirror</span></span>&#123;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Makeup</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-comment">//需要的资源只有一份，用static来保证</span><br>    <span class="hljs-keyword">static</span> Lipstick lipstick= <span class="hljs-keyword">new</span> Lipstick();<br>    <span class="hljs-keyword">static</span> Mirror mirror = <span class="hljs-keyword">new</span> Mirror();<br><br>    <span class="hljs-keyword">int</span> choice;  <span class="hljs-comment">//选择</span><br>    String name; <span class="hljs-comment">//名字</span><br><br>    Makeup(<span class="hljs-keyword">int</span> choice,String name)&#123;<br>        <span class="hljs-keyword">this</span>.choice=choice;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        makeup();<br>    &#125;<br>	<span class="hljs-comment">//化妆，互相持有对方的锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">makeup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (choice==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (lipstick)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得口红的锁&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (mirror)&#123;<br>                    System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得镜子的锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">synchronized</span> (mirror)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得镜子的锁&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">synchronized</span> (lipstick)&#123;<br>                    System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得口红的锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>上面的代码中，A先拿到口红的锁，并且没有释放掉，想在1秒之后再度拿到镜子的锁，但是镜子的锁B先拿到了，并且也没有释放掉，B想在2秒后拿到口红的锁，因此A与B相互僵持，最终程序卡死。拿到锁以后只有释放掉以后，其他对象才能拿到这个锁</strong></p>
<p>要想解决上面的情况，将睡眠之后拿锁的操作放在外面，也就是第一次拿锁结束，将这个锁释放掉，那么B就可以拿到这个锁，同理A也是。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.SneakyThrows;<br><br><span class="hljs-comment">//死锁：多个线程互相抱着对方需要的资源，然后形成僵持</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Makeup g1 = <span class="hljs-keyword">new</span> Makeup(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;小红&quot;</span>);<br>        Makeup g2 = <span class="hljs-keyword">new</span> Makeup(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        g1.start();<br>        g2.start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//口红</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lipstick</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//镜子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mirror</span></span>&#123;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Makeup</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-comment">//需要的资源只有一份，用static来保证</span><br>    <span class="hljs-keyword">static</span> Lipstick lipstick= <span class="hljs-keyword">new</span> Lipstick();<br>    <span class="hljs-keyword">static</span> Mirror mirror = <span class="hljs-keyword">new</span> Mirror();<br><br>    <span class="hljs-keyword">int</span> choice;  <span class="hljs-comment">//选择</span><br>    String name; <span class="hljs-comment">//名字</span><br><br>    Makeup(<span class="hljs-keyword">int</span> choice,String name)&#123;<br>        <span class="hljs-keyword">this</span>.choice=choice;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        makeup();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">makeup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (choice==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (lipstick)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得口红的锁&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (mirror)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得镜子的锁&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">synchronized</span> (mirror)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得镜子的锁&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (lipstick)&#123;<br>                System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;获得口红的锁&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.SneakyThrows;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-keyword">new</span> Thread(test).start();<br>        <span class="hljs-keyword">new</span> Thread(test).start();<br>        <span class="hljs-keyword">new</span> Thread(test).start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//定义lock锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();  <span class="hljs-comment">//加锁  要捕获一下错误</span><br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(num--);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();  <span class="hljs-comment">//解锁，解锁操作在finally中完成</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>lock锁和synchronized作用差不多，但是lock锁是显示锁，需要手动开启和关闭锁，一般在finally中关闭锁，并且lock锁只有代码块锁，但是synchronized有代码块锁和方法锁。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210409142700271.png" alt="image-20210409142700271"></p>
<h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210409152007207.png" alt="image-20210409152007207"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建线程连接池</span><br>        <span class="hljs-comment">//newFixedThreadPool 参数为线程池大小</span><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-comment">//执行线程，创建方法与原来不同，原来是 new Thread(new Mythread()).start;</span><br>        <span class="hljs-comment">//这里使用execute方法</span><br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br>        <br>        <span class="hljs-comment">//关闭连接</span><br>        service.shutdown();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>开发中遇到的问题</title>
    <url>/2020/09/08/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="springboot集成mybatis后，开始事务管理"><a href="#springboot集成mybatis后，开始事务管理" class="headerlink" title="springboot集成mybatis后，开始事务管理"></a>springboot集成mybatis后，开始事务管理</h3><ol>
<li>启用全局事务管理：在springboot的启动类上面，添加@**EnableTransactionManagement(proxyTargetClass = true)**注解</li>
<li>在service层中，在要添加的方法上面添加@Transactional注解，代表这个方法里面的操作是在同一个事务里面的，只要有一个事务有异常，就会回滚。</li>
</ol>
<a id="more"></a>



<h3 id="外键是用来干嘛的？"><a href="#外键是用来干嘛的？" class="headerlink" title="外键是用来干嘛的？"></a>外键是用来干嘛的？</h3><h3 id="有了外键应该怎么删除数据"><a href="#有了外键应该怎么删除数据" class="headerlink" title="有了外键应该怎么删除数据"></a>有了外键应该怎么删除数据</h3><h3 id="mybatis中parameterType中怎么传入多个不同类型的参数"><a href="#mybatis中parameterType中怎么传入多个不同类型的参数" class="headerlink" title="mybatis中parameterType中怎么传入多个不同类型的参数"></a>mybatis中parameterType中怎么传入多个不同类型的参数</h3><p>不需要使用parameterType参数</p>
<ol>
<li><p>使用下标</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">public <span class="hljs-built_in">List</span>&lt;XXXBean&gt; getXXXBeanList(<span class="hljs-built_in">String</span> xxId, <span class="hljs-built_in">String</span> xxCode);  <br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getXXXBeanList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;XXBean&quot;</span>&gt;</span><br><br>　　select t.* from tableName where id = #&#123;0&#125; and name = #&#123;1&#125;  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br></code></pre></td></tr></table></figure>

<p>由于是多参数那么就不能使用parameterType， 改用#｛index｝是第几个就用第几个的索引，索引从0开始</p>
</li>
<li><p>注解</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">public <span class="hljs-built_in">List</span>&lt;XXXBean&gt; getXXXBeanList(<span class="hljs-meta">@Param</span>(<span class="hljs-string">&quot;id&quot;</span>)<span class="hljs-built_in">String</span> id, <span class="hljs-meta">@Param</span>(<span class="hljs-string">&quot;code&quot;</span>)<span class="hljs-built_in">String</span> code);  <br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getXXXBeanList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;XXBean&quot;</span>&gt;</span><br><br>　　select t.* from tableName where id = #&#123;id&#125; and name = #&#123;code&#125;  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br></code></pre></td></tr></table></figure>

<p>由于是多参数那么就不能使用parameterType， 这里用@Param来指定哪一个</p>
</li>
<li><p>Map封装</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;XXXBean&gt; <span class="hljs-title">getXXXBeanList</span><span class="hljs-params">(HashMap <span class="hljs-built_in">map</span>)</span></span>;  <br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getXXXBeanList&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;hashmap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;XXBean&quot;</span>&gt;</span><br><br>　　select 字段... from XXX where id=#&#123;xxId&#125; code = #&#123;xxCode&#125;  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br></code></pre></td></tr></table></figure>

<p>其中hashmap是mybatis自己配置好的直接使用就行。map中key的名字是那个就在#{}使用那个，map如何封装就不用了我说了吧。</p>
</li>
<li><p>List封装</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">List</span>&lt;XXXBean&gt; getXXXBeanList(<span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">list</span>);  <br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getXXXBeanList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;XXBean&quot;</span>&gt;</span><br>　　select 字段... from XXX where id in<br>　　<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>  <br>　　　　#&#123;item&#125;  <br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span> <br></code></pre></td></tr></table></figure>

<p>总结</p>
<p>传递list和map在资源消耗上肯定远大于方法一和方法二，但是有一些特殊的情形需要传递list，比如你需要传递一个id集合并批量对id进行sql操作然后再返回等等。所以都需要了解。</p>
</li>
</ol>
<h3 id="Mybatis中传递参数时，会加上单引号吗"><a href="#Mybatis中传递参数时，会加上单引号吗" class="headerlink" title="Mybatis中传递参数时，会加上单引号吗"></a>Mybatis中传递参数时，会加上单引号吗</h3><p>使用**#{参数}**传入会加上单引号，sql语句解析是会加上‘ ’ </p>
<p>比如  select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是</p>
<p> select * from table where name = ‘小李’，就是会当成字符串来解析</p>
<p>但是${}并不会加上单引号</p>
<h3 id="在数据库中以时间分组查询数据怎么查"><a href="#在数据库中以时间分组查询数据怎么查" class="headerlink" title="在数据库中以时间分组查询数据怎么查"></a>在数据库中以时间分组查询数据怎么查</h3><p><code>select 时间 from 表名 group by 时间</code></p>
<h3 id="在数据库中按照准确的时间应该怎么查"><a href="#在数据库中按照准确的时间应该怎么查" class="headerlink" title="在数据库中按照准确的时间应该怎么查"></a>在数据库中按照准确的时间应该怎么查</h3><p>使用DATE_FORMAT()函数将date类型的转换为字符串</p>
<p>DATE_FORMAT(date,format)用法：将时间date转换为format格式的字符串</p>
<p>format是自己定义的格式，如<code>DATE_FORMAT(date,&#39;%Y-%m-%d&#39;)</code>，就是将date转换为格式为年-月-日的字符串</p>
<p><code>select * from 表名 where DATE_FORMAT(date,&#39;%Y-%m-%d&#39;)=xxx</code></p>
<h3 id="pgeHelper插件的用法"><a href="#pgeHelper插件的用法" class="headerlink" title="pgeHelper插件的用法"></a>pgeHelper插件的用法</h3><p>pageHelper插件是用来解决分页的问题</p>
<p>使用方法</p>
<ol>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 特别注意版本问题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在controller中直接使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/articles&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;得到所有的文章信息，用于在首页进行博客展示,需要传入当前pageNum,不传默认为1,每页显示3条信息&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResResult <span class="hljs-title">findAll</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span><span class="hljs-keyword">int</span> pageNum)</span></span>&#123;  <br>    <span class="hljs-comment">//传入pageNum的值，defaulValue表示默认值</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        PageHelper.startPage(pageNum,<span class="hljs-number">3</span>);  <span class="hljs-comment">//设置pageNum和pageSize的值</span><br>       List&lt;Article&gt; articles = articleService.findAll();<br>        PageInfo&lt;Article&gt; pageInfo = <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(articles);  <br>        <span class="hljs-comment">//将查询的结果放入PageInfo类中，在里面会有查询到的接货以及分页的信息（比如总页数，总记录数等等）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResResult(ResultCode.SUCCESS,pageInfo);<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResResult(ResultCode.ERROR,e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>PageInfo中的一些属性</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageNum;   <span class="hljs-comment">//当前页码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageSize;   <span class="hljs-comment">//每页显示多少条信息</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;      <span class="hljs-comment">//当前页有多少条信息</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> startRow;  <span class="hljs-comment">//表示当前页面第一个元素在数据库中的行号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> endRow;    <span class="hljs-comment">//表示当前页面的最后一个元素在数据库中的行号  startRow和endRow不常用，</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> total;    <span class="hljs-comment">//表示总的记录数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pages;     <span class="hljs-comment">//表示总的页数</span><br><span class="hljs-keyword">private</span> List&lt;T&gt; <span class="hljs-built_in">list</span>;  <span class="hljs-comment">//结果集</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> prePage;   <span class="hljs-comment">//前一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextPage;  <span class="hljs-comment">//后一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isFirstPage;  <span class="hljs-comment">//当前页面是第一页吗</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLastPage;   <span class="hljs-comment">//当前页面是最后一页吗</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasPreviousPage;  <span class="hljs-comment">//当前页面是否有上一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasNextPage;   <span class="hljs-comment">//当前页面是否有下一页</span><br><br></code></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="MapperScan注解的使用"><a href="#MapperScan注解的使用" class="headerlink" title="@MapperScan注解的使用"></a>@MapperScan注解的使用</h3><p>在学习了spring之后，不在需要给dao层建立实体类，只需要写出dao的接口就行了，但是需要我们使用@Mapper注解，在dao接口类上添加@Mapper注解，在编译之后就会生成接口实现类，不在需要我们人为的去写一个实现类。</p>
<p>但是在接口类很多的情况下，就需要我们给很多接口类都添加@Mapper注解，比较麻烦。所以就出现了@MapperScan</p>
<p><strong>@MapperScan注解</strong>用于指定dao接口类所在的包，该包下的每一个接口在编译之后都会生成一个实现类，不用再在每一个接口类上添加@Mapper注解。</p>
<p><strong>@MapperScan注解在springboot启动类上添加</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.hutdsj.blog.mapper&quot;)</span>   <span class="hljs-comment">//指定接口类所在的包，com.hutdsj.blog.mapper下的所有接口都会在编译后生成实现类@SpringBootApplication  //指定这是一个springboot程序public class BlogApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(BlogApplication.class, args);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>@MapperScan注解指定多个包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&#123;&quot;com.kfit.demo&quot;,&quot;com.kfit.user&quot;&#125;)</span>    <span class="hljs-comment">//使用逗号隔开</span><br></code></pre></td></tr></table></figure>



<h3 id="使用-Autowried-注解后注入为null"><a href="#使用-Autowried-注解后注入为null" class="headerlink" title="使用@Autowried 注解后注入为null"></a>使用@Autowried 注解后注入为null</h3><p>当你的注入对象已经注册到容器中（即已经添加了@Compoent，@Controller….等注解），但是仍然注入为null时，需要检查获取对象的方式是否为new,new出来的对象使用的是有参，无参构造，不走spring的IOC容器，直接创建出来的。而@Autowried注解是根据type自动配置，要求对象是在IOC容器里面的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/verifycode&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getVerify</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        response.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<span class="hljs-comment">//设置相应类型,告诉浏览器输出的内容为图片        response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//设置响应头信息，告诉浏览器不要缓存此内容        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);        response.setDateHeader(&quot;Expire&quot;, 0);        VerifyCode verifyCode = new VerifyCode();        verifyCode.getRandcode(request, response);//输出验证码图片方法    &#125; catch (Exception e) &#123;       e.printStackTrace();    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCode</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RedisUtil redisUtil;    ......    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRandcode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;     	.......        redisUtil.set(RANDOMCODEKEY,randomString);      	......    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>如上面这两段代码，因为verifyCode这个对象是被new出来的，即使在VerifyCode这个类中使用 <code>@Autowired</code>标注了</p>
<p><code>RedisUtil</code>,但是仍然获取不到RedisUtil的值，即没有创建出这个对象。</p>
<p>解决方法是在第一段代码中，verifyCode这个对象不要是new出来的，使用 <code>@Autowired</code>标注实体类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutowiredVerifyCode</span> verifyCode;	<br></code></pre></td></tr></table></figure>

<p>简单的来说：**@Autowired注入Spring Bean，则当前类必须也是Spring Bean才能调用它，不能用new xxx()来获得对象，这种方式获得的对象无法调用@Autowired注入的Bean。**</p>
<h3 id="使用-ConfigurationProperties注解，下面有横线"><a href="#使用-ConfigurationProperties注解，下面有横线" class="headerlink" title="使用@ConfigurationProperties注解，下面有横线"></a>使用@ConfigurationProperties注解，下面有横线</h3><p>使用<code>@ConfigurationProperties</code>注解，注解下面有横线，需要引入下面这个依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>但是好像就算有横线也没有问题，可以读取到配置文件。</p>
<h3 id="使用-ConfigurationProperties注解，读取不到配置文件"><a href="#使用-ConfigurationProperties注解，读取不到配置文件" class="headerlink" title="使用@ConfigurationProperties注解，读取不到配置文件"></a>使用@ConfigurationProperties注解，读取不到配置文件</h3><p>使用这个注解给实体类注入信息，需要配置文件中的属性名和实体类中的属性名一致，同时实体类中的属性还需要有set,get方法。</p>
<h3 id="在拦截器中使用-AutoWired注解注入为null"><a href="#在拦截器中使用-AutoWired注解注入为null" class="headerlink" title="在拦截器中使用@AutoWired注解注入为null"></a>在拦截器中使用@AutoWired注解注入为null</h3><p>因为拦截器的加载是在<strong>springcontext</strong>之前，所以在拦截器中注入为null。</p>
<p>因此我们需要在配置类中使用@Bean注解提前去加载</p>
<p>修改前的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;        <span class="hljs-comment">//注册拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //添加具体的拦截器，同时设置拦截的地址。        //JwtInterceptor为我们拦截器实体类        registry.addInterceptor(new JwtInterceptor()).addPathPatterns(&quot;/user/h&quot;);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>修改之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;	<span class="hljs-comment">//使用@Bean注解提前加载JwtInterceptor这个类    @Bean    public JwtInterceptor jwtInterceptor()&#123;        return new JwtInterceptor();    &#125;    //注册拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //添加具体的拦截器，同时设置拦截的地址。        registry.addInterceptor(jwtInterceptor()).addPathPatterns(&quot;/user/h&quot;);    &#125;	//注意：我们这里使用@Bean将jwtInterceptor 注册到IOC容器，然后下面addInterceptor中的参数不再是new JwtInterceptor(),而是调用上面的jwtInterceptor()方法&#125;</span><br></code></pre></td></tr></table></figure>

<p>拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;	    <span class="hljs-comment">//自动注入jwtutil    @Autowired    JwtUtil jwtUtil;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        String token = request.getHeader(&quot;token&quot;);        try &#123;            Claims claims = jwtUtil.parseJwt(token);            return true;        &#125; catch (Exception e) &#123;            map.put(&quot;code&quot;,403);            map.put(&quot;msg&quot;,&quot;token无效&quot;);        &#125;        String json= new ObjectMapper().writeValueAsString(map);        response.getWriter().write(json);        return false;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<h3 id="Disconnected-from-the-target-VM-address-‘127-0-0-1-3231’-transport-‘socket’"><a href="#Disconnected-from-the-target-VM-address-‘127-0-0-1-3231’-transport-‘socket’" class="headerlink" title="Disconnected from the target VM, address: ‘127.0.0.1:3231’, transport: ‘socket’"></a>Disconnected from the target VM, address: ‘127.0.0.1:3231’, transport: ‘socket’</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201104175754449.png" alt="image-20201104175754449"></p>
<p>在项目中报了这个错，在网上百度了很久，都不是我错误的原因。</p>
<p>我找了很久，发现是将一个类两次注册到IOC容器中的原因。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201104175954095.png" alt="image-20201104175954095"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201104180110624.png" alt="image-20201104180110624"></p>
<p>比如说这里，我已经使用<code>@Component</code>注解将<code>JwtInterceptor</code>注册到IOC容器中，但是我在<code>WebConfig</code>中又使用<code>@Bean</code>注解将<code>JwtInterceptor</code>注册到IOC容器中，然后就报了这样的错误。</p>
<h3 id="使用json将地址传给前端，发现地址处有两根斜杠"><a href="#使用json将地址传给前端，发现地址处有两根斜杠" class="headerlink" title="使用json将地址传给前端，发现地址处有两根斜杠"></a>使用json将地址传给前端，发现地址处有两根斜杠</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201109193629497.png" alt="image-20201109193629497"></p>
<p>这个情况是正常的，因为后面的地址是字符串，而在字符串中，反斜杠需要使用转义字符，也就是两个反斜杠来表示一个反斜杠，因此，这里的两个反斜杠只是标识这是一个字符串中的转移字符，仍然是一个反斜杠。</p>
<h3 id="从redis中获取数据，得到了Object类型，怎么将其转为java实体类"><a href="#从redis中获取数据，得到了Object类型，怎么将其转为java实体类" class="headerlink" title="从redis中获取数据，得到了Object类型，怎么将其转为java实体类"></a>从redis中获取数据，得到了Object类型，怎么将其转为java实体类</h3><p>使用fastjson来进行转换。</p>
<p>从redis中取出数据，得到了一个List<Object>xxx,想将它转为对应的java实体类。</Object></p>
<ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从redis中获取数据List&lt;Object&gt; topics = redisUtil.lGet(&quot;topics&quot;, 0, -1);//得到是是一个json字符串数组，将其转为topic类List&lt;Topic&gt; topics1 = JSONObject.parseArray(JSON.toJSONString(topics),Topic.class);for (Topic topic : topics1) &#123;    System.out.println(topic);</span><br></code></pre></td></tr></table></figure>



<h3 id="json返回到前端的日期格式有问题"><a href="#json返回到前端的日期格式有问题" class="headerlink" title="json返回到前端的日期格式有问题"></a>json返回到前端的日期格式有问题</h3><p>​    如果没有进行专门的设置，直接把日期返回给前端，那么日期的格式是有问题的</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201109212105358.png" alt="image-20201109212105358"></p>
<p>比如这个，日期看起来很乱，不是我们需要的格式（ps：之前格式更乱，和设置的时间相差8个小时）</p>
<p>因此我们需要专门设置一下日期的格式，在对应的实体类里面，在日期属性上面使用<code>@JsonFormat</code>注解，写上日期格式以及时区。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201109212428691.png" alt="image-20201109212428691"></p>
<h3 id="保存到数据库的时间和设置的时间相差8个小时"><a href="#保存到数据库的时间和设置的时间相差8个小时" class="headerlink" title="保存到数据库的时间和设置的时间相差8个小时"></a>保存到数据库的时间和设置的时间相差8个小时</h3><p>在此之前，我写jdbc的url都是这样写的<code>url:jdbc:mysql://localhost:3306/xxx?serverTimezone=utc</code></p>
<p>我们将时区设置为utc（utc不是时区，这样说只是为了理解），但是utc是协调世界时，中国在东八区，和这个时间相比快了8个小时，因此我们需要将时区设置为中国的时区</p>
<p>所以以后我们的url可以这么写: <code>url: jdbc:mysql://localhost:3306/hutbbs?serverTimezone=Asia/Shanghai</code></p>
<h3 id="数据库的字段名和关键字发生冲突"><a href="#数据库的字段名和关键字发生冲突" class="headerlink" title="数据库的字段名和关键字发生冲突"></a>数据库的字段名和关键字发生冲突</h3><p>写项目的时候报了这个错误</p>
<p><img src="/.com//myblog\public\images\多线程\image-20210415221808053.png" alt="image-20210415221808053"></p>
<p><strong>ou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near  xxxx</strong> 这个错误是数据库中的字段名和关键字起了冲突。碰到这种情况，我们一般有以下几种解决方法。</p>
<ul>
<li>第一种是修改字段名，将字段名修改为和关键字不冲突的名字。可以将sql语句复制到navicat中， 关键字会用蓝色标记， rank 没有用蓝色标记，但是好像也不能用，用了也会出错误，我就是被rank耽误了好久时间。</li>
<li>第二种是不修改字段名，在sql语句中，用一些特殊的符号将起冲突的字段名给括起来。在sqlserver中，使用方括号将字段名括起来,如：**[name]**。在mysql中，使用反单引号将字段名括起来（tab上面的那个键）如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">`name`<br></code></pre></td></tr></table></figure>



<h3 id="与前端对接数据时，接收到的数据为null"><a href="#与前端对接数据时，接收到的数据为null" class="headerlink" title="与前端对接数据时，接收到的数据为null"></a>与前端对接数据时，接收到的数据为null</h3><p>首先看前端传过来的数据是否为json格式，如果是json格式的话，就需要使用<code>@RequestBody</code>这个注解。</p>
<p>其次需要知道前端是否将数据封装成一个对象传递过来，如果封装为一个对象，那么我们这边也需要使用一个对象来接收数据。比如 前端传过来了用户名和密码，但是他封装为一个对象，所以我们在方法的参数上就需要写<code>User user</code>,而不能使用<code>String username,String password</code>来接收数据。</p>
<h3 id="将实体类存放到一些数据结构中，当再次取出来的时候，不能转成原来的实体类"><a href="#将实体类存放到一些数据结构中，当再次取出来的时候，不能转成原来的实体类" class="headerlink" title="将实体类存放到一些数据结构中，当再次取出来的时候，不能转成原来的实体类"></a>将实体类存放到一些数据结构中，当再次取出来的时候，不能转成原来的实体类</h3><p>上面<strong>从redis中获取数据，得到的Object类型</strong>问题其实和这个问题是一样的，只不过上面只是讲解的是redis中的。</p>
<p>取出来的数据不能转成原来的类型，我们需要借助json，先将原来的数据转为json格式，然后在使用json将数据封装到具体的实体类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入fastjson依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.56<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类型转换Object user = claims.get(&quot;user&quot;);//将map中的类型转为User类//先将user转为json字符串，然后使用parseObject 将字符串转为User.classUser user1 = JSON.parseObject(JSON.toJSONString(user), User.class);o</span><br></code></pre></td></tr></table></figure>

<h3 id="sql语句中，用查询结果作为like模糊查询的参数"><a href="#sql语句中，用查询结果作为like模糊查询的参数" class="headerlink" title="sql语句中，用查询结果作为like模糊查询的参数"></a>sql语句中，用查询结果作为like模糊查询的参数</h3><p>需要拼接字符串，一开始我是使用 +  来进行拼接，但是没有拼接成功，然后使用concat函数，但是由于未用单引号将通配符括起来，所以还是错了，应该用单引号将通配符括起来</p>
<h3 id="从前端一次接受多个参数应该怎么做"><a href="#从前端一次接受多个参数应该怎么做" class="headerlink" title="从前端一次接受多个参数应该怎么做"></a>从前端一次接受多个参数应该怎么做</h3><p>有时候前端可能一次性将填写的多个同一类型的数据提交给后端，这个时候我们需要使用list接收数据，在使用list接收数据的时候，还需要使用<code>@RequestBody</code>这个注解。</p>
<p>将多个对象同时传入数据库，可以使用foreach来遍历。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>    insert into ApplyData (id, datatype, Idcard,      gettime, `name`, `rank`,      `group`, `code`, checkstatus,      checktime, checkpeople, IntoTime      )      values    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>       (#&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.datatype,jdbcType=INTEGER&#125;, #&#123;item.idcard,jdbcType=NVARCHAR&#125;,      #&#123;item.gettime,jdbcType=NVARCHAR&#125;, #&#123;item.name,jdbcType=VARCHAR&#125;, #&#123;item.rank,jdbcType=NVARCHAR&#125;,      #&#123;item.group,jdbcType=VARCHAR&#125;, #&#123;item.code,jdbcType=NVARCHAR&#125;, #&#123;item.checkstatus,jdbcType=NVARCHAR&#125;,      #&#123;item.checktime,jdbcType=TIMESTAMP&#125;, #&#123;item.checkpeople,jdbcType=NVARCHAR&#125;, #&#123;item.intotime,jdbcType=TIMESTAMP&#125;      )    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中collection是容器的类型，item是容器中的每一个对象的名字，separator是分隔符。</p>
<p><strong>注意只要将数据放在foreach中即可，我在增加的时候，不小心将values这个字段一同放在foreach中，结果插入第二条数据死活插入不进去，看了别人的foreach的用法才知道values应该放在外面</strong></p>
<h3 id="使用foreach查询数据"><a href="#使用foreach查询数据" class="headerlink" title="使用foreach查询数据"></a>使用foreach查询数据</h3><p>碰到一个需求，传过来一个string集合，然后根据string集合中的每一个元素去数据库查询相对应的数据。一看到参数是个集合，我就想到应该使用foreach来进行遍历，的确也是使用这个。</p>
<p>我以为查询和上面的插入是一样的，因此直接套用了上面插入的语法，但是发现死活都插不进去。后面打印了sql语句才知道问题。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDescribe&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;optioncode&quot;</span>&gt;</span>        select CodeNo,`Describe`,typename,count from OptionCode        where  CodeNo =        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>                  #&#123;item&#125;         <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这是最初的写法，可以发现foreach和上面的插入是一样的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql">[A01, A02, A03]Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3eed9c44] was not registered for synchronization because synchronization is not activeJDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@418882cf] will not be managed by Spring==&gt;  Preparing: select CodeNo,`Describe`,typename,count from OptionCode where CodeNo = ? , ? , ?==&gt; Parameters: A01(String), A02(String), A03(String)<br></code></pre></td></tr></table></figure>

<p>这是打印出来的sql语句，<strong>select CodeNo,<code>Describe</code>,typename,count from OptionCode where CodeNo = ? , ? , ?</strong>  我们发现语句是 xxx= xx,xx,xx   很明显，等号并没有这个作用，等号只能附一个值，也就是说只能是xxx=xx这种，所以我之前只传一个值的时候是可以查询到数据的。当后面的具有多个参数的时候，我们就想到应该使用in这个关键字，in后面可以是一个集合。</p>
<p>但是in的格式是 xxx in (xx,xx,xx),所以我们就需要给传过来的参数添加一对括号，因此，需要在foreach中进行修改。修改的代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">select CodeNo,`Describe`,typename,count from OptionCode        where  CodeNo in        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>                  #&#123;item&#125;         <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这是打印出来的sql语句</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql">[A01, A02, A03]Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6bd28c3b] was not registered for synchronization because synchronization is not activeJDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6d0e99e0] will not be managed by Spring==&gt;  Preparing: select CodeNo,`Describe`,typename,count from OptionCode where CodeNo in ( ? , ? , ? )==&gt; Parameters: A01(String), A02(String), A03(String)<br></code></pre></td></tr></table></figure>

<p>可以很明显的看见这里已经变成了in ,<strong>select CodeNo,<code>Describe</code>,typename,count from OptionCode where CodeNo in ( ? , ? , ? )</strong>  这样查询是可以查询到的。</p>
<h3 id="打印sql语句"><a href="#打印sql语句" class="headerlink" title="打印sql语句"></a>打印sql语句</h3><p>在application.yml中修改配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:  type-aliases-package:</span> <span class="hljs-string">com.hut.jsj.pojo,;com.hut.jsj.vo</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*</span>  <span class="hljs-comment">#加入下面这段代码  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure>





<h3 id="如何在PostMan中传递Date类型的数据"><a href="#如何在PostMan中传递Date类型的数据" class="headerlink" title="如何在PostMan中传递Date类型的数据"></a>如何在PostMan中传递Date类型的数据</h3><p>今天在做数据库课设的时候，在学生表中有一个字段是生日，建表的同学将该字段的类型设置为Date型（如果是我自己写的话，我是不会将这个设置为Date型的，设置成字符串型会更加方便）。在使用postman测试接口的时候，我发现直接输入<code>2000-9-17</code>这种数据是加不进去的，会报下面这个错误。</p>
<p>(图挂了)</p>
<p>大概的意思 就是String型的数据不能转换为Date型的数据。</p>
<p><strong>那么应该如何传递参数呢？</strong></p>
<p>我百度了一下，有的说需要设置全局变量等等，我觉得很麻烦，后面发现只需要改变一下传递的参数的格式即可。</p>
<p><code>2000/09/17</code>即可，也就是用<code>/</code>连接年月日。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>mysql</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2021/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h4><h5 id="数据结构的两个层次"><a href="#数据结构的两个层次" class="headerlink" title="数据结构的两个层次"></a>数据结构的两个层次</h5><p><strong>1.逻辑结构</strong></p>
<p>逻辑结构是描述元素之间的逻辑关系，与数据的存储无关，独立于计算机，是从具体问题抽象出来的数学模型。</p>
<a id="more"></a>

<p><strong>2.物理结构（存储结构）</strong></p>
<p>数据元素及其关系在计算机内存器中的结构（存储方式），是数据结构在计算机中的表示</p>
<p>==存储结构是逻辑关系的影响与元素本身的映像，逻辑结构是数据结构的抽象，存储结构是数据结构的实现。==</p>
<h5 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h5><ul>
<li>线性结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。<strong>如：线性表、栈、队列、串</strong></li>
<li>非线性结构：一个节点可能有多个直接前趋和直接后继，<strong>如：树，图</strong></li>
</ul>
<h5 id="存储结构的种类"><a href="#存储结构的种类" class="headerlink" title="存储结构的种类"></a>存储结构的种类</h5><ul>
<li>顺序存储结构：用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由关系的存储位置来表示</li>
<li>链式存储结构：用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</li>
<li>索引存储结构</li>
<li>散列存储结构</li>
</ul>
<h4 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h4><h5 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h5><p>对特定问题求解方法和步骤的一种描述，它是指令的有限序列，其中每个指令表示一个或多个操作。</p>
<h5 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h5><p>一个算法必须具备以下五个重要特性：</p>
<ul>
<li>有穷性：一个算法必须总是咋执行<strong>有穷步</strong>之后结束，且每一步都在有穷时间内完成。</li>
<li>确定性：算法中每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li>
<li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次实现。</li>
<li>输入：一个算法有零个或多个输入。</li>
<li>输出：一个算法有一个或多个输出。</li>
</ul>
<h5 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h5><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
</ul>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间，==大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的时间与算法中进行的简单操作次数乘积==。</p>
<p><strong>算法运行时间=一个简单操作所需的时间 X 简单操作次数</strong> </p>
<p>即 <strong>算法运行时间=∑每条语句频度X该语句执行一次所需的时间</strong></p>
<p>每条语句执行一次所需要的时间，一般是由机器而异的，与算法无关。所以我们可以假设执行每条语句所需要的时间均为单位时间，此时对算法的运行时间的讨论就可以转化为讨论该算法中所有语句的执行次数，即频度之和。</p>
<p>为了便于比较不同算法的时间效率，我们仅比较它们的数量级。</p>
<p>T(n)=O(f(n)),称O(f(n))为算法的渐进时间复杂度(O是数量级的符号)，简称时间复杂度。 </p>
<p>== 一般情况下，不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数==，它是问题规模n的某个函数，用T(n)来表示。  </p>
<h5 id="分析时间复杂度的基本方法"><a href="#分析时间复杂度的基本方法" class="headerlink" title="分析时间复杂度的基本方法"></a>分析时间复杂度的基本方法</h5><ol>
<li>找出语句频度最大的那条语句为基本语句</li>
<li>计算基本语句的频度得到问题规模n的某个函数f(n)</li>
<li>取其数量级用符号“o”表示。 </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">x=<span class="hljs-number">0</span>;                                                       <span class="hljs-number">1</span><br>y=<span class="hljs-number">0</span>;                                                       <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)                                       <span class="hljs-number">3</span><br>    x++;                                                   <span class="hljs-number">4</span>    <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)                                       <span class="hljs-number">5</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)                                   <span class="hljs-number">6</span><br>        y++;                                               <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p><strong>f(n)=n*(n+1) *<em>:6的执行频度为n+1   7的执行频度是n</em>(n+1)        ** T(n)=O(n²)</strong></p>
<p>==时间复杂度是由嵌套最深层语句的频度决定的==</p>
<h5 id="时间复杂度分类"><a href="#时间复杂度分类" class="headerlink" title="时间复杂度分类"></a>时间复杂度分类</h5><ul>
<li>最坏时间复杂度：指在最坏的情况下，算法的时间复杂度。</li>
<li>平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</li>
<li>最好时间复杂度：指在最好情况下，算法的时间复杂度。</li>
</ul>
<p>一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比他长。</p>
<h5 id="算法时间效率的比较"><a href="#算法时间效率的比较" class="headerlink" title="算法时间效率的比较"></a>算法时间效率的比较</h5><p>时间复杂度按数量级递增顺序为：</p>
<p><img src="https://i.loli.net/2021/06/25/paxo5K83Pq14ykh.png" alt="image-20210622205237015"></p>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>空间复杂度：算法所需存储空间的度量，记作： S(n)=O(f(n))，n为问题的规模</p>
<p>算法要占据的空间</p>
<ul>
<li>算法本身要占据的空间，输入、输出、指令、常数、变量等</li>
<li>算法要使用的辅助空间。</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><p>线性表是具有相同特性的元素的一个有限序列，(a1,a2,…ai-1,ai,ai+1,…,an)     ai-1称为ai的直接前趋，ai+1称为ai的直接后继。当n=0时称为空表。</p>
<p>==同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。==</p>
<h3 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h3><ol>
<li><strong>InitList(&amp;L)</strong><ul>
<li>操作结果：构造一个空的线性表L。</li>
</ul>
</li>
<li><strong>DestroyList(&amp;L)</strong><ul>
<li>初始条件：线性表L已经存在。</li>
<li>操作结果：销毁线性表L。</li>
</ul>
</li>
<li><strong>ClearList(&amp;L)</strong><ul>
<li>初始条件：线性表L已经存在。</li>
<li>操作结果：将线性表L重置为空表。</li>
</ul>
</li>
<li><strong>ListEmpty(L)</strong><ul>
<li>初始条件：线性表L已经存在。</li>
<li>操作结果：若线性表L为空，则返回True，否则返回False。</li>
</ul>
</li>
<li><strong>ListLength(L)</strong><ul>
<li>初始条件：线性表L已经存在。</li>
<li>操作结果：返回线性表L中的数据元素个数。</li>
</ul>
</li>
<li><strong>GetElem(L,i,&amp;e)</strong><ul>
<li>初始条件：线性表L已经存在,1&lt;=i&lt;=ListLength(L)。</li>
<li>操作结果，用E返回线性表L中第i个数据元素的值。</li>
</ul>
</li>
<li><strong>LocateElem(L,e,compare())</strong><ul>
<li>初始条件：线性表L已经存在,compare()是数据元素判定函数。</li>
<li>操作结果：返回L中第1个与e满足compare()的数据元素的位序，若这样的数据元素不存在则返回值为0。</li>
</ul>
</li>
</ol>
<p>………</p>
<h3 id="顺序表的表示和实现"><a href="#顺序表的表示和实现" class="headerlink" title="顺序表的表示和实现"></a>顺序表的表示和实现</h3><p>线性表顺序存储结构占有一片连续的存储空间，知道某个元素的存储位置就可以计算其他元素的存储位置。</p>
<p>顺序表的特点：==以物理位置相邻表示逻辑关系，任意元素均可随机存取（优点）==，这种存取元素的方法叫做<strong>随机存取法</strong></p>
<p><img src="https://i.loli.net/2021/06/25/3j6CeI5b7ZdtYnp.png" alt="image-20210623102638413"></p>
<p> 假设线性表的每个元素需占m个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：</p>
<p>​                                                            <strong>LOC(ai+1)=LOC(ai)+m</strong></p>
<p><img src="https://i.loli.net/2021/06/25/i7oXZafVPcKBUGH.png" alt="image-20210623103523630"></p>
<p>使用一维数组表示顺序表，由于数组长度不可以动态定义，因此我们用一个变量表示顺序表的长度属性。</p>
<h5 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h5><p>顺序表的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> LIST_INT_SIZE 100   <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType elem[LIST_INIT_SIZE];   <span class="hljs-comment">//定义一个指定长度的数组，ElemType是数据类型，如INT,FLOAT.</span><br>    <span class="hljs-keyword">int</span> length;    <span class="hljs-comment">//当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure>

<h5 id="顺序表示意图"><a href="#顺序表示意图" class="headerlink" title="顺序表示意图"></a>顺序表示意图</h5><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210625201628543.png"></p>
<h4 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627131242504.png" alt="image-20210627131242504"></p>
<p><strong>其中橙色部分的为重点操作</strong></p>
<h5 id="顺序表的基本操作实现"><a href="#顺序表的基本操作实现" class="headerlink" title="顺序表的基本操作实现"></a>顺序表的基本操作实现</h5><p>操作算法中用到的预定义常量和类型</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210625202130788.png" alt=" "></p>
<h6 id="初始化线性表"><a href="#初始化线性表" class="headerlink" title="初始化线性表"></a>初始化线性表</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">status <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;					<span class="hljs-comment">//构造一个空的顺序表L</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE];             <span class="hljs-comment">//为顺序表分配空间</span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW); 				<span class="hljs-comment">//存储分配失败</span><br>    L.length = <span class="hljs-number">0</span>;                               <span class="hljs-comment">//空表长度为0</span><br>    renturn OK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="销毁线性表"><a href="#销毁线性表" class="headerlink" title="销毁线性表"></a>销毁线性表</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L.elem) <span class="hljs-keyword">delete</span> L.elem;     <span class="hljs-comment">//释放内存空间</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="清空线性表"><a href="#清空线性表" class="headerlink" title="清空线性表"></a>清空线性表</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    L.length=<span class="hljs-number">0</span>;          <span class="hljs-comment">//将线性表的长度设置为0</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="求线性表的长度"><a href="#求线性表的长度" class="headerlink" title="求线性表的长度"></a>求线性表的长度</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (L.length);<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="判断线性表是否为空"><a href="#判断线性表是否为空" class="headerlink" title="判断线性表是否为空"></a>判断线性表是否为空</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="顺序表取值（根据位置i获取相应位置数据元素的内容）"><a href="#顺序表取值（根据位置i获取相应位置数据元素的内容）" class="headerlink" title="顺序表取值（根据位置i获取相应位置数据元素的内容）"></a>顺序表取值（根据位置i获取相应位置数据元素的内容）</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//判断i的值是否合理</span><br>    e=L.elem[i<span class="hljs-number">-1</span>];    <span class="hljs-comment">//将第i个位置的元素赋值给e</span><br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="顺序表的查找（在线性表中查找与指定值e相同的数据元素的位置）"><a href="#顺序表的查找（在线性表中查找与指定值e相同的数据元素的位置）" class="headerlink" title="顺序表的查找（在线性表中查找与指定值e相同的数据元素的位置）"></a>顺序表的查找（在线性表中查找与指定值e相同的数据元素的位置）</h6><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++)<br>        <span class="hljs-keyword">if</span>(L.length[i]==e)   <span class="hljs-comment">//元素进行对比</span><br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    <span class="hljs-comment">//查找成功则返回序号</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">//查找失败，返回0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>平均查找长度：ASL=（n+1)/2 ，时间复杂度T(n)=O(n)</strong></p>
<h6 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h6><p>算法思想：</p>
<ul>
<li>插入位置i是否合法，只能在0~L.length之间，即第1个位置和第length+1个位置。</li>
<li>判断顺序表的存储空间是否已满，若已满返回ERROR。</li>
<li>将第L.length至第i位的元素依次向后移动一个位置，将第i个位置空出来。</li>
<li>将要插入的新元素e放入第i个位置</li>
<li>表长+1，插入成功返回OK</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//判断插入位置是否合理</span><br>    <span class="hljs-keyword">if</span>(L.length==MAXSIZE) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//判断顺序表的存储空间是否已满</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>;j&gt;=i<span class="hljs-number">-1</span>j;--)         <span class="hljs-comment">//将数据依次后移</span><br>    &#123;<br>        L.elem[j+<span class="hljs-number">1</span>]=L.elem[j];<br>    &#125;<br>    L.elem[i<span class="hljs-number">-1</span>]=e;          <span class="hljs-comment">//赋值，插入数据</span><br>    L.length++;            <span class="hljs-comment">//表长+1 </span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>平均移动长度：ASL=n/2，时间复杂度T(n)=O(n)</strong></p>
<h6 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h6><p>线性表的删除运算是指将表的第i(1&lt;=i&lt;=n)个节点删除，使长度为n的线性表变成长度为n-1的线性表。</p>
<p>算法思想：</p>
<ul>
<li>判断删除位置是否合法。（合法值为1&lt;=i&lt;=n)</li>
<li>将欲删除的元素保留在e中。</li>
<li>将第i+1至第n位元素依次向前移动一个位置</li>
<li>表长-1，删除成功返回OK。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//i的值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length;j++)&#123;<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];      <span class="hljs-comment">//被删除元素之后的元素前移</span><br>    &#125;<br>    L.length--;                 <span class="hljs-comment">//表长减1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>平均移动长度：(n-1)/2，时间复杂度T(N)=O(n)</strong></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><strong>顺序表的优点：</strong></p>
<ul>
<li>存储密度大（存储密度=结点本身所占存储量/结点结构所占存储量），顺序表的存储密度为1。</li>
<li>可以随机存取表中任一元素。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在插入、删除某一元素时，需要移动大量元素。</li>
<li>浪费存储空间（需要预先分配空间，很多空间可能没有用到）</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充。</li>
</ul>
<h4 id="补充C和C-的知识"><a href="#补充C和C-的知识" class="headerlink" title="补充C和C++的知识"></a>补充C和C++的知识</h4><p>定义顺序表</p>
<p>数组静态分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> LIST_INT_SIZE 100   <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType elem[LIST_INIT_SIZE];   <span class="hljs-comment">//定义一个指定长度的数组，ElemType是数据类型，如INT,FLOAT.</span><br>    <span class="hljs-keyword">int</span> length;    <span class="hljs-comment">//当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure>

<p>数组动态分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *data;   <span class="hljs-comment">//这里是一个指针变量，指的是数组的第一个元素</span><br>    <span class="hljs-keyword">int</span> length;<br>&#125;SqList  <span class="hljs-comment">//顺序表类型</span><br>    <br><span class="hljs-comment">//动态分配空间</span><br>    SqList L;  <span class="hljs-comment">//定义一个顺序表L</span><br>	L.data=(ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);  <span class="hljs-comment">//使用malloc函数动态分配空间</span><br></code></pre></td></tr></table></figure>

<h5 id="C语言内存分配函数"><a href="#C语言内存分配函数" class="headerlink" title="C语言内存分配函数"></a>C语言内存分配函数</h5><p>需要加载头文件<code>&lt;stdlib.h&gt;</code></p>
<ul>
<li>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址。</li>
<li>sizeof(x)运算，计算变量x的长度,即占几个字节。</li>
<li>free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量。</li>
</ul>
<h5 id="C-动态存储分配"><a href="#C-动态存储分配" class="headerlink" title="C++动态存储分配"></a>C++动态存储分配</h5><p><code>new l类型名T（初值列表）</code></p>
<p>功能：申请用于存放T类型对象的内存空间，并依初值赋以初值</p>
<p>结果值：</p>
<p>​    成功：T类型的指针，指向新分配的内存。</p>
<p>​    失败：0（NULL)</p>
<p><code>int *p1 = new int ;</code>  从内存开辟一个空间放一个int型变量，返回一个地址。</p>
<p><code>int *p1 = new int(10);</code> 从内存开辟一个空间放10个int型变量，返回一个地址。</p>
<h3 id="链表的表示和实现"><a href="#链表的表示和实现" class="headerlink" title="链表的表示和实现"></a>链表的表示和实现</h3><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>链式存储结构：结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</p>
<p>线性表的链式表示又称为非顺序映像或链式映像。</p>
<p>用一组<strong>物理位置任意的存储单元</strong>来存放线性表的数据元素。</p>
<p>这组存储单元既可以是<strong>连续</strong>的，也可以是<strong>不连续</strong>的，甚至是零散分布在内存中的任意位置上的。</p>
<p>链表中元素的<strong>逻辑次序和物理次序不一定相同</strong>。</p>
<h4 id="与链式存储相关的术语"><a href="#与链式存储相关的术语" class="headerlink" title="与链式存储相关的术语"></a>与链式存储相关的术语</h4><p><strong>1、结点：</strong>数据元素的存储映像。链表的各个结点由两部分组成：<strong>数据域和指针域</strong>，数据域用来存储数值数据，指针域用来存储直接后继结点的存储位置。</p>
<p><strong>2、链表：</strong>n个结点由指针链组成一个链表。</p>
<p><strong>3、单链表、双链表、循环链表：</strong></p>
<ul>
<li>结点只有一个指针域的链表成为<strong>单链表</strong>或<strong>线性链表</strong>，指针域存储直接后继结点的地址，并且尾结点的指针域为NULL。</li>
<li>结点由两个指针域的链表称为<strong>双链表</strong>，第一个指针域存储前一个结点的地址，后一个指针域存储下一个结点的地址，尾结点的指针域为NULL。</li>
<li>首尾相连的链表称为<strong>循环链表</strong>，尾指针的指针域存储首节点的地址。</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627134652130.png" alt="image-20210627134652130"></p>
<p><strong>4、头指针、头结点和首元结点：</strong></p>
<ul>
<li>头指针：指向链表第一个结点的指针，是个指针，没有数据域。</li>
<li>首元结点：链表中第一个存储数据元素的结点。</li>
<li>头结点，为了方便在首元结点前附设的一个结点，有数据域和指针域，但是数据域不保存数据，指针域指向首元结点的地址。</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627135040727.png" alt="image-20210627135040727"></p>
<blockquote>
<p>既然设不设置头结点都可以，为什么要设置头结点呢？设置头结点有什么好处？</p>
</blockquote>
<p>1.便于首元结点的处理。</p>
<p>如果没有头结点，那个首元结点的地址就由头指针指向，而有了头指针，那么首元结点的地址就保存在头结点的指针域中，可以直接由头结点指向，与后面的结点操作一直，不用进行特殊处理。</p>
<p>2.便于空表和非空表的统一处理</p>
<p>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也一致了。</p>
<blockquote>
<p>头结点的数据域内存什么信息</p>
</blockquote>
<p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但是这个节点不计入链表的长度。</p>
<h4 id="链式存储结构的特点"><a href="#链式存储结构的特点" class="headerlink" title="链式存储结构的特点"></a>链式存储结构的特点</h4><ol>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</li>
<li>正是因为存储位置是任意的，因此不能像顺序表中直接访问某一结点。访问时必须从头指针开始进入链表，并通过每一个结点的指针域找到下一个结点，依次扫描，所以寻找第一个节点和最后一个节点所花费的时间不等。 这种存取元素的方法叫做<strong>顺序存取法。</strong></li>
</ol>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>带头结点的单链表</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627141240817.png" alt="image-20210627141240817"></p>
<h5 id="单链表的类型定义"><a href="#单链表的类型定义" class="headerlink" title="单链表的类型定义"></a>单链表的类型定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span>&#123;</span>         <span class="hljs-comment">//声明结点的类型和指向结点的指针类型     </span><br>    ElemType data;           <span class="hljs-comment">//结点的数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Londe</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">//结点的指针域</span><br>&#125;LNode,*LinkList;          <span class="hljs-comment">//LinkList为指向结构体Londe类型的指针类型</span><br></code></pre></td></tr></table></figure>

<p> <strong>定义链表：</strong><code>LinkList L;</code></p>
<p><strong>定义结点指针P：</strong><code>LNode *p;</code>  或者<code>LinkList p;</code></p>
<h5 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h5><p><img src="/.com//blog\数据结构\image-20210627155835316.png" alt="image-20210627155835316"></p>
<h6 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h6><p>算法步骤：</p>
<ul>
<li>生成的新结点作为头结点，用头指针L指向头结点。</li>
<li>将头结点的指针域置空。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L=(LinkList) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));   <span class="hljs-comment">//根据LNode的内存大小动态分配一个空间，返回空间地址，也可以使用C++:L=new LNode;生成头结点。</span><br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h6><p>链表中无元素，称为空链表（头指针和头结点还在）</p>
<p>算法思路：判断头结点的指针域是否为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;   <span class="hljs-comment">//判断链表是否为空，是返回2，不是返回0；L是头指针，直接指向了头结点。</span><br>   <span class="hljs-keyword">if</span>(L-&gt;next)<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="销毁单链表"><a href="#销毁单链表" class="headerlink" title="销毁单链表"></a>销毁单链表</h6><p>链表销毁后不存在（头结点不存在）</p>
<p>算法思路：从头指针开始，依次释放所有结点。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627151613026.png" alt="image-20210627151613026"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">DestroyList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    LinkList p;   <span class="hljs-comment">//或LNode *p  定义一个指针，用来存储当前结点。</span><br>    <span class="hljs-keyword">while</span>(L)&#123;     <span class="hljs-comment">//判断是否到达链表尾部</span><br>        p=L;      <span class="hljs-comment">//将当前结点赋值给p</span><br>        L=L-&gt;next;  <span class="hljs-comment">//L指向下一个结点，向后移动一位</span><br>        <span class="hljs-built_in">free</span>(p);    <span class="hljs-comment">//释放当前节点的空间  也可以使用delete(new 出来的结点用delete，malloc的用free)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h6><p>链表仍存在，但是链表中没有元素，成为空链表（头指针和头结点仍然存在）</p>
<p>算法思路：依次释放所有结点，并将头结点的指针域设置为空。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627153059520.png" alt="image-20210627153059520"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    LNode *p,*q;            <span class="hljs-comment">//定义两个辅助指针结点</span><br>    p=L-&gt;next;              <span class="hljs-comment">//使p指向首元结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;              <span class="hljs-comment">//判断链表是否到达尾结点</span><br>        q=p-&gt;next;         <span class="hljs-comment">//将当前结点的下一结点赋给q，释放当前结点后还可以找到下一结点</span><br>        <span class="hljs-built_in">free</span>(p);           <span class="hljs-comment">//释放当前结点的空间</span><br>        p=q;               <span class="hljs-comment">//p指向当前结点的下一结点</span><br>    &#125;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;      <span class="hljs-comment">//将头结点的指针域设置为NULL。</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="求链表的表长"><a href="#求链表的表长" class="headerlink" title="求链表的表长"></a>求链表的表长</h6><p>算法思路：从首元结点开始，依次计数所有结点。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20210627154551676.png" alt="image-20210627154551676"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    LinkList p;<br>    p=L-&gt;next;                <span class="hljs-comment">//p指向首元结点</span><br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;                <span class="hljs-comment">//定义长度</span><br>    <span class="hljs-keyword">while</span>(p)&#123;              <span class="hljs-comment">//判断是否到达链表尾部</span><br>        p=p-&gt;next;        <span class="hljs-comment">//将p指向当前结点的下一结点</span><br>        t++;             <span class="hljs-comment">//长度+1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="取值——取第i个元素的内容"><a href="#取值——取第i个元素的内容" class="headerlink" title="取值——取第i个元素的内容"></a>取值——取第i个元素的内容</h6><p><strong>算法步骤：</strong></p>
<p>1.从第一个节点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值 p=L-&gt;next。</p>
<p>2.j做计数器，累计当前扫描过的结点数，j初值为1。</p>
<p>3.当p指向扫描到的下一结点时，计数器j加1。</p>
<p>4.当j==i时，p所指的结点就是要找的第i个结点。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;  <br>    LinkList p;  <br>    p=L-&gt;next;           <span class="hljs-comment">//p指向首元结点</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;       <span class="hljs-comment">//向后扫描，直到p指向第i个元素或者p到达链表尾部</span><br>        p=p-&gt;next;       <span class="hljs-comment">//p指向下一个结点</span><br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j==i)&#123;           <span class="hljs-comment">//如果j==i，说明找到了第i个元素。</span><br>        e=p-&gt;data;<br>    	<span class="hljs-keyword">return</span> OK;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br></code></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>注解和反射</title>
    <url>/2021/04/12/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解的作用就是负责注解其他注解，java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型做说明。</p>
<ul>
<li>@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li>
<li>@Retention：表示需要在什么级别保存该注解信息，用户描述注解的生命周期（source&lt;class&lt;runtime)</li>
<li>@Document：说明该注解将包含在javadoc中</li>
<li>@Inherited：说明子类可以继承父类中的该注解</li>
</ul>
<a id="more"></a>

<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p><strong>使用@Interface自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;i<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//因为age已经有了默认值，可以不用再赋值，如果只有一个参数，还可以直接省略前面你的参数名，直接写参数</span><br>    <span class="hljs-meta">@MyAnnotation(name=&quot;pty&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//表示这个注解我们可以用在哪些地方，type表示类，method表示方法，field表示属性</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-comment">//表示这个注解在什么地方还有效</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>    <span class="hljs-comment">//注解的参数： 参数类型+参数名();</span><br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span>  12</span>;  <span class="hljs-comment">//还可以使用default &quot;xxx&quot; 设置默认值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>反射是java被视为动态语言的关键，反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</strong></p>
<p>实际上，我们创建的每一个类都是对象。在加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象，这个类对象包含了完成的类的结构信息。我们可以通过这个对象看到类的结构。</p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/20170513133210763.png" alt="img"></p>
<h4 id="获得反射对象"><a href="#获得反射对象" class="headerlink" title="获得反射对象"></a>获得反射对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mp.demo.reflection;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//通过反射过去类的Class对象， 使用.forname()方法，参数为实体类的包名+类名</span><br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.mp.demo.reflection.User&quot;</span>);<br>        System.out.println(c1);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>一个类只能有一个Class对象</strong>‘’</p>
<h4 id="Class类常用的方法"><a href="#Class类常用的方法" class="headerlink" title="Class类常用的方法"></a>Class类常用的方法</h4><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210411194627729.png" alt="image-20210411194627729"></p>
<h4 id="获得Class类对象"><a href="#获得Class类对象" class="headerlink" title="获得Class类对象"></a>获得Class类对象</h4><ul>
<li>已经知道具体的类，通过类的Class属性获取。推荐使用这种，这种最为安全可靠，程序性能高</li>
</ul>
<p><code>Class c = User.class;</code> </p>
<ul>
<li>已经有某个类的具体对象，需要获取这个类的Class对象，可以调用这个具体对象的getClass方法</li>
</ul>
<p><code>Class c = user.getClass()</code>  user是User类具体的对象</p>
<ul>
<li>知道一个类的全类名（包名+类名）,且该类在类路径下，可以通过Class类的静态方法forName()获取，但是可能会抛出异常。</li>
</ul>
<p><code>Class c1 = Class.forName(&quot;com.mp.demo.reflection.User&quot;);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mp.demo.reflection;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//通过.class 方法获取实例</span><br>        Class cl = User.class;<br>        System.out.println(cl);<br><br>        <span class="hljs-comment">//通过具体对象调用getClass方法创建class实例</span><br>        User user = <span class="hljs-keyword">new</span> User();<br>        Class c2 = user.getClass();<br>        System.out.println(c2);<br><br>        <span class="hljs-comment">//使用全类名创建class对象</span><br>        Class c3 = Class.forName(<span class="hljs-string">&quot;com.mp.demo.reflection.User&quot;</span>);<br>        System.out.println(c3);<br><br>        <span class="hljs-comment">//获取父类的class对象</span><br>        Class c4 = c2.getSuperclass();<br>        System.out.println(c4);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="类加载器（JVM-目前先了解）"><a href="#类加载器（JVM-目前先了解）" class="headerlink" title="类加载器（JVM   目前先了解）"></a>类加载器（JVM   目前先了解）</h4><p>作用：将class文件字节码内容加载到内存中，并将这些景泰数据转换成为方法区的运行时的数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210411214155426.png" alt="image-20210411214155426"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//获取系统类的加载器</span><br>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br><br>        <span class="hljs-comment">//获取系统类加载器得到父类加载器-&gt;拓展类加载器</span><br>        ClassLoader parent = systemClassLoader.getParent();<br>        System.out.println(parent);<br><br>        <span class="hljs-comment">//获取拓展类加载器的父类加载器-&gt;根加载器（c/c++)   根（引导类）加载器无法读取到</span><br>        ClassLoader parent1 = parent.getParent();<br>        System.out.println(parent1);<br><br><br>        <span class="hljs-comment">//测试当前类是哪个加载器加载的</span><br>        ClassLoader classLoader = User.class.getClassLoader();<br>        System.out.println(classLoader);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210411215250373.png" alt="image-20210411215250373"></p>
<h4 id="获取运行时类的完整结构（方法，属性，类名，构造器…"><a href="#获取运行时类的完整结构（方法，属性，类名，构造器…" class="headerlink" title="获取运行时类的完整结构（方法，属性，类名，构造器….)"></a>获取运行时类的完整结构（方法，属性，类名，构造器….)</h4><p>==获取属性和方法、构造器的方法有两种，一种是没加Declared的，一种是加了Declared的。前者只能获取到公共的属性、方法和构造器（即由public修饰的），后者可以获取到所有的，包括被private、protected修饰的==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;<br>        <span class="hljs-comment">//获取user类对象</span><br>        Class c1 = User.class;<br><br>        System.out.println(<span class="hljs-string">&quot;=================名字========================&quot;</span>);<br><br>        <span class="hljs-comment">//获取类的名字</span><br>        String name = c1.getName();  <span class="hljs-comment">//获取类的包名+类名</span><br>        String name1 = c1.getSimpleName();  <span class="hljs-comment">//获取类的类名</span><br>        System.out.println(name);<br>        System.out.println(name1);<br><br>        System.out.println(<span class="hljs-string">&quot;=================属性========================&quot;</span>);<br><br>        <span class="hljs-comment">//获得类的属性</span><br>        Field[] fields = c1.getDeclaredFields();  <span class="hljs-comment">//获得所有的属性</span><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field);<br>        &#125;<br><br>        Field name2 = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);   <span class="hljs-comment">//获取指定的属性</span><br>        System.out.println(name2);<br><br>        System.out.println(<span class="hljs-string">&quot;=================方法========================&quot;</span>);<br><br>        <span class="hljs-comment">//获取类的方法</span><br>        Method[] declaredMethods = c1.getDeclaredMethods();  <span class="hljs-comment">//获取所有的方法</span><br>        <span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>            System.out.println(declaredMethod);<br>        &#125;<br>        <span class="hljs-comment">//获取指定的方法,参数1是方法名，参数二是参数的类型，没有参数填写null</span><br>        <span class="hljs-comment">//为什么要填写参数类型，因为java存在重载</span><br>        Method setName = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        System.out.println(setName);<br><br>        System.out.println(<span class="hljs-string">&quot;=================构造器========================&quot;</span>);<br><br>        Constructor[] declaredConstructors = c1.getDeclaredConstructors();  <span class="hljs-comment">//获取所有的构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor declaredConstructor : declaredConstructors) &#123;<br>            System.out.println(declaredConstructor);<br>        &#125;<br>		<span class="hljs-comment">//此处的参数的类型必须和构造器的参数类型一样。由于我使用了@AllArgsConstructor注解，因此含所有参数的构造器的参数类型的顺序与你定义属性时的顺序一样</span><br>        Constructor declaredConstructor = c1.getDeclaredConstructor(<span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">int</span>.class);<br>        System.out.println(declaredConstructor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210411222729261.png" alt="image-20210411222729261"></p>
<h4 id="动态创建对象、调用方法、操作属性"><a href="#动态创建对象、调用方法、操作属性" class="headerlink" title="动态创建对象、调用方法、操作属性"></a>动态创建对象、调用方法、操作属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException, NoSuchFieldException </span>&#123;<br>        Class c1 = User.class;<br><br>        <span class="hljs-comment">//直接使用newInstance()方法，调用的是无参构造器，如果没有无参构造器，会报错</span><br>        Object user = c1.newInstance();<br>        System.out.println(user);<br><br>        System.out.println(<span class="hljs-string">&quot;=================构造器======================&quot;</span>);<br>        <span class="hljs-comment">//通过构造器创建实例</span><br>        <span class="hljs-comment">//通过Class对象获取构造器</span><br>        Constructor constructor = c1.getDeclaredConstructor(<span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">int</span>.class);<br>        User user1 = (User) constructor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pty&quot;</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">//通过构造器创建实例，参数为构造器所需的具体的值</span><br>        System.out.println(user1);<br><br>        System.out.println(<span class="hljs-string">&quot;====================调用普通方法=================&quot;</span>);<br><br>        <span class="hljs-comment">//获取普通方法</span><br>        Method setName = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        setName.invoke(user1, <span class="hljs-string">&quot;彭天怡&quot;</span>);   <span class="hljs-comment">//通过invoke()方法激活方法，第一个参数为执行的对象，第二个是方法需要的具体参数</span><br>        System.out.println(user1);<br><br>        System.out.println(<span class="hljs-string">&quot;===================操作属性=====================&quot;</span>);<br><br>        <span class="hljs-comment">//获取属性</span><br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//因为name设置为私有属性，因此不能被外界访问到，使用setAccessible(true)可以使其被访问</span><br>        name.setAccessible(<span class="hljs-keyword">true</span>);<br>        name.set(user1,<span class="hljs-string">&quot;pty1&quot;</span>); <span class="hljs-comment">//设置属性</span><br>        name.get(user1);<br>        System.out.println(user1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">User(id=<span class="hljs-number">0</span>, name=<span class="hljs-keyword">null</span>, age=<span class="hljs-number">0</span>)<br>==============================构造器===============================<br>User(id=<span class="hljs-number">1</span>, name=pty, age=<span class="hljs-number">12</span>)<br>==============================调用普通方法===============================<br>User(id=<span class="hljs-number">1</span>, name=彭天怡, age=<span class="hljs-number">12</span>)<br>==============================操作属性===============================<br>User(id=<span class="hljs-number">1</span>, name=pty1, age=<span class="hljs-number">12</span>)<br><br>Process finished with exit code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>如果实体类没有无参构造，不能直接使用newInstance()方法，会报错，应该使用构造器来创建对象</li>
<li>使用<code>构造器.newInstance()</code>创建对象时，参数为构造器具体需要的值</li>
<li>获取到方法后，通过<code>方法.invoke()</code>来激活方法，第一个参数为执行方法的对象，第二个是方法所需的参数。</li>
<li>由于私有方法和私有属性不能被直接操作，因此需要在操作前使用<code>setAccessibel(true)</code>方法，这样就可以操作private修饰的方法和属性了。（setAccessibel(true) 也称为暴力忽略）</li>
<li><code>getMathod()</code>和<code>getField()</code>不仅可以获取到本类的方法和属性，还可以获取到从父类继承的方法和属性。</li>
</ul>
<h4 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,User&gt; <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>        <span class="hljs-comment">//获取Class对象</span><br>        Class c1 = Test.class;<br>        <span class="hljs-comment">//获取具体的方法</span><br>        Method test1 = c1.getDeclaredMethod(<span class="hljs-string">&quot;test1&quot;</span>, Map.class, List.class);<br>        <span class="hljs-comment">//getGenericParameterTypes()返回一个Type对象数组，获取方法的形参类型，如果参数是泛型，将会返回完整的泛型信息</span><br>        Type[] genericParameterTypes = test1.getGenericParameterTypes();<br>        <span class="hljs-keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;<br>            System.out.println(genericParameterType);<br>            <span class="hljs-comment">//判断参数类型是否属于参数化类型（只要是泛型，且不是数组和本类上定义的泛型）</span><br>            <span class="hljs-keyword">if</span>(genericParameterType <span class="hljs-keyword">instanceof</span> ParameterizedType)&#123;<br>                <span class="hljs-comment">//将genericParameterTyp强转为ParameterizedType类型，并且调用getActualTypeArguments()方法获取参数化类型中的实际参数</span><br>                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();<br>                <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>                    System.out.println(actualTypeArgument);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=============方法返回值的泛型============&quot;</span>);<br>        <span class="hljs-comment">//操作与获取上面方法的参数类型一致，不同的是获取的是返回值的参数类型 getGenericReturnType()</span><br>        Method test2 = c1.getDeclaredMethod(<span class="hljs-string">&quot;test2&quot;</span>, <span class="hljs-keyword">null</span>);<br>        Type genericReturnType = test2.getGenericReturnType();<br>        System.out.println(genericReturnType);<br>        <span class="hljs-keyword">if</span>(genericReturnType <span class="hljs-keyword">instanceof</span>  ParameterizedType)&#123;<br>            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();<br>            <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>                System.out.println(actualTypeArgument);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.util.Map&lt;java.lang.String, com.mp.demo.reflection.User&gt;  <span class="hljs-comment">//获得了完整的泛型信息</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span>    //获得了泛型里面具体的参数类型</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">mp</span>.<span class="hljs-title">demo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br><span class="hljs-class"><span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">mp</span>.<span class="hljs-title">demo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">mp</span>.<span class="hljs-title">demo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br><span class="hljs-class"></span>=============方法返回值的泛型============<br>java.util.Map&lt;java.lang.String, com.mp.demo.reflection.User&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">mp</span>.<span class="hljs-title">demo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br></code></pre></td></tr></table></figure>

<h4 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h4><p><strong>User类 + 自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Table(&quot;用户表&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-meta">@FieldUser(columnName = &quot;id&quot;,type = &quot;int&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-meta">@FieldUser(columnName = &quot;name&quot;,type = &quot;String&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@FieldUser(columnName = &quot;age&quot;,type = &quot;int&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>&#125;<br><br><span class="hljs-comment">//自定义注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Table&#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> FieldUser&#123;<br>    <span class="hljs-function">String <span class="hljs-title">columnName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br>        Class c1 = User.class;<br>        <span class="hljs-comment">//获取类全部的注解</span><br>        Annotation[] annotations = c1.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(annotation);<br>        &#125;<br><br>        <span class="hljs-comment">//获取类特定的注解,并强转为特定的类型</span><br>        Table annotation = (Table) c1.getAnnotation(Table.class);<br>        String value = annotation.value();<br>        System.out.println(value);<br><br>        <span class="hljs-comment">//获取属性特定的注解</span><br>        <span class="hljs-comment">//先获取属性</span><br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//获取属性的注解，这里不需要进行强转，已经是FieldUser类了</span><br>        FieldUser annotation1 = name.getAnnotation(FieldUser.class);<br>        <span class="hljs-comment">//获取注解的值</span><br>        System.out.println(annotation1.columnName());<br>        System.out.println(annotation1.type());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>==只有当注解的@Retention=RUNTIME时，才能在反射中被获取到==</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/09/08/Mysql/</url>
    <content><![CDATA[<h2 id="数据库开发语言SQL"><a href="#数据库开发语言SQL" class="headerlink" title="数据库开发语言SQL"></a>数据库开发语言SQL</h2><p>SQL是一种数据库查询和设计语言，主要用于存取数据，查询数据，更新数据和管理关系数据库系统。</p>
<p>SQL语言分为3个部分，即数据定义语言（DDL），数据操作语言(DML)，和数据控制语言(DCL)</p>
<a id="more"></a>

<ul>
<li><p>DDL</p>
<p>用于定义数据库、表、视图、索引、触发器等。其中包括create语句(创建数据库、表、视图)，alter语句(修改表。视图)，drop语句(删除数据库、表、视图)</p>
</li>
<li><p>DML</p>
<p>增删改查数据，包括select，update，delete，insert</p>
</li>
<li><p>DCL</p>
<p>数据完整控制，数据安全性控制和数据库的恢复等，具体如授权(GRANT)、回滚（ROLLBACK）、提交(CONMMIT)</p>
</li>
</ul>
<h2 id="mysql在命令行操作数据库"><a href="#mysql在命令行操作数据库" class="headerlink" title="mysql在命令行操作数据库"></a>mysql在命令行操作数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> database_name;         //database_name是所要创建的数据库的名字<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;                       //查询所有的数据库<br><span class="hljs-keyword">use</span> database_name;                    //使用（选择）数据库，database_name是你要用的数据库的名字<br><span class="hljs-keyword">drop</span> datebase database_name;          //删除数据库，首先要确定这个数据库存在才能删除<br></code></pre></td></tr></table></figure>



<h2 id="数据表的设计理念"><a href="#数据表的设计理念" class="headerlink" title="数据表的设计理念"></a>数据表的设计理念</h2><h3 id="1-数据表包含列，索引和触发器"><a href="#1-数据表包含列，索引和触发器" class="headerlink" title="1.数据表包含列，索引和触发器"></a>1.数据表包含列，索引和触发器</h3><pre><code>+ 列：也称为栏位，对于属性列，创建表时必须指定列的名字和数据类型
+ 索引：根据指定的数据库表列建立起来的顺序，提供了快速访问数据的途径。
+ 触发器：用户定义的事务命令的集合。</code></pre>
<h3 id="2-数据表的设计需要遵循三范式"><a href="#2-数据表的设计需要遵循三范式" class="headerlink" title="2.数据表的设计需要遵循三范式"></a>2.数据表的设计需要遵循三范式</h3><ul>
<li><p>第一范式：确保每列保持原子性</p>
<p>数据库的每一列都是不可分割的原子数据项，而不能是集合、数组、记录等非原子数据项</p>
</li>
</ul>
<ul>
<li><p>第二范式：确保每列都和主键相关</p>
<p>满足第二范式必须先满足第一范式，第二范式要求实体的属性完全依赖主关键字。如果不存在依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p>
<p>多对多，三张表，关系表两个外键。（关系表用来连接另外两张表）</p>
</li>
<li><p>第三范式：确保每列都和主键列直接相关，而不是间接相关。</p>
<p>满足第三范式必须先满足第二范式，要求一个关系中不包含已在其他关系中包含的非主关键字信息</p>
<p>一对多两张表，多的表加外键 。</p>
</li>
</ul>
<p>可以参考这篇博客，我觉得写得很详细。<a href="https://blog.csdn.net/kenhins/article/details/51084815?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-51084815.nonecase&utm_term=%E5%BB%BA%E8%A1%A8%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F">三范式</a></p>
<h3 id="3-表和表的关系"><a href="#3-表和表的关系" class="headerlink" title="3.表和表的关系"></a>3.表和表的关系</h3><p>数据库里表和表的关系有3种：一对一，一对多，多对多。</p>
<ul>
<li>一对一：主表和相关联的表是一一对应的。比如学生信息表和学生成绩表，可以根据学生信息表中学生的id在学生成绩表中找到唯一的一个成绩。</li>
<li>一对多：比如一个班级表，每个班级有多个学生，一个学生只对应一个班级，班级和学生就是一对多的关系。</li>
<li>多对多：比如选课表，每门课有很多学生选，一个学生又可以选多门课。学生和选课就是多对多的关系。</li>
</ul>
<h3 id="4-创建表"><a href="#4-创建表" class="headerlink" title="4.创建表"></a>4.创建表</h3><ul>
<li><p>建表的语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name(<br>	属性名  数据类型 [完整性约束条件],<br>    属性名  数据类型 [完整性约束条件],<br>    属性名  数据类型 [完整性约束条件],<br>    ....<br>    属性名  数据类型 [完整性约束条件]);<br>    <br>    //写完一个字段要加一个逗号，最后一个不要加<br></code></pre></td></tr></table></figure>

<p>表名不能为sql的关键字</p>
</li>
</ul>
<h3 id="5-操作表的约束"><a href="#5-操作表的约束" class="headerlink" title="5.操作表的约束"></a>5.操作表的约束</h3><p>完整性约束条件是对字段进行限制的，要求用户对该属性进行的操作符合特定的要求。如果不满足完整性约束条件，数据库系统就不再执行用户的操作。MySQL中基本的完整性约束条件如下表。</p>
<table>
<thead>
<tr>
<th>约束条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>primary key</td>
<td>标识该属性为该表的主键，可以唯一的标识对应的元组</td>
</tr>
<tr>
<td>foreign key</td>
<td>标识该属性为该表的外键，是与之联系的某表的主键</td>
</tr>
<tr>
<td>not null</td>
<td>标识该属性不能为空</td>
</tr>
<tr>
<td>unique</td>
<td>标识该属性的值是唯一的</td>
</tr>
<tr>
<td>auto_increment</td>
<td>标识该属性的值自动增加，这是MySQL语句的特色</td>
</tr>
<tr>
<td>default</td>
<td>为该属性设置默认值</td>
</tr>
</tbody></table>
<h4 id="1-设置非空约束"><a href="#1-设置非空约束" class="headerlink" title="1.设置非空约束"></a>1.设置非空约束</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>属性名  数据类型  <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>    ......<br>);<br><br>直接在所要设置的字段名后面加上NOT NULL<br></code></pre></td></tr></table></figure>

<h4 id="2-设置表的默认值"><a href="#2-设置表的默认值" class="headerlink" title="2.设置表的默认值"></a>2.设置表的默认值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>属性名  数据类型 <span class="hljs-keyword">DEFAULT</span> defaultvalue,<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>username  <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>age  <span class="hljs-built_in">int</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">3</span>,<br>    .....<br>)<br><br>在所要设置的属性后面加上<span class="hljs-keyword">DEFAULT</span> defaultvalue  defaultvalue是默认值<br></code></pre></td></tr></table></figure>

<h4 id="3-设置表字段唯一约束（UK"><a href="#3-设置表字段唯一约束（UK" class="headerlink" title="3.设置表字段唯一约束（UK)"></a>3.设置表字段唯一约束（UK)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>属性名  数据类型  <span class="hljs-keyword">UNIQUE</span>,<br>    ......<br>);<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>username  <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">UNIQUE</span>,<br>age  <span class="hljs-built_in">int</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">3</span>,<br>    .....<br>)<br><br>直接在所要设置的字段名后面加上<span class="hljs-keyword">UNIQUE</span><br></code></pre></td></tr></table></figure>

<h4 id="4-设置表的主键约束（PK）"><a href="#4-设置表的主键约束（PK）" class="headerlink" title="4.设置表的主键约束（PK）"></a>4.设置表的主键约束（PK）</h4><ul>
<li>主键是表的一个特殊字段，该字段能唯一的标识该表中的每一条信息。主键和记录的关系如同身份证和人的关系。主键必须是唯一的，表中任意两条记录的主键字段的值不能相同，主键必须是非空的。</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>属性名  数据类型  PRIMARY <span class="hljs-keyword">KEY</span>,<br>    ......<br>);<br></code></pre></td></tr></table></figure>



<h3 id="5-设置表字段值自动增加"><a href="#5-设置表字段值自动增加" class="headerlink" title="5.设置表字段值自动增加"></a>5.设置表字段值自动增加</h3><ul>
<li>一个表中只能有一个字段使用AUTO_INCREMENT约束，且该字段的数据类型必须是整数类型，一般设置该约束的字段会同时设置成PK约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>属性名   数据类型   PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,<br>    ......<br>);<br><br><br>//只要这只的字段名后面加上PRIMARY KEY AUTO_INCREMENT 将该字段名同时设置成主键和自增长<br></code></pre></td></tr></table></figure>



<h3 id="6-设置表的外键约束-FK"><a href="#6-设置表的外键约束-FK" class="headerlink" title="6.设置表的外键约束(FK)"></a>6.设置表的外键约束(FK)</h3><ul>
<li><p>外键是表的一个特殊字段，外键约束用于保证多个表（通常是两个表）之间的参照完整性，即构建与两个表的字段之间的参照关系</p>
</li>
<li><p>设置外键约束的两个表之间具有父子关系，即子表中某个字段的取值范围由父表决定。列入一个班级和学生的关系，每个班级有多个学生。首先就应该有学生表和班级表，然后学生表有一个表示班级编号的字段classno,其依赖于班级表的主键，这样字段classno就是学生表的外键，通过该字段，班级表和学生表建立了关系</p>
</li>
<li><p>外键依赖于数据库中已经存在的父表的主键，外键可以为空。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tablename(<br>属性名a  数据类型，<br>    .....<br>    <span class="hljs-keyword">CONSTRAINT</span> fk_class_id  <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (class_id)  <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">class</span>(<span class="hljs-keyword">id</span>)<br>    //fk_class_id为外键约束的名字，可以随便取， class_id为这个表中你要设置为外键的字段名<br>    // <span class="hljs-keyword">class</span>为你要关联的表，<span class="hljs-keyword">id</span>为你要关联的表的字段名<br>    //这句话的意思就是  将这个表中的class_id作为外键，并且关联<span class="hljs-keyword">class</span>表的字段名为<span class="hljs-keyword">id</span>的字段<br><br></code></pre></td></tr></table></figure>



<ul>
<li>实际开发中，一般不使用物理外键（即不设置出一个具体的外键），而使用逻辑外键，我们知道他有外键的功能即可可以参考这篇博客  <a href="https://zhuanlan.zhihu.com/p/114834741">主键和外键</a></li>
</ul>
<h3 id="7-修改表"><a href="#7-修改表" class="headerlink" title="7.修改表"></a>7.修改表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_class <span class="hljs-keyword">rename</span> tab_class;     //修改表的名字，使用<span class="hljs-keyword">alter</span>和<span class="hljs-keyword">rename</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">add</span> propName proptype; <br>		//在表的最后一个位置增加字段，tablename为表的名字，propName为属性名，proptype是数据类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">add</span> propName proptype <span class="hljs-keyword">first</span>;<br>       //在表的第一个位置增加字段，tablename为表的名字，propName为属性名，proptype是数据类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">add</span> propName proptype <span class="hljs-keyword">after</span> pNameOld；<br>       //在pnameOld后面加一个字段名，pNameOld是已经存在的字段名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">drop</span> propname;<br>       //删除表中的某个字段，tablename为表的名字，propName为属性名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">modify</span> propName propType;<br>		//修改某个字段的数据类型<br></code></pre></td></tr></table></figure>



<h2 id="MySQL的数据操作"><a href="#MySQL的数据操作" class="headerlink" title="MySQL的数据操作"></a>MySQL的数据操作</h2><h3 id="1-插入语句"><a href="#1-插入语句" class="headerlink" title="1.插入语句"></a>1.插入语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tablename(field1,field2,field3......)<br>		<span class="hljs-keyword">values</span>(value1,value2,value3.....)；<br></code></pre></td></tr></table></figure>





<ul>
<li><p>tablename是要插入的表的名字，field为要插入的字段名，value表示要插入的数值，并且field要和value一一对应。</p>
</li>
<li><p>field可以省略，这样就必须在values中写出所有字段的值，并且value对应的字段名必须与数据表中字段名的顺序相同。</p>
</li>
<li><p>在给表中所有字段赋值的时候，可以不用写field,由于主键是自增的，所以给主键赋值NULL，系统会自动为其赋值上条记录中该字段的取值加1。</p>
</li>
<li><p>field的顺序可以不和数据表中的字段名的顺序相同，但是必须保证field和value是一一对应的。</p>
</li>
<li><p>插入多条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tablename(field1,field2,field3......)<br>		<span class="hljs-keyword">values</span>(value11,value12,value13.....)，<br>		<span class="hljs-keyword">values</span>(value21,value22,value23.....),<br>		<span class="hljs-keyword">values</span>(value31,value32,value33.....),<br>		........<br>		<span class="hljs-keyword">values</span>(valuen1,valuen2,valuen3......);<br></code></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>可以通过插入数据来实现数据的复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tablename(field1,field2,field3.....)<br>	<span class="hljs-keyword">select</span> (field1,fidld2,field3.....)<br>	<span class="hljs-keyword">from</span> tablename2 where.....<br>	<br>//从tablename2中查询出数据，将这些数据作为<span class="hljs-keyword">values</span>插入到tablename中。<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="2-更新数据记录"><a href="#2-更新数据记录" class="headerlink" title="2.更新数据记录"></a>2.更新数据记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tablename <br>		<span class="hljs-keyword">set</span> field1=value1,field2=value2,field3=value3.....<br>	<span class="hljs-keyword">where</span> ....<br>//tablename是表的名字，<span class="hljs-keyword">field</span>是字段名，<span class="hljs-keyword">value</span>是值，<span class="hljs-keyword">where</span>后面填特定的条件<br></code></pre></td></tr></table></figure>



<h3 id="3-删除数据记录"><a href="#3-删除数据记录" class="headerlink" title="3.删除数据记录"></a>3.删除数据记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">where</span> ....<br><br>//参数tablename表示所要删除的数据记录的表名，<span class="hljs-keyword">where</span> 后面填特定的条件<br></code></pre></td></tr></table></figure>



<h2 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h2><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h3><table>
<thead>
<tr>
<th>整数类型</th>
<th>字节数</th>
<th>无符号数的取值范围</th>
<th>有符号数的取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>0~255</td>
<td>-128~127</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>0~65535</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>0~16777215</td>
<td>-8388608~83886007</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>0~4294967295</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>INTEGER</td>
<td>4</td>
<td>0~4294967295</td>
<td>2147483648~2147483647</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>0~18446744073709551615</td>
<td>-9223372036854775808~9223372036854775807</td>
</tr>
</tbody></table>
<ul>
<li>字段选择哪个整数类型取决于该字段的范围，现在最常用的整数类型是INT类型。</li>
</ul>
<h3 id="2-浮点数类型和定点数类型"><a href="#2-浮点数类型和定点数类型" class="headerlink" title="2.浮点数类型和定点数类型"></a>2.浮点数类型和定点数类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>负数的取值范围</th>
<th>非负数的取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>4</td>
<td>-3.402823466E+38~-1.175494351E-38</td>
<td>0和1.175494351E-38~3.402823466E+38</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
<td>-1.7976931348623157E+308~-202250738585072014E-308</td>
<td>0和202250738585072014E-308~1.7976931348623157E+308</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>M+2</td>
<td>同DOUBLE类型</td>
<td>同DOUBLE类型</td>
</tr>
</tbody></table>
<ul>
<li>从表中可以看出DECIMAL类型的取值范围和DOUBLE相同。FLOAT和DOUBLE类型存储数据是存储的是近似值，DECIMAL存储的是字符串，因此提供了更高的精度。在金融系统中，表示货币金额的时候优先选择DECIMAL，一般的价格题中，比如商品的价格一般选择FLOAT类型。</li>
</ul>
<h3 id="3-日期与时间类型"><a href="#3-日期与时间类型" class="headerlink" title="3.日期与时间类型"></a>3.日期与时间类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>1</td>
</tr>
<tr>
<td>DATE</td>
<td>4</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
</tr>
<tr>
<td>TIMESTAP</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>YEAR类型表示年，DATE类型表示日期，TIME类型表示时间，DATETIME和TIMESTAMP表示日期和时间</li>
<li>根据自己的需要，选择相应的类型。</li>
<li>在实际开发中，往往需要将时间格式化以后才能插入到数据库</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成日期对象</span><br>Date date = <span class="hljs-keyword">new</span> Date();<br><span class="hljs-comment">//设置日期格式化样式为yyyy-MM-dd</span><br> SimpleDateFormat  SimpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-comment">//将date转为yyyy-MM-dd的字符串</span><br>String format = simpleDateFormat.format(date);<br>Date parse = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>      parse = simpleDateFormat.parse(format);<br>   &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="4-字符串类型"><a href="#4-字符串类型" class="headerlink" title="4.字符串类型"></a>4.字符串类型</h3><ul>
<li><strong>char</strong>和<strong>varchar</strong>类型为字符串类型。</li>
<li>在建表的时候，<strong>varchar</strong>需要设置长度，不设置会报错（有些人又说不会，但是我建表的时候没加过不了）。</li>
<li>设置长度的格式 : <code>字符串类型（M)</code></li>
<li><strong>CHAR</strong>和<strong>VARCHAR</strong>没有太大的区别。CHAR的长度是固定的，而VARCHAR的长度是可变的，指定长度之后，其长度可以在0到指定长度之间。比如VARCHAR(100)的最大长度是100，但不是每条记录都会占用100字节，而是在这个最大值范围内，用多少占多少。</li>
</ul>
<h2 id="单表数据查询"><a href="#单表数据查询" class="headerlink" title="单表数据查询"></a>单表数据查询</h2><h3 id="1-查询所有的字段数据"><a href="#1-查询所有的字段数据" class="headerlink" title="1.查询所有的字段数据"></a>1.查询所有的字段数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> field1,field2,field3....fieldn <span class="hljs-keyword">from</span> tablename；<br></code></pre></td></tr></table></figure>

<ul>
<li>在select后面写出所有的字段名</li>
<li>除了上面这种方法，还可以通过符号”*“来实现</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tablename;<br></code></pre></td></tr></table></figure>

<h3 id="2-查询指定字段数据"><a href="#2-查询指定字段数据" class="headerlink" title="2.查询指定字段数据"></a>2.查询指定字段数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">//查询指定字段数据的方法和查询所有字段数据的第一种方法相同，只是查询所有是要写出所有的字段名，而查询部分只要写出自己需要的字段名即可<br><br><span class="hljs-keyword">select</span> field1，field2，field3.....from tablenamea<br></code></pre></td></tr></table></figure>

<h3 id="3-避免重复数据"><a href="#3-避免重复数据" class="headerlink" title="3.避免重复数据"></a>3.避免重复数据</h3><p>在MySQL查询执行简单数据查询时，有时候会显示重复数据。</p>
<p>比如说学生表中有3条数据，age字段的数据分别是16,17,16，你想查询班上的孩子是哪个岁数的，如果是简单的查询就会出现16,17,16,三个数据，而两个16是重复的，我们只要显示一个就够了。</p>
<p>这个时候就要使用DISTINCT功能来避免重复数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">frselect distinct age from student;<br><br>//用distinct修饰你想避免重复的字段<br></code></pre></td></tr></table></figure>

<h3 id="4-条件数据记录查询"><a href="#4-条件数据记录查询" class="headerlink" title="4.条件数据记录查询"></a>4.条件数据记录查询</h3><ul>
<li>条件查询的种类</li>
</ul>
<table>
<thead>
<tr>
<th>查询条件</th>
<th>符号或关键字</th>
</tr>
</thead>
<tbody><tr>
<td>比较</td>
<td>= 、&lt;、&lt;=、&gt;、&gt;=、!=、&lt;&gt;(不等于)、!&gt;(不大于)、!&lt;</td>
</tr>
<tr>
<td>指定范围</td>
<td>BETWEEN  AND、NOT BETWEEN AND</td>
</tr>
<tr>
<td>指定集合</td>
<td>IN、NOT IN</td>
</tr>
<tr>
<td>匹配字符</td>
<td>LIKE、NOT LIKE</td>
</tr>
<tr>
<td>是否为空值</td>
<td>IS NULL、IS NOT NULL</td>
</tr>
<tr>
<td>多个查询条件</td>
<td>AND、OR</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> field1，field2.....from tablename <span class="hljs-keyword">where</span> .....<br></code></pre></td></tr></table></figure>

<ol>
<li><p>带IN关键字的查询</p>
<ol>
<li><p>用IN来查询在集合中的数据，NOT IN查询不在集合中的数据</p>
<p><code>select * from student where age in (15,16，17)</code>  查询年龄为15,16,17的学生数据</p>
<p><code>select * from student where age not in (15,16,17)</code> 查询年龄不是15,16,17的学生数据</p>
</li>
<li><p>在使用IN关键字的时候，查询的集合中如果存在NULL，不会影响查询；使用NOT IN时，如果查询的集合中有NULL，则不会有任何的查询结果。</p>
</li>
</ol>
</li>
<li><p>带BETWEEN AND关键字的查询</p>
<ol>
<li><p>BETWEEN AND关键字操作符只针对数字类型。</p>
</li>
<li><p>用BETWEEN AND查询符合范围的数据，NOT BETWEEN AND查询不符合范围的数据。</p>
<p><code>select * from student where age between 15 and 17;</code> 查询年龄在15  ~ 17这个范围内的数据</p>
<p><code>select * from student where age not between 15 and 17;</code>  查询年龄不在15 ~ 17这个范围内的数据。</p>
</li>
</ol>
</li>
<li><p>带LIKE关键字的查询</p>
<ol>
<li><p>LIKE关键字支持   _    和  % 这两个通配符</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>_</td>
<td>该通配符只能匹配单个字符</td>
</tr>
<tr>
<td>%</td>
<td>该通配符可以匹配任意长度的字符串，既可以是0个字符串、1个字符串，又可以是很多字符串</td>
</tr>
</tbody></table>
<p><code>select * from student where name like &#39;L%&#39;;</code>  查询名字以L开头的学生数据</p>
<p><code>select * from student where not name like &#39;L%&#39; </code>  查询名字不是以K开头的学生数据</p>
<p><code>select * from student where name like &#39;_A%&#39;</code> 查询名字的第二个字母是A的学生数据</p>
</li>
<li><p><strong>注意使用like关键字的时候，通配符位置要用单引号括起来，就算是数字类型的也需要使用单引号</strong></p>
</li>
</ol>
</li>
<li><p>带AND的多条件查询</p>
<ol>
<li><p>关键字ADN可以用来联合多个条件进行查询，使用AND时，只有同时满足所有查询条件的记录才会被查询出来。</p>
<p><code>select * from student where age = 15 and name =&#39;pty&#39;</code>  查询年龄=15岁并且名字是pty的学生的数据</p>
</li>
</ol>
</li>
<li><p>OR，IS NULL 、NOT IS NULL这三个关键字比较简单，OR和AND差不多，就不讲了</p>
</li>
<li><p>对查询的结果进行排序</p>
<ol>
<li>使用ORDER BY关键字对记录进行排序</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age [<span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>];<br><br>//对查询出来的结果根据年龄进行排序，[]中表示可选参数<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>ASC表示按升序排序，DESC表示按降序排序。</p>
</li>
<li><p>可以指定多个字段进行排序，比如可以先按照年龄排序再按照班级排序</p>
<p><code>select * from student order by age asc,classno desc</code> 先按照年龄升序，在按照班级降序</p>
<p>即如果两个人年龄相同，班级小的那个人排在前面。</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-统计函数和分组函数"><a href="#5-统计函数和分组函数" class="headerlink" title="5.统计函数和分组函数"></a>5.统计函数和分组函数</h3><ul>
<li>COUNT()函数：实现统计表中记录的条数</li>
<li>AVG()函数：实现计算字段值的平均值</li>
<li>SUM()函数：实现计算字段值的综合</li>
<li>MAX()函数：实现查询字段值的最大值</li>
<li>MIN()函数：实现查询字段值的最小值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">count()函数：<br>	count(*)  对表中的记录进行统计，无论表字段中包含的是null值还是非null值<br>	cout(field)  对表中特定的字段进行统计，忽略null值。<br>	<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">from</span> student;  //查询student表中一共有多少条记录<br>	<br>avg()函数：<br>	avg(field)  先计算特定字段值的和，在求平均值。<br>	<span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(age) <span class="hljs-keyword">from</span> student;  //查询student中学生年龄的平均值<br><br><br>sum()函数:<br>	sum(field)  计算特定字段值之和，在具体使用中会忽略null值。<br>	<span class="hljs-keyword">select</span>  <span class="hljs-keyword">avg</span>(age) <span class="hljs-keyword">from</span> student;  //查询student中学生年龄的总和<br><br>max()函数 min()函数：<br>	max(field)  计算特定字段值的最大值，在具体使用中会忽略null值<br>	min(field)  计算特定字段值的最小值，在具体使用中会忽略null值<br>	<span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(age) maxval,<span class="hljs-keyword">min</span>(age) minval <span class="hljs-keyword">from</span> s_score;  //查询student中学生年龄的最大最小值。<br></code></pre></td></tr></table></figure>

<ul>
<li>当数据表中没有任何数据时，COUNT()函数返回数据为0，其他所有函数返回NULL。</li>
</ul>
<h4 id="简单分组函数"><a href="#简单分组函数" class="headerlink" title="简单分组函数"></a>简单分组函数</h4><ul>
<li>在现实应用中，经常会先把所有的数据记录进行分组，再对这些分组后的数据记录进行统计计算。</li>
<li>使用GROUP BY 来实现分组</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 统计函数() <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">where</span> .... <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">field</span>;<br>// 根据field进行分组然后在统计数据<br></code></pre></td></tr></table></figure>

<ul>
<li>同一组的数据只会展示一条。</li>
<li>只实现简单的分组查询是没有任何意义的，因为GROUP BY 关键字在单独使用时，默认查询出每个分组中随机一条记录。不具有确定性。因此常和统计函数一起使用</li>
<li>如果想要显示每个分组中的字段，可以使用GROUP_CONCAT()函数来实现。该函数可以显示每个分组中的指定字段。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">field</span>) <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">where</span> .... <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">field</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql&gt; select subject,group_concat(name) name,count(name) number from teacher GROUP BY subject;<br>+<span class="hljs-comment">---------+------------+--------+</span><br>| subject | name       | number |<br>+<span class="hljs-comment">---------+------------+--------+</span><br>| 化学    | snow,ji    |      2 |<br>| 数学    | huang,zhou |      2 |<br>| 生物    | peng       |      1 |<br>| 语文    | chen       |      1 |<br>+<span class="hljs-comment">---------+------------+--------+</span><br>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.34</span> sec)<br>//根据subject 分类，将每组中的<span class="hljs-keyword">name</span>都显示出来，并统计人数<br></code></pre></td></tr></table></figure>

<ul>
<li>Having可以对分组后的数据进行再一次过滤</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">field</span>) <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">where</span> .... <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">field</span> <span class="hljs-keyword">having</span> ....<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">//根据subject 分类，将每组中的name都显示出来，并统计人数,在过滤掉人数小于等于1的mysql&gt; select subject,group_concat(name) name,count(name) number from teacher GROUP BY subject having number&gt;1;<br>+<span class="hljs-comment">---------+------------+--------+</span><br>| subject | name       | number |<br>+<span class="hljs-comment">---------+------------+--------+</span><br>| 化学    | snow,ji    |      2 |<br>| 数学    | huang,zhou |      2 |<br>+<span class="hljs-comment">---------+------------+--------+</span><br>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>////根据subject 分类，将每组中的<span class="hljs-keyword">name</span>都显示出来，并统计人数,在过滤掉人数小于等于<span class="hljs-number">1</span>的<br></code></pre></td></tr></table></figure>

<ul>
<li>Having的执行效率比where低，能用where解决的不要用where</li>
</ul>
<h3 id="6-使用LIMIT限制数据记录查询数量"><a href="#6-使用LIMIT限制数据记录查询数量" class="headerlink" title="6.使用LIMIT限制数据记录查询数量"></a>6.使用LIMIT限制数据记录查询数量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">from</span> tablename where....limit offset_start,<span class="hljs-keyword">row_count</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>offset_start表示起始位置，这个可以省略不写，如果不写默认值为0，表示从第一条记录开始显示。</li>
<li>offset_start应该比起始位置小1，类似于数组的下标。比如你要显示第4条数据，则offset_start应该为3。</li>
<li>row_count表示记录条数，即显示出来的记录数，如果row_count小于查询出来的总记录数，则只显示row_count设置的记录数；如果大于总记录数，则会把所有的都显示出来。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql&gt; select * from teacher limit 2;<br>+<span class="hljs-comment">------+------+------+---------+---------+</span><br>| tid  | name | age  | subject | salary  |<br>+<span class="hljs-comment">------+------+------+---------+---------+</span><br>| 2001 | snow |   22 | 化学    | 1200.00 |<br>| 2002 | peng |   23 | 生物    | 1200.00 |<br>+<span class="hljs-comment">------+------+------+---------+---------+</span><br>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>//限制了只显示<span class="hljs-number">2</span>条记录数，默认从第一条记录开始<br><br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">8</span>;<br>+<span class="hljs-comment">------+-------+------+---------+---------+</span><br>| tid  | name  | age  | subject | salary  |<br>+<span class="hljs-comment">------+-------+------+---------+---------+</span><br>| 2001 | snow  |   22 | 化学    | 1200.00 |<br>| 2002 | peng  |   23 | 生物    | 1200.00 |<br>| 2003 | huang |   21 | 数学    | 1200.00 |<br>| 2004 | ji    |   24 | 化学    | 1200.00 |<br>| 2005 | chen  |   23 | 语文    | 1200.00 |<br>| 2006 | zhou  |   21 | 数学    | 1200.00 |<br>+<span class="hljs-comment">------+-------+------+---------+---------+</span><br>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>//限制显示<span class="hljs-number">8</span>条记录，但由于总记录数为<span class="hljs-number">6</span>，所以显示了所有记录。<br></code></pre></td></tr></table></figure>



<h2 id="多表数据查询"><a href="#多表数据查询" class="headerlink" title="多表数据查询"></a>多表数据查询</h2><p>MySQL支持连接查询，在具体实现连接查询的操作时，首先将两个或两个以上的表按照某个条件连接起来，再查询所要求的数据记录，连接查询分为内连接查询和外连接查询。</p>
<p>在具体应用中，如果需要实现多表记录查询，一般不适合进行连接查询，因为该操作的效率比较低，所以MySQL体用了连接查询的替代操作——子查询操作。</p>
<h3 id="1-内连接查询"><a href="#1-内连接查询" class="headerlink" title="1.内连接查询"></a>1.内连接查询</h3><p>MySQL中，内连接数据查询通过“INNER JOIN…ON”语句来实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">from</span> tablename1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> tablename2  <span class="hljs-keyword">on</span> 条件<br></code></pre></td></tr></table></figure>

<p>内连接查询分为以下3类：</p>
<ul>
<li>自连接     指表与其自身连接 （这个不是很懂，看起来很简单就是一张表，但是不知道怎么得到的结果）</li>
<li>等值连接   在关键字ON后的匹配条件使用等于关系运算符（=）  这个方式我之前用的比较多</li>
<li>不等连接   关键字ON后的匹配条件使用 &gt;、&lt;、&gt;=、&lt;=、!=等关系运算符</li>
</ul>
<h3 id="2-外链接查询"><a href="#2-外链接查询" class="headerlink" title="2.外链接查询"></a>2.外链接查询</h3><p>MySQL中，外连接数据查询通过“OUTER JOIN…ON”语句来实现。<strong>outer可以省略</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">left</span>|<span class="hljs-keyword">right</span>|<span class="hljs-keyword">full</span>| [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">join</span> ..... on....<br></code></pre></td></tr></table></figure>

<p>外链接查询分为以下3类：</p>
<ul>
<li>左外连接</li>
<li>右外连接</li>
<li>全外连接</li>
</ul>
<p>左外连接：以<code>left join</code>左边的表为参考表，左表的所有记录都会被显示出来，而右表只会显示符合搜索条件的记录，没有数据的地方用NULL来代替</p>
<p>右外连接：以right join 右边的表为参考表，右表的所有记录都会被显示出来，而左表只显示符合搜索条件的记录，没有数据的地方用NULL代替。</p>
<p>全连接：目前mysql不支持这种方式。</p>
<p>参考这篇博客 <a href="https://blog.csdn.net/plg17/article/details/78758593">图解mysql内外连接</a></p>
<h3 id="3-复合条件连接查询"><a href="#3-复合条件连接查询" class="headerlink" title="3.复合条件连接查询"></a>3.复合条件连接查询</h3><p>复合条件连接查询中，通过添加过滤条件限制查询的结果，使查询的结果更加准确。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">班级表<br>mysql&gt; select * from t_class;<br>+<span class="hljs-comment">---------+--------+------+---------+</span><br>| classno | cname  | loc  | advisor |<br>+<span class="hljs-comment">---------+--------+------+---------+</span><br>|       1 | class1 | loc1 | ad1     |<br>|       2 | class2 | loc2 | ad2     |<br>|       3 | class3 | loc3 | ad3     |<br>|       4 | class4 | loc4 | ad4     |<br>+<span class="hljs-comment">---------+--------+------+---------+</span><br>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>学生表<br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_student;<br>+<span class="hljs-comment">-------+---------------------+--------+------+---------+</span><br>| stuid | name                | gender | age  | classno |<br>+<span class="hljs-comment">-------+---------------------+--------+------+---------+</span><br>|  1001 | Alicia Florric      | Female |   33 |       1 |<br>|  1002 | Kalinda Sharma      | Female |   31 |       1 |<br>|  1003 | Cary Agos           | Male   |   27 |       1 |<br>|  1004 | Diane Lockhart      | Female |   43 |       2 |<br>|  1005 | Eli Gold            | Male   |   44 |       3 |<br>|  1006 | Peter Florric       | Male   |   34 |       3 |<br>|  1007 | Will Gardner        | Male   |   38 |       2 |<br>|  1008 | Jacquiline Florriok | Male   |   38 |       4 |<br>|  1009 | Zach Florriok       | Male   |   14 |       4 |<br>|  1010 | Grace Florriok      | Male   |   12 |       4 |<br>+<span class="hljs-comment">-------+---------------------+--------+------+---------+</span><br>10 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>分数表<br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_score;<br>+<span class="hljs-comment">-------+---------+---------+------+-----------+---------+</span><br>| stuid | Chinese | English | Math | Chemistry | Physics |<br>+<span class="hljs-comment">-------+---------+---------+------+-----------+---------+</span><br>|  1001 |      90 |      89 |   92 |        83 |      80 |<br>|  1002 |      92 |      98 |   92 |        93 |      90 |<br>|  1003 |      79 |      78 |   82 |        83 |      89 |<br>|  1004 |      89 |      92 |   91 |        92 |      89 |<br>|  1005 |      92 |      95 |   91 |        96 |      97 |<br>|  1006 |      90 |      91 |   92 |        94 |      92 |<br>|  1007 |      91 |      90 |   83 |        88 |      93 |<br>|  1008 |      90 |      81 |   84 |        86 |      98 |<br>|  1009 |      91 |      84 |   85 |        86 |      93 |<br>|  1010 |      88 |      81 |   82 |        84 |      99 |<br>+<span class="hljs-comment">-------+---------+---------+------+-----------+---------+</span><br>10 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>//查找总成绩超过<span class="hljs-number">450</span>的学生的编号，姓名，性别，年龄，班级号，班级名称，班级位置和班主任信息<br><span class="hljs-keyword">SELECT</span><br>	st.stuid,<br>	st. <span class="hljs-keyword">NAME</span>,<br>	st.gender,<br>	st.age,<br>	st.classno,<br>	c.cname,<br>	c.loc,<br>	c.advisor,<br>	sc.Chinese + sc.English + sc.Math + sc.Chemistry + sc.Physics total<br><span class="hljs-keyword">FROM</span><br>	t_student st,<br>	t_class c,<br>	t_score sc<br><span class="hljs-keyword">WHERE</span><br>	st.classno = c.classno<br><span class="hljs-keyword">AND</span> st.stuid = sc.stuid;<br><br>+<span class="hljs-comment">-------+---------------------+--------+------+---------+--------+------+---------+-------+</span><br>| stuid | NAME                | gender | age  | classno | cname  | loc  | advisor | total |<br>+<span class="hljs-comment">-------+---------------------+--------+------+---------+--------+------+---------+-------+</span><br>|  1001 | Alicia Florric      | Female |   33 |       1 | class1 | loc1 | ad1     |   434 |<br>|  1002 | Kalinda Sharma      | Female |   31 |       1 | class1 | loc1 | ad1     |   465 |<br>|  1003 | Cary Agos           | Male   |   27 |       1 | class1 | loc1 | ad1     |   411 |<br>|  1004 | Diane Lockhart      | Female |   43 |       2 | class2 | loc2 | ad2     |   453 |<br>|  1005 | Eli Gold            | Male   |   44 |       3 | class3 | loc3 | ad3     |   471 |<br>|  1006 | Peter Florric       | Male   |   34 |       3 | class3 | loc3 | ad3     |   459 |<br>|  1007 | Will Gardner        | Male   |   38 |       2 | class2 | loc2 | ad2     |   445 |<br>|  1008 | Jacquiline Florriok | Male   |   38 |       4 | class4 | loc4 | ad4     |   439 |<br>|  1009 | Zach Florriok       | Male   |   14 |       4 | class4 | loc4 | ad4     |   439 |<br>|  1010 | Grace Florriok      | Male   |   12 |       4 | class4 | loc4 | ad4     |   434 |<br>+<span class="hljs-comment">-------+---------------------+--------+------+---------+--------+------+---------+-------+</span><br><br></code></pre></td></tr></table></figure>

<h3 id="4-合并查询数据记录"><a href="#4-合并查询数据记录" class="headerlink" title="4.合并查询数据记录"></a>4.合并查询数据记录</h3><p>通过UNION来实现合并查询数据记录的操作，可以将多个select语句的查询结果合并在一起组成新的关系</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> .... <span class="hljs-keyword">from</span> .... <span class="hljs-keyword">union</span>|<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>  <span class="hljs-keyword">select</span> .... <span class="hljs-keyword">from</span> .... <span class="hljs-keyword">union</span>|<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> select....form<br>			.....<br></code></pre></td></tr></table></figure>

<p>上述语句中存在多个查询数据记录语句，每个查询数据记录语句之间使用UNION或者UNION ALL语句进行连接。</p>
<p>合并后的数据记录包含所有select语句的查询结果。union关键字会去掉重复数据，而union all则不会。</p>
<h3 id="5-子查询"><a href="#5-子查询" class="headerlink" title="5.子查询"></a>5.子查询</h3><p>什么是笛卡尔积？ </p>
<p>假如A表有4条数据，B表有3条数据，将这两张表联合起来。A表中的每一条数据都会去和B表的每一条数据匹配，也就是说将会出现12条数据，这就是笛卡尔积。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql">seletct * from a,b where a.xxx=b.xxx<br></code></pre></td></tr></table></figure>

<p>执行上面这条语句的时候，就会先进行笛卡尔积操作，然后在选择符合条件的数据。当数据量足够大的时候，进行笛卡尔积就很容易导致死机。</p>
<p>当笛卡尔的数据记录数很大时，就通常使用子查询。</p>
<p>所谓子查询，是指在一个查询中嵌套其他若干查询。即在一个select语句的from或者where子句中包含另一个select查询语句。在查询语句中，前面的那个select被称为主查询，where子句中的select语句被称为子查询，也被称为嵌套查询。</p>
<p><strong>查询薪资水平为高级的员工的编号，名字，性别，年龄和工资</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql&gt; select * from t_employee;<br>+<span class="hljs-comment">------+--------------------+--------+------+--------+--------+</span><br>| id   | name               | gender | age  | salary | deptno |<br>+<span class="hljs-comment">------+--------------------+--------+------+--------+--------+</span><br>| 1001 | Alicia Florric     | Female |   33 |  10000 |      1 |<br>| 1002 | Kalinda Sharma     | Female |   31 |   9000 |      1 |<br>| 1003 | Cary Agos          | Male   |   27 |   8000 |      1 |<br>| 1004 | Eli Gold           | Male   |   44 |  20000 |      2 |<br>| 1005 | Peter Florric      | Male   |   34 |  30000 |      2 |<br>| 1006 | Diane Lockhart     | Female |   43 |  50000 |      3 |<br>| 1007 | Maia Rindell       | Female |   43 |   9000 |      3 |<br>| 1008 | Will Gardner       | Male   |   36 |  50000 |      3 |<br>| 1009 | Jacquiline Florric | Female |   57 |   9000 |      4 |<br>| 1010 | Zach Florric       | Female |   17 |   5000 |      5 |<br>| 1011 | Grace Florric      | Female |   14 |   4000 |      5 |<br>+<span class="hljs-comment">------+--------------------+--------+------+--------+--------+</span><br>11 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_slevel;<br>+<span class="hljs-comment">------+--------+-------+-------------+</span><br>| id   | salary | level | description |<br>+<span class="hljs-comment">------+--------+-------+-------------+</span><br>|    1 |   3000 |     1 | 初级        |<br>|    2 |   7000 |     2 | 中级        |<br>|    3 |  10000 |     3 | 高级        |<br>|    4 |  20000 |     4 | 特级        |<br>|    5 |  30000 |     5 | 高管        |<br>+<span class="hljs-comment">------+--------+-------+-------------+</span><br>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> a.id, a. <span class="hljs-keyword">NAME</span>,a.gender,a.age,a.salary <span class="hljs-keyword">FROM</span> t_employee a <span class="hljs-keyword">WHERE</span><br>    -&gt; a.salary &gt;= (<span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> t_slevel <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEVEL</span> = <span class="hljs-number">3</span>)<br>    -&gt; <span class="hljs-keyword">AND</span> a.salary &lt; (<span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> t_slevel <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEVEL</span> = <span class="hljs-number">4</span>);<br>+<span class="hljs-comment">------+----------------+--------+------+--------+</span><br>| id   | NAME           | gender | age  | salary |<br>+<span class="hljs-comment">------+----------------+--------+------+--------+</span><br>| 1001 | Alicia Florric | Female |   33 |  10000 |<br>+<span class="hljs-comment">------+----------------+--------+------+--------+</span><br>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<h3 id="5-1-带关键字IN的子查询"><a href="#5-1-带关键字IN的子查询" class="headerlink" title="5.1 带关键字IN的子查询"></a>5.1 带关键字IN的子查询</h3><p>一个查询语句的条件可能落在另一个查询语句的查询结果中，这可以通过关键字IN来判断。</p>
<p><strong>查询员工表t_employee的数据记录，这些记录的字段deptno的值必须在部门表t_dept中出现过</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_employee <span class="hljs-keyword">where</span> deptno <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">select</span> deptno <span class="hljs-keyword">from</span> t_dept);<br></code></pre></td></tr></table></figure>

<h3 id="5-2带关键字EXISTS的子查询"><a href="#5-2带关键字EXISTS的子查询" class="headerlink" title="5.2带关键字EXISTS的子查询"></a>5.2带关键字EXISTS的子查询</h3><p>关键字EXISTS表示存在，后面的参数是一个任意的子查询，系统对子查询进行运算以判断他是否返回行。</p>
<p>如果至少返回一行，那么EXISTS返回的结果是true,此时外层语句将进行查询；如果子查询没有任何返回行，那么EXISTS的返回结果是false,此时外层语句将不进行查询。 （前面的select语句是外层语句）</p>
<p><strong>查询t-dept表中是否存在deptno为4的部门，如果存在，再查询表t_employee的记录</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_employee <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_dept <span class="hljs-keyword">where</span> deptno=<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p><strong>查询表t-dept中是否存在的deptno为4的部门，如果存在，在查询t_employee表中字段age大于40的记录</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_employee <span class="hljs-keyword">where</span> age&gt;<span class="hljs-number">40</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">select</span>* <span class="hljs-keyword">from</span> t_dept <span class="hljs-keyword">where</span> deptno=<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<h3 id="5-3带关键字ANY的子查询"><a href="#5-3带关键字ANY的子查询" class="headerlink" title="5.3带关键字ANY的子查询"></a>5.3带关键字ANY的子查询</h3><p>关键字ANY表示满足其中任意一个条件。</p>
<p>使用ANY时，只要满足内层查询语句返回的结果中的任意一个，就可以通过该条件执行外层查询语句。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2021/12/07/java%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
    <content><![CDATA[<p>题目：<br>1、列举出四种及以上Java的容器类（即集合类）？<br>Set、List、Queue、Map、ArrayList、HashSet、HashMap</p>
<a id="more"></a>


<p>2、简单说说Java事件处理由哪四部分组成？<br>Java事件由四部分组成：<br>事件源：产生事件的对象，例如：各个组件<br>事件对象：事件类<br>监听器：监听器接口(里面定义了响应事件的抽象方法)<br>“注册”：产生事件的对象，通过调用一个方法，通知“监听器”。</p>
<p>3、Java网络编程主要基于两个协议，是哪两个协议，其作用各是什么？（7分）<br>答：是TCP协议和UDP协议（1分）<br>    TCP协议：是面向连接的传输层协议。 进程（应用程序）在使用TCP协议之前，必须先建立连接，在数据传输完毕后要释放已建立的连接。（3分）<br>    UDP协议：是无连接的传输层协议。进程（应用程序）使用UDP无须建立连接，当然，数据传输结束时也没有连接需要释放。因此，用UDP能减少开销和发送数据之前的时延。（3分）</p>
<p>4、X公司承接了一个软件项目，目前正在做可行性分析。项目经理偏向于采用Java语言开发此项目，但有少数员工提出也可以用其他语言开发如C++或C#等，为统一思想。项目经理委托小张收集数据，并给大家分析下Java的特点或优势。（请列举Java的特点至少6点，并简单进行分析说明）<br>答：简单、面向对象、支持分布式(即网络功能)、健壮性（少出低级错误）、安全（被破解的可能性）、体系结构中立（跨平台）、可移植性、解释执行、高性能、多线程、动态</p>
<p>5、Java相对于C、C++语言，更适合应用型软件的开发，这主要是Java语言本身就相对C++语言作出了一些变化，请分析出至少Java相对C++语言在语法上6个及更多的不同点。<br>答：1）全局变量：Java中没有全局变量。2）指针：Java不支持指针，但对象变量实际上都是指针。3）数据类型的支持：Java在不同平台上数据类型都统一。4）类型转换：Java有类型相容性检查。5）结构和联合：Java只支持类。6）多重继承：Java用接口实现类似多重继承的功能。7）内存管理：Java自动回收无用内存。8）头文件：Java支持包引入import。9）宏定义和预处理：Java不支持宏定义。</p>
<p>6、什么是JDBC，在什么时候会用到它？<br>答、JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<p>7、列举出任意四个JDBC连接数据库相关的Java类？<br>答：DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等</p>
<p>8、JDBC操作数据库的步骤？<br>答：注册数据库驱动。<br>建立数据库连接。<br>操作数据库：包括创建一个Statement，执行SQL语句，处理结果集等。<br>关闭数据库连接</p>
<p>9、有哪些不同类型的JDBC驱动，每种驱动的特点是什么？<br>答：有四类JDBC驱动。<br>1） JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。<br>2） Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。<br>3） Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。<br>4） Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。</p>
<p>10、JDBC是如何实现Java程序和JDBC驱动的松耦合的？<br>答：JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。在这里可以看到更多JDBC的使用示例。</p>
<p>11、JDBC的DriverManager是用来做什么的？<br>答：JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p>
<p>=======================================================<br>论述题：</p>
<p>对Java中JDBC的分析和理解？<br>   （1、可以从JDBC的含义；JDBC连接数据库相关的常用Java类；当前主要使用哪种类型的JDBC驱动；JDBC是如何实现Java程序和JDBC驱动的松耦合的；JDBC的DriverManager是用来做什么的；JDBC的DriverManager的理解等等角度进行分析（但不限于这些角度）<br>     2、能正确答出3个及以上点，且字数超过200字，则得满分<br>    ）。<br>答：<br>  1、JDBC的含义<br>  JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<p>  2、JDBC连接数据库相关的常用Java类包括（列举4个及以上，并可以简单说说列举的类的作用或含义）：<br>  DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等  </p>
<p>  3、主要使用的JDBC驱动类型<br>  Direct-to-Database Pure Java Driver：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQLConnector/J是MySQL数据库的驱动。</p>
<p>  4、JDBC如何实现Java程序和JDBC驱动的松耦合的<br>JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。</p>
<p>  5、JDBC的DriverManager<br>JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager. getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p>
<p>=======================================================</p>
<p>12、在Java程序中，如何获取数据库服务器的相关信息？<br>答：使用DatabaseMetaData可以获取到服务器的信息。当和数据库的连接成功建立了之后，可以通过调用getMetaData()方法来获取数据库的元信息。DatabaseMetaData里面有很多方法，通过它们可以获取到数据库的产品名称，版本号，配置信息等。相关代码为：<br>DatabaseMetaData metaData = con.getMetaData();<br>String dbProduct = metaData.getDatabaseProductName();</p>
<p>13、JDBC的Statement是什么？<br>答：Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法我们可以生成一个Statement对象。我们可以通过调用它的execute()，executeQuery()，executeUpdate()方法来执行静态SQL查询。由于SQL语句是程序中传入的，如果没有对用户输入进行校验的话可能会引起SQL注入的问题。<br>另外，默认情况下，一个Statement同时只能打开一个ResultSet。如果想操作多个ResultSet对象的话，需要创建多个Statement。Statement接口的所有execute方法开始执行时都默认会关闭当前打开的ResultSet。</p>
<p>14、execute，executeQuery，executeUpdate的区别是什么？<br>答：1）execute方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。<br>2）executeQuery方法用来执行查询(select)，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。<br>3）executeUpdate方法用来执行添删改操作，即insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。<br>4）只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p>
<p>15、JDBC的PreparedStatement是什么？<br>答：PreparedStatement对象代表的是一个预编译的SQL语句。用它提供的setter方法可以传入查询的变量。<br>由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。由于PreparedStatement自动对特殊字符转义，避免了SQL注入攻击，因此应当尽量的使用它。</p>
<p>16、PreparedStatement中如何注入NULL值？<br>答：可以使用它的setNull方法来把null值绑定到指定的变量上。setNull方法需要传入参数的索引以及SQL字段的类型，像这样：<br>ps.setNull(10, java.sql.Types.INTEGER);.</p>
<p>17、Statement中的getGeneratedKeys方法有什么用？<br>答：有的时候表会生成主键，这时候就可以用Statement的getGeneratedKeys()方法来获取这个自动生成的主键的值了。</p>
<p>18、相对于Statement，PreparedStatement的优点是什么？<br>答：它和Statement相比优点在于：<br>1）PreparedStatement有助于防止SQL注入，因为它会自动对特殊字符转义。<br>2）PreparedStatement可以用来进行动态查询。<br>3）PreparedStatement执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。<br>4）使用PreparedStatement的setter方法更容易写出面向对象的代码，而Statement的话，我们得拼接字符串来生成查询语句。如果参数太多了，字符串拼接看起来会非常难看并且容易出错。</p>
<p>19、JDBC中大数据量的分页解决方法?<br>答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。<br>mysql语法：<br>    SELECT *<br>    FROM 表名<br>    LIMIT [START], length;<br>oracle语法：<br>    SELECT *FROM (<br>        SELECT 列名,列名,ROWNUM rn<br>        FROM 表名<br>        WHERE ROWNUM&lt;=(currentPage*lineSize)) temp<br>    WHERE temp.rn&gt;(currentPage-1)*lineSize;</p>
<p>简答和分析题集</p>
<p>20 java中有几种类型的流?JDK为每种类型的流提供了一些抽象类以提供继承，请说出他们分别是哪些类？<br>答：<br>（1）字节流，字符流。<br>（2）字节流继承于InputStream，OutputStream。<br>（3）字符流继承于Reader Writer。</p>
<p>21 使用处理流的优势有哪些？如何识别所使用的流是处理流还是节点流？<br>答：<br>优势：对开发人员来说，使用处理流进行输入/输出操作更简单。使用处理流的执行效率更高。<br>识别：处理流的构造器的参数不是一个物理节点，而是已经存在的流。而节点流都是直接以物理 IO 及节点作为构造器参数的。</p>
<p>22 什么是标准的IO流？<br>答：在java语言中用stdin表示键盘，用stdout表示监视器。它们被封装在System类的类变量 in 和 out 中，对应系统调用System,in 和 System,out。这样的两个流加上System.err统称为标准流。<br>System类中声明的3个类变量：<br>（1）public static InputStream in;<br>（2）public static PrinStream out;<br>（3）public static PriStram err;</p>
<p>23  什么能被序列化？什么不能被序列化？<br>答：<br>能被序列化：<br>（1）属性<br>（2）类型；<br>不能被序列化：<br>（1）static的属性；<br>（2）方法，<br>（3）加了transient修饰符的属性。</p>
<p>24 什么是java序列化，如何实现java序列化？<br>答：<br>（1）序列化而就是一种处理对象流的机制，所谓对象流也就是对象的内容进行流化。<br>（2）实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputSream对象，接着使用ObjectOutputSream对象的writeObject方法就可以将参数obj对象写出，要恢复的话则使用输入流。</p>
<p>1.抽象：<br>　答：<br>  抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p>2.继承：<br>　答：<br>  继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>
<p>3.封装：<br>　答：<br>   封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<ol start="4">
<li>多态性：<br> 答：<br> 　多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li>
</ol>
<p>5、String是最基本的数据类型吗?<br>　答：<br>  基本数据类型有8个，包括byte、short、int、long、char、float、double和boolean。<br>　java.lang.String是类，不属于基本数据类型。</p>
<p>6、int 和 Integer 有什么区别<br>　Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。</p>
<p>小张到X软件公司实习，第一天程序员老李为摸底，问了他一个问题：Java中的有8个基本数据类型，这破坏了面向对象的思想，为此Java提供了封装类，那么这些封装类具体有哪些？请代小张回答（至少回答出其中六个即可得满分）</p>
<p>Java为每个原始类型提供了封装类。<br>原始类型       封装类<br>boolean      Boolean<br>char          Character<br>byte          Byte<br>short          Short<br>int          Integer<br>long          Long<br>float          Float<br>double      Double<br>　引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p>
<p>7、实习程序员小张，接到X项目组经理命令完成某模块代码开发。在设计中，该模块算法中特别提到将有大量字符串的拼接。编码过程中，小张准备使用自己熟悉的String对象类完成这段代码，并向程序员老王征求意见，谁知老王否定了小张用String类型的方案，并建议他此处使用StringBuffer对象更合适，这令小张有些困惑。请帮小张分析下为何此处要用StringBuffer？<br>  即回答：String 和StringBuffer的区别<br>　答：<br>  JAVA平台提供了两个类：String和StringBuffer。<br>  String不是简单类型，而是一个类，它被用来表示字符序列。String的特点是一旦赋值，便不能更改其指向的字符对象，如果更改，则会生成一个新的字符串对象。<br>  StringBuffer是一个具有对象引用传递特点的字符串对象。StringBuffer对象可以调用其方法动态的进行增加、插入、修改和删除操作，从而实现多次插入字符，而不用担心像String类那样不断产生新对象而消耗内存，因而在字符串变化较多的操作中，效率更高。</p>
<p>9、&amp;和&amp;&amp;的区别。<br>   答： &amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p>
<p>10、final, finally的区别。<br>　　答：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改（相当于常量）。被声明为final的方法也同样只能使用，不能覆盖。<br>    finally是异常处理语句结构的一部分，表示总是执行。一般在异常处理时提供 finally 块来执行任何清除操作。</p>
<p>11、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?<br>　  答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<p>12、error和exception有什么区别?<br>　 答：error 表示恢复不是不可能但很困难的情况下的一种严重问题，是一种系统性的错误，程序本身不能处理这样的情况，比如说内存溢出。<br>      exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，是不会发生这种错误的。</p>
<p>13、abstract class和interface有什么区别?<br>　  答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。     Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>　   接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<p>14、GC是什么? 为什么要有GC?<br>　　答：1）GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或错误的内存回收会导致程序或系统的不稳定，甚至崩溃；2）Java提供的垃圾回收机制（GC）可以自动监测对象是否超过作用域从而达到自动回收内存的目的；3）Java不提供显示释放已分配内存的操作方法。</p>
<p>15、分析题<br>    1）short s1 = 1; s1 = s1 + 1;有什么错?<br>    答：short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，int数据1给short型变量s1，需要强制转换类型）<br>    2）short s1 = 1; s1 += 1;有什么错?<br>    答：本题无措short s1 = 1; s1 += 1;（可以正确编译）</p>
<p>16、分析题：Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>    答：Math.round(11.5)==12<br>        Math.round(-11.5)==-11<br>        round方法返回与参数最接近的长整数，参数加1/2后求其floor.</p>
<p>17、String s = new String(“xyz”);创建了几个String Object?<br>    答：两个对象，一个是在字符串池中的对象“xyx”,引用对象s指向的堆空间的对象“xyx”。其中，堆空间的对象“xyz”是字符串池中字符串“xyz”的副本。    </p>
<p>18、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?<br>　  答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。</p>
<p>19、数组有没有length()这个方法? String有没有length()这个方法？<br>　  答：数组没有length()这个方法，只有length的属性，用来得到数组元素个数。<br>        String有length()这个方法，用来得到字符串长度。</p>
<p>20、构造器Constructor是否可被override?<br>　  答：构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。</p>
<p>21、是否可以继承String类?<br>　  答：String类是final类，故不可以继承。</p>
<p>22、swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?<br>　  答：switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。<br>       long,string 都不能作用于swtich。</p>
<p>23、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?<br>　  答：会执行，在return前执行。</p>
<p>24、编程题: 用最有效率的方法算出2乘以8等於几?<br>    答：用位运算符“&lt;&lt;”，语句写为：2 &lt;&lt; 3;</p>
<p>25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>　  答：<br>    是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p>
<p>26、Java中的异常处理机制的简单原理和应用。<br>　   答：<br>     当JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。</p>
<p>27、描述一下JVM加载class文件的原理机制?<br>　  答：JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<p>28、char型变量中能不能存贮一个中文汉字?为什么?<br>　  答：能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的</p>
<p>29、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?<br>    答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>    同步的实现方面有两种，分别是synchronized,wait与notify</p>
<p>30、线程的基本概念、线程的基本状态以及状态之间的关系<br>　 答：<br>   线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。<br>   Java中的线程有四种状态分别是：运行、就绪、挂起、结束。 </p>
<p>=============================================<br>论述题<br>31、谈谈对Java语言中异常处理的理解？（<br>    1）可以从异常处理包含哪些关键字；每个关键字的含义或作用；引用异常处理后对开发有哪些帮助；异常处理机制的类体系结构；异常处理实现的底层机制等角度进行分析（但不限于这些角度）；<br>    2）能正确答出3个及以上点，且字数超过200字，则得满分。答案仅供参考，不唯一<br>   ）<br>    答：<br>    1、基本概念<br>    Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p>
<pre><code>2、5个主要关键字的作用
用try来指定一块预防所有&quot;异常&quot;的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的&quot;异常&quot;的类型。
finally为确保一段代码不管发生什么&quot;异常&quot;都被执行一段代码。
throw语句用来明确地抛出一个&quot;异常&quot;。
throws用来标明一个成员函数可能抛出的各种&quot;异常&quot;。

3、实现的机制
Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。
4、采用异常处理机制的好处
可以提高Java语言的处理错误能力；可以帮助程序员调试程序，发现开发中的问题，提高开发效率；可以让Java程序有健壮性，程序不容易崩溃；</code></pre>
<p>===========================================================</p>
<p>32、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>   答：1）可以。<br>       2）只有一个类的类名能与Java程序的该源文件名相同。</p>
<p>33、java中实现多态的机制是什么（Java借助什么实现多态性）？<br>　 答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。<br>      重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。</p>
<p>34、在JAVA中，如何跳出当前的多重嵌套循环？<br>    答：用break; return 方法。</p>
<p>35、Java是从（  B  ）语言改进重新设计而发展来的？<br>A. Ada    B. C++    C.Pascal  D.BASIC<br>分析：Java是从C、C++发展过来的</p>
<p>36、研究下面Java代码<br>public class TestException{<br>    public static void main(String args[]){<br>        try{<br>            System.out.println(“hello,jr”);<br>            System.exit(0);<br>        }finally{<br>            System.out.println(“88”);<br>        }<br>    }<br>}<br>输出结果为：（  A  ）<br>A. hello,jr<br>B. 88<br>C. hello,jr后是88<br>D. 不能编译<br>分析：System.exit(0);会中断程序，即使是finally都无法被执行</p>
<p>37、下面说法正确的有（  C   ）<br>A. class中的contructor不可省略<br>B. contructor必须与class同名，但方法不能与class同名<br>C. contructor在一个对象被new时执行<br>D. 一个class只能定义一个contructor</p>
<p>分析：contructor就是指的构造方法，普通方法也可以和类同名</p>
<p>38、在java中，已定义两个接口B和C，要定义一个实现这两个接口的类，以下语句正确的是（  C  ）<br>A. interface A extends B,C<br>B. interface A implements B,C<br>C. class A implements B,C<br>D. class A implements B,implements C</p>
<p>分析：类实现接口的基本语法</p>
<p>39、当编译并允许下面程序时，会发生什么结果？（   D   ）<br>public class Demo{<br>    protected Demo(){<br>        for(int i=0;i&lt;10;i++){<br>            System.out.println(i);<br>        }<br>    }</p>
<pre><code>public static void main(String args[])&#123;
    Demo d=new Demo();
&#125;</code></pre>
<p>}<br>A. 编译错误，构造方法不能被声明为protected<br>B. 允许错误，构造方法不能被声明为protected<br>C. 编译并运行输出0到10<br>D. 编译并运行输出0到9</p>
<p>分析：本题程序无错误可正常运行，构造方法是可以定义为protected的。</p>
<p>40、当编译和运行下面程序时，哪项描述可以最准确的表达发生了什么事情（   B    ）<br>public class MyAr{</p>
<pre><code>public void amethod()&#123;
    int i;
    System.out.println(i);    
&#125;

public static void main(String args[])&#123;
    MyAr m=new MyAr();
    m.amethod();
&#125;</code></pre>
<p>}<br>A. 编译并输出0<br>B. 编译错误<br>C. 编译并输出null<br>D. 运行错误</p>
<p>分析： 方法amethod()中定义的变量：int i; 是一个方法级别的变量，必须手动赋予初值，否则编译错误。<br>       注意：成员变量系统给默认值，如果不显示手动赋值，依然是正确的。</p>
<p>41、给定java代码如下，关于super的用法，以下描述正确的是（    C   ）<br>class C extends B{<br>    public C(){<br>        super();<br>    }<br>}<br>A. 用来调用类B中定义的super()方法<br>B. 用来调用类C中定义的super()方法<br>C. 用来调用类B中的无参构造方法<br>D. 用来调用类B中第一个出现的构造方法</p>
<p>分析：super()的含义是用来调用父类（B）中不带参数的构造方法。super()的用法，一般出现在子类构造方法中第一行。</p>
<p>42、下列语句正确的是（   A  ）<br>A) 形式参数可被视为local variable<br>B) 形式参数可被字段修饰符修饰<br>C) 形式参数为方法被调用时，真正被传递的参数<br>D) 形式参数不可以是对象</p>
<p>分析：B项无此说法，C中被真正传递的是实参，D中形参可以使对象</p>
<p>43、以下代码输出结果为（  C    ）<br>public class Test{<br>    public static String output=””;</p>
<pre><code>public static void foo(int i)&#123;
    try&#123;
        if(i==1)
            throw new Exception();

        output+=&quot;1&quot;;            
    &#125;catch(Exception e)&#123;
        output+=&quot;2&quot;;
        return ;
    &#125;finally&#123;
        output+=&quot;3&quot;;
        output+=&quot;4&quot;;
    &#125;
&#125;

public static void main(String args[])&#123;
    foo(0);
    foo(1);
    System.out.println(output);
&#125;</code></pre>
<p>}<br>A. 1342        B. 123        C. 134234    D. 13423</p>
<p>分析：本题中，foo(0)时，if语句if(i==1)throw new Exception();不满足条件，不会抛出异常，因此此时output值为“134”；<br>      紧接着执行foo(1)时，if语句if(i==1)throw new Exception();满足条件，抛出异常，执行catch语句，output值变成“1342”；<br>      最难点在于此时碰到了return，是否还会执行finally语句，答案是会执行，因此最后output值变成“134234”；答案为C。</p>
<p>44、在Java中，下列（  D    ）类不能派生出子类？<br>A) public class MyClass{ … }<br>B) class MyClass{ … }<br>C) abstract class MyClass{ … }<br>D) final class MyClass{    … }</p>
<p>分析：类前面可以有public和默认两种权限，一般都能被子类继承，因此A、B答案可以派生子类<br>      C答案是抽象类，也可以被继承<br>      D答案是final修饰的类，是最终类，不允许被继承。</p>
<p>45、编译和运行下面代码时显示结果是（     ）<br>public class Conv{<br>    public static void main(String argv[]){<br>            Conv c=new Conv();<br>            String s=new String(“ello”);<br>            c.amethod(s);<br>    }<br>    public void amethod(String s){<br>            char c=’H’;<br>            c+=s;<br>            System.out.println(c);<br>    }<br>}<br>A、Hello<br>B、ello<br>C、elloH<br>D、编译错误<br>解答：D<br>分析：c是字符类型，s是字符串类型，字符型无法自动转换成字符串类型，因此语句c+=s;类型不兼容，有语法错误，故答案是D<br>修改方案：将char c=’H’;语句变为String c=”H”;</p>
<p>46、当下列程序执行时，其输出结果是（     ）。<br>int i=9;<br>switch (i) {<br> default:<br> System.out.println(“default”);<br> case 0:<br> System.out.println(“zero”);<br> break;<br> case 1:<br> System.out.println(“one”);<br> case 2:<br> System.out.println(“two”);<br>}<br>A、default<br>B、default, zero<br>C、错误： default 子句没有定义<br>D、没有输出结果<br>解答：Ｂ<br>原因：程序开始遇到default关键字，会执行其语句块中语句，输出“default”；<br>由于default语句块中没有结束switch语句的关键字break;<br>所以程序会继续执行其他case块中语句，并且无需验证case的值匹配；运行到case 0语句块时，首先输出“zero”，最后碰到break语句，结束整个switch语句块。<br>故最后输出结果：<br>default<br>zero</p>
<p>47、阅读下列代码，其正确的结果是（     ）。<br>publicclass Test2 {<br>    static boolean foo(char c) {<br>       System.out.print(c);<br>       return true;<br>    }<br>    Public static void main(String[] argv) {<br>       int i = 0;<br>       //for(65;88&amp;&amp;(i&lt;2);67)<br>       for (foo(‘A’); foo(‘B’) &amp;&amp; (i &lt; 2); foo(‘C’)) {<br>           i++;<br>           foo(‘D’);<br>       }<br>    }<br>}<br>A. ABDCBDCB<br>B. ABCDABCD<br>C. Compilation fails.<br>D. An exception is thrown at runtimeB、1<br>解答：A</p>
<p>48、有以下程序段：<br>class MyThread extends Thread {<br>    public static void main(String args[]) {<br>        MyThread t = new MyThread();<br>        MyThread s = new MyThread();<br>        t.start();<br>        System.out.print(“one.”);<br>        s.start();<br>        System.out.print(“two.”);<br>    }<br>    public void run() {<br>        System.out.print(“Thread”);<br>    }<br>}<br>则下列选项说法正确的是（     ）。<br>A、编译失败<br>B、程序运行结果为：one.Threadtwo.Thread<br>C、程序运行结果是：one.two.ThreaThread<br>D、程序运行结果不确定<br>解答：D<br>分析：线程是并行运行，故结果输出顺序是不确定。<br>部分同学计算机运行几次时，可能会发现结果确定，<br>是因计算机速度太快导致，可以多次运行十几次或几十次，可以发现结果有变化</p>
<p>49、仔细分析下面程序，其正确的输出结果是（     ）。<br>publicclass Test1 {<br>    public static void changeStr(String str){   //②str<br>        str=”welcome”;<br>    }<br>    public staticvoid main(String[] args) {<br>        String str=”1234”;               //①str<br>        changeStr(str);<br>        System.out.println(str);<br>    }<br>}<br>A、welcome<br>B、welcome1234<br>C、1234<br>D、1234welcome<br>解答：C</p>
<p>分析：<br>1）主方法中的①号变量str是实际参数，changeStr(String str)中的②号str是形式参数，虽然是两个同名字变量，但实际是两个变量。</p>
<p>2）Java字符串基于字符串池实现，虽然①号str传值给了②号str，并且传的是引用，<br>   但②号str中执行语句str=”welcome”;后，并没有修改”1234”这个值本身，而是在字符串池中，新增加了一个字符串常量”welcome”，<br>   ②号str的引用指向了新的”welcome”值，但①号str指向的值”1234”没有被修改，因此主方法中打印输出的①号str的值还是1234</p>
<p>3）这里要注意，正常情况下，给方法的参数传值，当值是对象类型时，是引用传递。（若是基本数据类型，则是值传递）<br>   引用传递的确是可以利用方法来修改引用指向对的成员变量值的，字符串类（String）因其实现的机制是基于字符串池，故情况特殊<br>   参见下面代码对比：</p>
<p>class Stu{<br>    int stuAge;<br>}<br>public class Test1 {<br>    public static void changeStu(Stu stu){<br>        stu.stuAge=100;<br>    }<br>    public static void changeStr(String str){<br>        str=”welcome”;<br>    }<br>    public static void main(String[] args) {<br>        String str=”1234”;<br>        changeStr(str);               //Java字符串基于字符串池实现，因此不是简单的传递引用<br>        System.out.println(str);<br>//        Stu s=new Stu();<br>//        s.stuAge=20;<br>//        changeStu(s);                //对象类型传的是引用<br>//        System.out.println(s.stuAge);//输出100<br>    }<br>}  </p>
<p>50、下面2个文件位于相同目录下，编译运行后会出现的情况是（      ）。<br>//File P1.java<br>package MyPackage;<br>class P1{<br>void afancymethod(){<br>        System.out.println(“What a fancy method”);<br>        }<br>}<br>//File P2.java<br>public class P2 extends P1{<br>    public static void main(String argv[]){<br>    P2 p2 = new P2();<br>    p2.afancymethod();<br>    }<br>}<br>A、2个文件都可以编译，P2运行输出“What a fancy method”<br>B、2个文件都不能编译<br>C、2个文件都可以编译，P2运行时报错误<br>D、P1编译成功，P2编译时报错误<br>解答：D</p>
<p>51、编译和运行下面代码时显示的结果是（     ）。<br>public class MyClass{<br> static int i;<br> public static void main(String argv[]){<br>     System.out.println(i);<br> }<br>}<br>A、Error Variable i may not have been initializenull<br>C、1<br>D、0<br>解答：D<br>分析：本题能正常运行，static int i;中定义的i是静态成员变量，Java中成员变量默认给了初值，整型的初值是0，故此题正确</p>
]]></content>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2021/07/22/redis/</url>
    <content><![CDATA[<h2 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h2><h3 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h3><h4 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对"></a>KV键值对</h4><ul>
<li>新浪：<strong>Redis</strong></li>
<li>美团：Redis+Tair</li>
<li>阿里、百度：Redis+memecache</li>
</ul>
<a id="more"></a>

<h4 id="文档型数据库（bson格式-和-json一样）"><a href="#文档型数据库（bson格式-和-json一样）" class="headerlink" title="文档型数据库（bson格式 和 json一样）"></a>文档型数据库（bson格式 和 json一样）</h4><ul>
<li><strong>MongoDB</strong>(一般必须要掌握)<ul>
<li>MongoDB是一个基于分布式文件存储的数据库，c++编写，主要用来处理大量的文档！</li>
<li>是一个介于关系型数据库和菲关系型数据库中间的产品！</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<h4 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h4><ul>
<li><strong>HBase</strong></li>
<li>分布式文件系统</li>
</ul>
<h4 id="图关系数据库"><a href="#图关系数据库" class="headerlink" title="图关系数据库"></a>图关系数据库</h4><ul>
<li>他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐</li>
<li><strong>Neo4j</strong>,InfoGrid</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201007193243690.png" alt="image-20201007193243690"></p>
<h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。</p>
</blockquote>
<h3 id="Redis能干嘛"><a href="#Redis能干嘛" class="headerlink" title="Redis能干嘛"></a>Redis能干嘛</h3><ol>
<li>内存存储、持久化。内存中是断电即失，所以说持久化很重要（rdb、aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量!)</li>
</ol>
<h3 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h3><ol>
<li>多样的数据类型</li>
<li>持久优化</li>
<li>集群</li>
<li>事务</li>
</ol>
<h3 id="Linux安装Redis"><a href="#Linux安装Redis" class="headerlink" title="Linux安装Redis"></a>Linux安装Redis</h3><ol>
<li>下载安装包</li>
</ol>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201007195230760.png" alt="image-20201007195230760"></p>
<ol start="2">
<li>解压Redis的安装包，程序一般放在/opt目录下。</li>
<li>进入解压后的文件，可以看到我们redis的配置文件</li>
</ol>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201014160551048.png" alt="image-20201014160551048"></p>
<ol start="4">
<li>基本的环境安装命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum install gcc-c++<br><span class="hljs-comment">#如果redis的版本是6.0以上的，需要升级gcc到5.3以上</span><br>yum -y install centos-release-scl<br>yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils<br>scl <span class="hljs-built_in">enable</span> devtoolset-9 bash<br><span class="hljs-comment">#需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。</span><br><span class="hljs-comment">#如果要长期使用gcc 9.3的话：</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile<br><span class="hljs-comment">#这样退出shell重新打开就是新版的gcc了</span><br>make<br></code></pre></td></tr></table></figure>

<ol start="5">
<li><p>redis的默认安装路径<code>/usr/local/bin</code></p>
</li>
<li><p>将redis配置文件，复制到我们当前目录下    redis.conf文件</p>
</li>
<li><p>配置redis为后台启动</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#cd 到redis.conf文件目录</span><br>vim 复制的redis.conf文件的路径<br><span class="hljs-comment">#向下找，修改daemenize no 为 daemonize yes</span><br></code></pre></td></tr></table></figure>

<ol start="8">
<li>启动redis</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在/usr/local/bin目录下</span><br>redis-server redis.conf文件的地址<br>redis-server<br>redis-cli p6379   <span class="hljs-comment">#连接</span><br></code></pre></td></tr></table></figure>

<ol start="9">
<li>查看redis的进程是否开启</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -ef|grep redis <br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201014165115068.png" alt="image-20201014165115068"></p>
<ol start="10">
<li>关闭redis服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">shutdown<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201014164917598.png" alt="image-20201014164917598"></p>
<p><a href="https://blog.csdn.net/u011159417/article/details/80085011">Linux安装redis</a></p>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><p>redis-benchmark是一个压力测试工具！</p>
<p>官方自带的性能测试工具！</p>
<p>redis-benchmark命令参数</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>-h</strong></td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>-p</strong></td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>-s</strong></td>
<td align="left">指定服务器 socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>-c</strong></td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>-n</strong></td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>-d</strong></td>
<td align="left">以字节的形式指定 SET/GET 值的数据大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>-k</strong></td>
<td align="left">1=keep alive 0=reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>-r</strong></td>
<td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>-P</strong></td>
<td align="left">通过管道传输 <numreq> 请求</numreq></td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>-q</strong></td>
<td align="left">强制退出 redis。仅显示 query/sec 值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>–csv</strong></td>
<td align="left">以 CSV 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>-l</strong></td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>-t</strong></td>
<td align="left">仅运行以逗号分隔的测试命令列表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>-I</strong></td>
<td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>简单测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#测试：100个并发连接   100000请求</span><br>redis-benchmark -h localhost -p 6379 -c 100 -n 100000<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201014171727085.png" alt="image-20201014171727085"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201014172606359.png" alt="image-20201014172606359"></p>
<h3 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h3><p>redis一共有16个数据库。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20201014173309203.png" alt="image-20201014173309203"></p>
<p>默认使用的是第0个</p>
<p>可以使用select进行切换数据库！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; select 3  <span class="hljs-comment">#切换数据库</span><br>OK<br>127.0.0.1:6379[3]&gt; DBSIZE <span class="hljs-comment">#查看数据库大小</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379[3]&gt; <span class="hljs-built_in">set</span> name pty  <span class="hljs-comment">#设置name 属性值</span><br>OK<br>127.0.0.1:6379[3]&gt; get name   <span class="hljs-comment">#拿到数据库中的name属性值</span><br><span class="hljs-string">&quot;pty&quot;</span><br>127.0.0.1:6379[3]&gt; keys *    <span class="hljs-comment">#查看数据库中的全部key</span><br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379[3]&gt; flushdb   <span class="hljs-comment">#清除当前数据库</span><br>OK<br>127.0.0.1:6379[3]&gt; flushall   <span class="hljs-comment">#清除全部数据库</span><br>OK<br></code></pre></td></tr></table></figure>

<p><strong>redis是单线程的</strong></p>
<p>Redis很快，是基于内存操作的，CPU不是Redis性能瓶颈，Redis的瓶颈是机器的内存和网络带宽。</p>
<p><strong>redis是单线程的为什么这么快</strong></p>
<p>速度：CPU&gt;内存&gt;硬盘</p>
<p>redis是将所有的数据全部放在内存中的，多线程cpu上下文会切换，这是一个耗时操作。对于内存系统来说，如果没有上下文切换效率就是最高的，所以单线程去操作效率就是最高的。</p>
<h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作==数据库==、==缓存==和==消息中间件MQ==。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）</p>
<h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name pty  <span class="hljs-comment">#set一个key</span><br>OK<br>127.0.0.1:6379&gt; exists name   <span class="hljs-comment">#判断当前key是否存在，存在则返回1，不存在返回0</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; exists name1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; expire name 10  <span class="hljs-comment">#给当前的key设置过期时间，单位是秒</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; ttl name     <span class="hljs-comment">#查看当前key的剩余时间</span><br>(<span class="hljs-built_in">integer</span>) -2<br>127.0.0.1:6379&gt; move name 2   <span class="hljs-comment">#移动当前的可以到第二个数据库</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> name  <span class="hljs-comment">#查看当前key的类型</span><br>string<br>127.0.0.1:6379&gt; del name   <span class="hljs-comment">#删除当前的key,可以同时删除多个key，返回删除的key的数量</span><br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>

<p>更多的redis-key的命令参考官网：<a href="http://www.redis.cn/commands.html">redis官网</a></p>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#####################################</span><br><span class="hljs-comment">#append 追加字符串</span><br><span class="hljs-comment">#strlen 获取列表的长度</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 v1   <span class="hljs-comment">#set一个key</span><br>OK<br>127.0.0.1:6379&gt; get key1  <br><span class="hljs-string">&quot;v1&quot;</span><br>127.0.0.1:6379&gt; append key1 hah   <span class="hljs-comment">#在key1后面追加字符串，如果key1不存在，就相当于set key1</span><br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;v1hah&quot;</span><br>127.0.0.1:6379&gt; strlen key1 <span class="hljs-comment">#获取key1的长度</span><br>(<span class="hljs-built_in">integer</span>) 5<br><span class="hljs-comment">########################################</span><br><span class="hljs-comment">#incr自增1</span><br><span class="hljs-comment">#decr自减1</span><br><span class="hljs-comment">#incrby 自增指定的数</span><br><span class="hljs-comment">#decrby 自减指定的数</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> views 0<br>OK<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; incr views    <span class="hljs-comment">#自增 +1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;1&quot;</span><br>127.0.0.1:6379&gt; decr views    <span class="hljs-comment">#自减 -1</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; incrby views 10  <span class="hljs-comment">#自增 +10，自增多少可以自己设置</span><br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;10&quot;</span><br>127.0.0.1:6379&gt; decrby views 20 <span class="hljs-comment">#自减 -20  自减多少可以自己设置</span><br>(<span class="hljs-built_in">integer</span>) -10<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;-10&quot;</span><br><span class="hljs-comment">###############################</span><br><span class="hljs-comment">#字符串范围 range</span><br><span class="hljs-comment">#截取字符串</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 hello,world<br>OK<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;hello,world&quot;</span><br>127.0.0.1:6379&gt; getrange key1 0 3    <span class="hljs-comment">#截取字符串 [0,3]</span><br><span class="hljs-string">&quot;hell&quot;</span><br>127.0.0.1:6379&gt; getrange key1 0 -1   <span class="hljs-comment">#截取全部字符串，和get key1效果一样</span><br><span class="hljs-string">&quot;hello,world&quot;</span><br><span class="hljs-comment">#################################</span><br><span class="hljs-comment">#setrange 替换字符串</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 abcde<br>OK<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;abcde&quot;</span><br>127.0.0.1:6379&gt; setrange key2 2 hahaa  <span class="hljs-comment">#替换指定位置开始的字符串，这里的指定位置和数组一样，即2相当于3</span><br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; get key2 <br><span class="hljs-string">&quot;abhahaa&quot;</span><br><span class="hljs-comment">###########################################</span><br><span class="hljs-comment">#setex(set with expire)  </span><br><span class="hljs-comment">#设置一个key，并为其设置过期时间，和expire差不多，但是setex是在设置key的时候就为key设置过期时间,而expire是在设置完key以后在设置过期时间</span><br>127.0.0.1:6379&gt; setex name 20 pty  <span class="hljs-comment">#设置一个key,并设置20s过期</span><br>OK<br>127.0.0.1:6379&gt; ttl name   <span class="hljs-comment">#查看当前key的剩余时间</span><br>(<span class="hljs-built_in">integer</span>) 13<br>127.0.0.1:6379&gt; <br><span class="hljs-comment">#setnx(set if not exist) 设置一个key,如果key不存在则设置，存在则创建失败。</span><br>127.0.0.1:6379&gt; setnx key3 hh   <span class="hljs-comment">#设置一个key,因为key3不存在，所以创建成功</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; get key3<br><span class="hljs-string">&quot;hh&quot;</span><br>127.0.0.1:6379&gt; setnx key3 hah  <span class="hljs-comment">#设置一个key,因为key3已经存在，所以创建失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get key3<br><span class="hljs-string">&quot;hh&quot;</span><br><span class="hljs-comment">#############################</span><br>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3  <span class="hljs-comment">#同时设置多个值</span><br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;k3&quot;</span><br>2) <span class="hljs-string">&quot;k1&quot;</span><br>3) <span class="hljs-string">&quot;k2&quot;</span><br>127.0.0.1:6379&gt; mget k1 k2 k3  <span class="hljs-comment">#同时获取多个值</span><br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v2  <span class="hljs-comment">#同时设置多个值，如果已经存在，则创建失败，这是一个原子性操作，要么同时成功，要么同时失败，因为k1已经存在，所以创建失败，那么k4也没有创建成功。</span><br>(<span class="hljs-built_in">integer</span>) 0<br><span class="hljs-comment">#####################################</span><br><span class="hljs-comment">#getset   先返回key的值，然后再设置key的值</span><br>127.0.0.1:6379&gt; getset k1 v2   <span class="hljs-comment">#先返回key1原来的值v1，在将k1设置为v2</span><br><span class="hljs-string">&quot;v1&quot;</span><br>127.0.0.1:6379&gt; get k1<br><span class="hljs-string">&quot;v2&quot;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>所有的List命令都是由l开头的。Redis不区分大小写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">###############################################</span><br><span class="hljs-comment">#Lpush</span><br><span class="hljs-comment">#Rpush</span><br><span class="hljs-comment">#Lrange</span><br>127.0.0.1:6379&gt; lpush list one <span class="hljs-comment">#将一个值或多个值插入到key的头部（左），这里的list相当于这个列表的名字</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush list two<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lpush list three<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange list 0 -1 <span class="hljs-comment">#获取list中指定区间的值，  0 -1 表示获取全部的值</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 1 <span class="hljs-comment">#可以看到后进先出，类似于栈</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; rpush list 0  <span class="hljs-comment">#将一个值或多个值插入到list的尾部（右）  lpush从左插入，头部，rpush从右插入，尾部</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>4) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Lpop</span><br><span class="hljs-comment">#Rpop</span><br>127.0.0.1:6379&gt; lpop list  <span class="hljs-comment">#移出list的第一个元素，从左边移出</span><br><span class="hljs-string">&quot;three&quot;</span><br>127.0.0.1:6379&gt; rpop list  <span class="hljs-comment">#移出list的最后一个元素，从右边移出</span><br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;two&quot;</span><br>2) <span class="hljs-string">&quot;one&quot;</span><br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Lindex</span><br>127.0.0.1:6379&gt; lindex list 1   <span class="hljs-comment">#通过下标获得list的某一个值</span><br><span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lindex list 0<br><span class="hljs-string">&quot;two&quot;</span><br><span class="hljs-comment">#########################################</span><br>Llen<br>127.0.0.1:6379&gt; Llen list    <span class="hljs-comment">#获取list的长度</span><br>(<span class="hljs-built_in">integer</span>) 2<br><span class="hljs-comment">########################################</span><br><span class="hljs-comment">#移出指定的值</span><br>Lrem<br>127.0.0.1:6379&gt; lrange list 0 -1   <span class="hljs-comment">#可以看到，list中可以存在相同的值</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;three&quot;</span><br>3) <span class="hljs-string">&quot;two&quot;</span><br>4) <span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lrem list 1 one    <span class="hljs-comment">#移出list集中指定个数的value,  移除list中的1个one</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;three&quot;</span><br>3) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; lrem list 2 three   <span class="hljs-comment">#移除list中的2个three</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;two&quot;</span><br><span class="hljs-comment">########################################</span><br><span class="hljs-comment">#Ltrim 修改集合中的元素，只保留指定区间的元素，可以理解为lpop,只不过这个是将指定区间外的都移除</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;k4&quot;</span><br>2) <span class="hljs-string">&quot;k3&quot;</span><br>3) <span class="hljs-string">&quot;k2&quot;</span><br>4) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; ltrim list 1 2   <span class="hljs-comment">#只保留list集合中区间1到区间2的元素</span><br>OK<br>127.0.0.1:6379&gt; lrange list 0 -1   <span class="hljs-comment">#lrange 0 -1 是获取list的所有值，只返回两条，说明list已经被改变，不再是4条数据</span><br>1) <span class="hljs-string">&quot;k3&quot;</span><br>2) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-comment">#####################################</span><br>RpopLpush  <span class="hljs-comment">#移除列表的最后一个元素，并将他移动到一个新的列表的头部（左）</span><br>127.0.0.1:6379&gt; rpoplpush list list1 <span class="hljs-comment">#将list的最后一个元素移到list1的头部，如果list1不存在会自动创建</span><br><span class="hljs-string">&quot;k2&quot;</span><br>127.0.0.1:6379&gt; lrange list1 0 -1<br>1) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Lset  将列表中指定下标的值修改为另一个值   如果列表不存在或者指定下标没有值，则修改失败，类似有更新操作</span><br>127.0.0.1:6379&gt; exists list   <span class="hljs-comment">#判断数据库中是否存在list这个key</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; lset list 1 pty    <span class="hljs-comment">#因为不存在list，所以使用lset修改出错</span><br>(error) ERR no such key<br>127.0.0.1:6379&gt; lpush list k1    <span class="hljs-comment">#创建list,并且添加值</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lrange list 0 0<br>1) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; lset list 1 pty   <span class="hljs-comment">#使用lset修改，因为list只有1个值，下标为1的位置没有值，所以修改失败</span><br>(error) ERR index out of range     <span class="hljs-comment">#超出范围</span><br>127.0.0.1:6379&gt; lset list 0 pty    <span class="hljs-comment">#使用lset修改list中下标为0的值，修改为pty</span><br>OK<br>127.0.0.1:6379&gt; lrange list 0 00<br>1) <span class="hljs-string">&quot;pty&quot;</span><br><span class="hljs-comment">##########################################</span><br><span class="hljs-comment">#Linsert  在某个特定的元素的前面或者后面添加一个值</span><br>127.0.0.1:6379&gt; Linsert list before pty hello   <span class="hljs-comment">#在list中的pty前面添加一个值 hello</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;pty&quot;</span><br>127.0.0.1:6379&gt; Linsert list after pty ok   <span class="hljs-comment">#在list中的pey后面添加一个值 ok</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;pty&quot;</span><br>3) <span class="hljs-string">&quot;ok&quot;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h3><p>set中的值不能重复，List中的值可以重复。set无序不重复集合。</p>
<p>set的命令以s开头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">##############################</span><br><span class="hljs-comment">#Sadd  往set中添加一个元素</span><br><span class="hljs-comment">#Smembers 查看set中的所有值</span><br><span class="hljs-comment">#Sismember 判断一个值是不是在set中，是返回1，不是返回0</span><br>127.0.0.1:6379&gt; sadd myset hello  <span class="hljs-comment">#向set中添加一个值</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset pty<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset pty  <span class="hljs-comment">#向set中添加一个重复的值，因为set的值不能重复，所以添加失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; smembers myset  <span class="hljs-comment">#查看set中的所有值</span><br>1) <span class="hljs-string">&quot;pty&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; sismember myset pty   <span class="hljs-comment">#判断pty是否在set中，在返回1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sismember myset pet   <span class="hljs-comment">#判断pet是否在set中，不在返回0</span><br>(<span class="hljs-built_in">integer</span>) 0<br><span class="hljs-comment">##############################</span><br><span class="hljs-comment">#Scard 获取set中的元素个数</span><br>127.0.0.1:6379&gt; scard myset <span class="hljs-comment">#获取myset中的元素个数</span><br>(<span class="hljs-built_in">integer</span>) 2<br><span class="hljs-comment">###############################</span><br><span class="hljs-comment">#Srem 移除set中的特定的值</span><br>127.0.0.1:6379&gt; srem myset hello   <span class="hljs-comment">#移除set中的特定值，移除myset中的hello</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;pty&quot;</span><br><span class="hljs-comment">##################################</span><br><span class="hljs-comment">#Srandmember  在set集合中随机抽取指定个数的元素</span><br>127.0.0.1:6379&gt; sadd myset  1 <br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset  2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset  3 4 5 6 7 8 9 10  <span class="hljs-comment">#向myset中添加元素，元素个数少，抽取有偶然性</span><br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; srandmember myset 1   <span class="hljs-comment">#在set集合中随机抽取一个元素</span><br>1) <span class="hljs-string">&quot;6&quot;</span><br>127.0.0.1:6379&gt; srandmember myset 1<br>1) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; srandmember myset 3  <span class="hljs-comment">#在set集合中随机抽取3个元素</span><br>1) <span class="hljs-string">&quot;5&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment">###############################</span><br><span class="hljs-comment">#Spop 在set集合中随机移除指定个数个元素</span><br>127.0.0.1:6379&gt; spop myset 1   <span class="hljs-comment">#随机移除一个元素</span><br>1) <span class="hljs-string">&quot;1&quot;</span><br>127.0.0.1:6379&gt; spop myset 3   <span class="hljs-comment">#随机移除三个元素</span><br>1) <span class="hljs-string">&quot;7&quot;</span><br>2) <span class="hljs-string">&quot;9&quot;</span><br>3) <span class="hljs-string">&quot;pty&quot;</span><br><span class="hljs-comment">###############################</span><br><span class="hljs-comment">#Smov 将一个指定元素元素从一个集合移到另一个集合</span><br>127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; sadd set1 1 2 3 4 5 6<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; smove set1 set2 1   <span class="hljs-comment">#将set1中的1移到set2中，如果set2没有创建会自动创建</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers set2<br>1) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment">#############################</span><br><span class="hljs-comment">#Sdiff  返回A B两个集合中，A集合中的和B集合中不同的元素，如果是SDIFF B A，则返回B中与A不同的元素</span><br><span class="hljs-comment">#Sinter 返回A B两个set集合中共有的元素</span><br><span class="hljs-comment">#Sunion 返回A B两个set集合中的所有元素，如果具有相同元素，只显示一个</span><br>127.0.0.1:6379&gt; sadd set1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd set1 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd set1 c   <span class="hljs-comment">#向set1中添加a,b,c三个元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd set2 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd set2 d<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd set2 e   <span class="hljs-comment">#向set2中添加c，d,e三个元素，可以看到，set1和set2具有c这个相同元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sdiff set1 set2  <span class="hljs-comment">#返回set1和set2中，set1中的特有元素 相当于求差集</span><br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>127.0.0.1:6379&gt; sinter set1 set2  <span class="hljs-comment">#返回set1和set2共有元素  相当于求交集</span><br>1) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; sunion set1 set2  <span class="hljs-comment">#返回set1和set2所有元素 相当于求并集</span><br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;c&quot;</span><br>3) <span class="hljs-string">&quot;a&quot;</span><br>4) <span class="hljs-string">&quot;e&quot;</span><br>5) <span class="hljs-string">&quot;d&quot;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><p>每一个key里面又可以存储多个key-value组合，可以理解成类，如Person是一个类，里面包含username,age,class等属性，这里的Person就相当于外面的key,username就是里面的key,value就是属性值。</p>
<p>redis是一个key-value数据库，hash其实就是value里面又是多个key-value</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">############################</span><br><span class="hljs-comment">#Hset 向key中添加 key-value组合，可以同时添加多个key-value</span><br><span class="hljs-comment">#Hget 获取key中指定key的value,只能获取一个</span><br><span class="hljs-comment">#Hmget 获取key中指定key的value,可以同时获取多个</span><br>127.0.0.1:6379&gt; hset hash1 filed1 hello   <span class="hljs-comment">#向hash1中添加key=filed1,value=hello的元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget hash1 filed1     <span class="hljs-comment">#获取hash1中key=filed1的value</span><br><span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; hset hash1 filed2 pty filed3 haha <span class="hljs-comment">#同时设置多个key-value</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; hmget hash1 filed1 filed2 filed3  <span class="hljs-comment">#同时获取多个key-value</span><br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;pty&quot;</span><br>3) <span class="hljs-string">&quot;haha&quot;</span><br><span class="hljs-comment">#################################</span><br><span class="hljs-comment">#Hdel 删除hash中指定key，可以同时删除多个</span><br>127.0.0.1:6379&gt; hdel hash1 filed3  <span class="hljs-comment">#删除hash1中的key=filed3</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hgetall hash1   <span class="hljs-comment">#获取hash1中的所有key-value，可以看见filed3没有了</span><br>1) <span class="hljs-string">&quot;filed1&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br>3) <span class="hljs-string">&quot;filed2&quot;</span><br>4) <span class="hljs-string">&quot;pty&quot;</span><br><span class="hljs-comment">####################################</span><br><span class="hljs-comment">#Hlen  获取hash中key-value的数量</span><br>127.0.0.1:6379&gt; hlen hash1 <br>(<span class="hljs-built_in">integer</span>) 2  <span class="hljs-comment">#返回的是key-value的数量，像上面的filed1和hello是一个key-value，数量为1。</span><br><span class="hljs-comment">#####################################</span><br><span class="hljs-comment">#Hexists 判断hash中是否存在指定的key，</span><br>127.0.0.1:6379&gt; hexists hash1 filed1  <span class="hljs-comment">#判断hash1中是否存在filed1</span><br>(<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Hkeys  获取hash中的所有key</span><br><span class="hljs-comment">#Hvals 获取hash中所有的value</span><br>127.0.0.1:6379&gt; hkeys hash1   <span class="hljs-comment">#获取hash1中所有的key</span><br>1) <span class="hljs-string">&quot;filed1&quot;</span><br>2) <span class="hljs-string">&quot;filed2&quot;</span><br>127.0.0.1:6379&gt; hvals hash1   <span class="hljs-comment">#获取hash1中所有的value</span><br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;pty&quot;</span><br><span class="hljs-comment">####################################</span><br><span class="hljs-comment">#Hincrby  给hash中的指定key的值自增指定的数，没有hdecrby hincr hdecr</span><br>127.0.0.1:6379&gt; hset <span class="hljs-built_in">hash</span> field 2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hincrby <span class="hljs-built_in">hash</span> field 4  <span class="hljs-comment">#给hash中的field自增+4</span><br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; hget <span class="hljs-built_in">hash</span> field<br><span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Hsetnx 如果key不存在则创建成功，存在则不成功</span><br>127.0.0.1:6379&gt; hsetnx <span class="hljs-built_in">hash</span> field1 1   <span class="hljs-comment">#因为hash中没有field1，创建成功</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hsetnx <span class="hljs-built_in">hash</span> field1 2 <span class="hljs-comment">#因为hash中已经有了field1,创建失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure>

<p>从上面的命令可以看出来，hash和string的操作很像。hash更适合于对象的存储，string更适合于字符串存储。</p>
<h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><p>在set的基础上增加了一个值  ，set添加数组的时候<code>sadd k1 v1</code> 而zset添加时<code>zadd k1 score1 v1</code></p>
<p>在key-value中间多了一个数字，这个数字用来排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">######################</span><br><span class="hljs-comment">#Zadd 向zset中添加数据，并指定一个值，可以根据这个值进行排序。</span><br>127.0.0.1:6379&gt; zadd zset1 1 one    <span class="hljs-comment">#向zset1中添加数据，指定score为1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd zset1 2 two 3 three<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; zrange zset1 0 -1  <span class="hljs-comment">#添加多个数据，score为2 3</span><br>1) <span class="hljs-string">&quot;one&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br>127.0.0.1:6379&gt; <br><span class="hljs-comment">#########################</span><br><span class="hljs-comment">#Zrangebyscore 获取zset中的value，并根据设定的score的值进行排序，升序排序。</span><br><span class="hljs-comment">#Zrevrangebyscore 获取zsetz中的value,根据设定的score的值进行排序，降序排序。</span><br>127.0.0.1:6379&gt; zadd salary 2500 xh<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd salary 3000 xm<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd salary 5000 pty<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrangebyscore salary -inf +inf   <span class="hljs-comment">#根据score获取zset的value,score的取值范围为负无穷到正无穷，inf表示无穷大。 inf处的值可以任意修改</span><br>1) <span class="hljs-string">&quot;xh&quot;</span><br>2) <span class="hljs-string">&quot;xm&quot;</span><br>3) <span class="hljs-string">&quot;pty&quot;</span><br>127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores <span class="hljs-comment">#不仅根据score获取zset中的value，同时还获取相对应的score</span><br>1) <span class="hljs-string">&quot;xh&quot;</span><br>2) <span class="hljs-string">&quot;2500&quot;</span><br>3) <span class="hljs-string">&quot;xm&quot;</span><br>4) <span class="hljs-string">&quot;3000&quot;</span><br>5) <span class="hljs-string">&quot;pty&quot;</span><br>6) <span class="hljs-string">&quot;5000&quot;</span><br>127.0.0.1:6379&gt; zrevrangebyscore salary +inf -inf withscores  <span class="hljs-comment">#降序排序</span><br>1) <span class="hljs-string">&quot;pty&quot;</span><br>2) <span class="hljs-string">&quot;5000&quot;</span><br>3) <span class="hljs-string">&quot;xm&quot;</span><br>4) <span class="hljs-string">&quot;3000&quot;</span><br>5) <span class="hljs-string">&quot;xh&quot;</span><br>6) <span class="hljs-string">&quot;2500&quot;</span><br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#Zrem   移除指定的value</span><br>127.0.0.1:6379&gt; zrem salary xh    <span class="hljs-comment">#移除salary中的xh</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrange salary 0 -1<br>1) <span class="hljs-string">&quot;xm&quot;</span><br>2) <span class="hljs-string">&quot;pty&quot;</span><br><span class="hljs-comment">#####################################</span><br><span class="hljs-comment">#Zcard 获取zset中的数量</span><br>127.0.0.1:6379&gt; zcard salary   <span class="hljs-comment">#获取salary中的数量</span><br>(<span class="hljs-built_in">integer</span>) 2<br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Zcount  获取zset中指定区间的成员数量</span><br>127.0.0.1:6379&gt; zadd zet 1 hello 2 pty 3 hahah  <br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zcount zet 1 3   <span class="hljs-comment">#获取zet中score为1 - 3的成员数量</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zcount zet 1 2    <span class="hljs-comment">#获取zet中score为1 - 2的成员数量</span><br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure>

<p>可以用来做排行榜。</p>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial(地理位置)"></a>geospatial(地理位置)</h3><p>朋友的定位，附近的人，打车距离计算……</p>
<p><a href="https://www.redis.net.cn/order/3685.html">文档</a></p>
<blockquote>
<p>Geoadd：将指定的地理空间位置（纬度、经度、名称）添加到指定的<code>key</code>中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#geoadd  向key中添加指定的经纬度，先写经度，再写纬度。</span><br><span class="hljs-comment">#有效的经度从-180度到180度。有效的纬度从-85.05112878度到85.05112878度。</span><br><span class="hljs-comment">#两级无法直接添加，一般是下载城市数据，通过java程序一次性导入</span><br>127.0.0.1:6379&gt; geoadd city 116.41 39.90 beijing 121.47 31.23 shanghai 108.95 34.26 xian<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; geoadd city 118.77 32.04 nanjing<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd city 106.50 29.5 chongqing<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Geopos：从<code>key</code>里返回所有给定位置元素的位置（经度和纬度）。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Geopos:获取key中指定位置的经纬度。</span><br>127.0.0.1:6379&gt; geopos city beijing shanghai xian   <span class="hljs-comment">#获取北京，上海，西安的经纬度</span><br>1) 1) <span class="hljs-string">&quot;116.40999823808670044&quot;</span><br>   2) <span class="hljs-string">&quot;39.90000009167092543&quot;</span><br>2) 1) <span class="hljs-string">&quot;121.47000163793563843&quot;</span><br>   2) <span class="hljs-string">&quot;31.22999903975783553&quot;</span><br>3) 1) <span class="hljs-string">&quot;108.95000249147415161&quot;</span><br>   2) <span class="hljs-string">&quot;34.25999964418929977&quot;</span><br>127.0.0.1:6379&gt; geopos city nanjing  <span class="hljs-comment">#获取南京的经纬度</span><br>1) 1) <span class="hljs-string">&quot;118.76999884843826294&quot;</span><br>   2) <span class="hljs-string">&quot;32.03999960287850968&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Geodist：返回两个给定位置之间的距离</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Geodist:返回两个给定位置之间的距离</span><br><span class="hljs-comment">#如果有一个位置不存在key中，则返回空值</span><br><span class="hljs-comment"># m 表示单位为米。</span><br><span class="hljs-comment"># km 表示单位为千米。</span><br><span class="hljs-comment"># mi 表示单位为英里。</span><br><span class="hljs-comment"># ft 表示单位为英尺。</span><br><span class="hljs-comment">#如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</span><br>127.0.0.1:6379&gt; geodist city beijing shanghai   <span class="hljs-comment">#获取北京到上海的距离 没写单位，默认以m为单位</span><br><span class="hljs-string">&quot;1066992.3081&quot;</span><br>127.0.0.1:6379&gt; geodist city beijing shanghai km <span class="hljs-comment">#获取北京到上海的距离，以km为单位</span><br><span class="hljs-string">&quot;1066.9923&quot;</span> <br></code></pre></td></tr></table></figure>

<blockquote>
<p>Georadius：已给定的经纬度为中心，找出某一半径内的元素</p>
</blockquote>
<p>范围可以使用以下其中一个单位：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>在给定以下可选项时， 命令会返回额外的信息：</p>
<ul>
<li><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。</li>
<li><code>WITHHASH</code>: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
</ul>
<p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>
<ul>
<li><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
<li>count：设置一个数字，可以只获取排序在前的指定数量的元素。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; georadius city 100 35 1000 km  <br><span class="hljs-comment">#获取以经纬度 100 35为中心，半径为1000km以内的元素，元素必须在key中才能获取</span><br>1) <span class="hljs-string">&quot;xian&quot;</span><br>2) <span class="hljs-string">&quot;chongqing&quot;</span><br>127.0.0.1:6379&gt; georadius city 100 35 1000 km count 1  <span class="hljs-comment">#使用count控制获取的数量</span><br>1) <span class="hljs-string">&quot;xian&quot;</span><br>127.0.0.1:6379&gt; georadius city 100 35 1000 km withdist  <span class="hljs-comment">#获取元素的同时返回元素与中心的直线距离</span><br>1) 1) <span class="hljs-string">&quot;xian&quot;</span><br>   2) <span class="hljs-string">&quot;822.9592&quot;</span><br>2) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) <span class="hljs-string">&quot;864.4890&quot;</span><br>127.0.0.1:6379&gt; georadius city 100 35 1000 km withcoord  <span class="hljs-comment">#获取元素同时返回元素的经纬度</span><br>1) 1) <span class="hljs-string">&quot;xian&quot;</span><br>   2) 1) <span class="hljs-string">&quot;108.95000249147415161&quot;</span><br>      2) <span class="hljs-string">&quot;34.25999964418929977&quot;</span><br>2) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) 1) <span class="hljs-string">&quot;106.49999767541885376&quot;</span><br>      2) <span class="hljs-string">&quot;29.50000115408581536&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Georadiusbymember：找出位于指定范围内的元素，中心点有给定的位置元素</p>
</blockquote>
<p>这个命令与上面的Georadius命令功能差不多，区别在于上面的命令需要自己输入中心点的坐标，而这个命令是给出一个位置元素，以他的经纬度作为中心点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; georadiusbymember city shanghai 500 km   <span class="hljs-comment">#找出以上海为中心，半径为500km以内的元素</span><br>1) <span class="hljs-string">&quot;shanghai&quot;</span><br>2) <span class="hljs-string">&quot;nanjing&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Geohash：返回一个或多个位置元素的 Geohash 表示</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geohash city nanjing <span class="hljs-comment">#返回nanjing的经纬度，并将二维的经纬度转换为一维的字符串</span><br>1) <span class="hljs-string">&quot;wtsqq8twt80&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>Geo底层的实现原理其实就是Zset！我们可以使用Zset命令来操作geo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zrange city 0 -1<br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>3) <span class="hljs-string">&quot;shanghai&quot;</span><br>4) <span class="hljs-string">&quot;nanjing&quot;</span><br>5) <span class="hljs-string">&quot;beijing&quot;</span><br>127.0.0.1:6379&gt; zrem city beijing<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrange city 0 -1<br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>3) <span class="hljs-string">&quot;shanghai&quot;</span><br>4) <span class="hljs-string">&quot;nanjing&quot;</span><br>127.0.0.1:6379&gt; geopos beijing<br>(empty array)<br></code></pre></td></tr></table></figure>

<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>用来统计基数。</p>
<p>什么是基数？ 基数就是在一个集合中，不重复的数字的数量。如A{1,2,3,4,3,5} 这个集合的基数就是5。</p>
<p>应用场景：在统计访问量的时候，一个人多次访问一个网站，还是算作一个人。这个时候就需要统计基数。</p>
<p>优点：占用的内存是固定的，2^64个不同元素的基数，只需要12kb的内存。</p>
<p>有0.81%的错误率，如果允许错误，可以使用Hyperloglog。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Pfadd 向key中添加元素</span><br>127.0.0.1:6379&gt; pfadd key a b c d e f g h i j k  <span class="hljs-comment">#向key中添加元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfcount key  <span class="hljs-comment">#统计key中的基数</span><br>(<span class="hljs-built_in">integer</span>) 11 <br>127.0.0.1:6379&gt; pfadd key1 f g h i k m n s <span class="hljs-comment">#向key1中添加元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfcount key1  <span class="hljs-comment">#统计key1中的基数</span><br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; pfmerge key3 key key1  <span class="hljs-comment">#将key 和 key1的元素合并到key3中。</span><br>OK<br>127.0.0.1:6379&gt; pfcount key3  <span class="hljs-comment">#统计key3中的基数，key3由key和key1合并而来，应该有19个数，但因为统计的是基数，有5个重复了，所以基数只有14个。</span><br>(<span class="hljs-built_in">integer</span>) 14<br></code></pre></td></tr></table></figure>

<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Bitmaps 位图，数据结构，都是操作二进制位来进行记录，只有0和1两个状态</p>
<p>统计用户活跃，不活跃，打卡，未打卡等两个状态的，都可以使用Bitmaps</p>
<p>以下以打卡为例子来讲解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#setbit 向key中添加数据，第一个数字为坐标，第二个数字代表状态，只能为 1或者0</span><br>127.0.0.1:6379&gt; setbit sign 0 1    <span class="hljs-comment">#设置第一天的状态为1</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 1 0   <span class="hljs-comment">#设置第二天的状态为0</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 1 3   <span class="hljs-comment">#可以看到当第二个数字不是1或0时报错</span><br>(error) ERR bit is not an <span class="hljs-built_in">integer</span> or out of range<br>127.0.0.1:6379&gt; setbit sign 2 0   <span class="hljs-comment">#设置第三天的状态为0</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 3 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 4 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 5 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 6 1<br>(<span class="hljs-built_in">integer</span>) 0<br><span class="hljs-comment">#########################################</span><br><span class="hljs-comment">#getbit 查看某一个坐标的状态，是0还是1</span><br>127.0.0.1:6379&gt; getbit sign 6<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; getbit sign 2<br>(<span class="hljs-built_in">integer</span>) 0<br><span class="hljs-comment">##########################################</span><br><span class="hljs-comment">#bitcount 统计状态为1的坐标的数量</span><br>127.0.0.1:6379&gt; bitcount sign<br>(<span class="hljs-built_in">integer</span>) 4<br></code></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis事务本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p>
<p>一次性、顺序性、排他性。</p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会被执行。</p>
<p><strong>Redis单条命令是有原子性的，但是事务不保证原子性！</strong> </p>
<p>redis的事务：</p>
<ul>
<li>开启事务(multi)</li>
<li>命令入队()</li>
<li>执行事务(exec)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># multi  开启事务</span><br><span class="hljs-comment"># exec  执行事务</span><br>127.0.0.1:6379&gt; multi    <span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1   <span class="hljs-comment">#输入一些命令</span><br>QUEUED                      <span class="hljs-comment">#可以看到并没有直接返回结果，而是将命令入队</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>    <span class="hljs-comment">#执行事务</span><br>1) OK                    <span class="hljs-comment">#将上述命令的结果按照入队的顺序返回</span><br>2) OK<br>3) <span class="hljs-string">&quot;v1&quot;</span><br>4) OK<br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment">#Discard  放弃事务</span><br>127.0.0.1:6379&gt; multi     <span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1   <span class="hljs-comment">#输入命令</span><br>QUEUED                      <span class="hljs-comment">#命令入队</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; discard  <span class="hljs-comment">#放弃事务</span><br>OK<br>127.0.0.1:6379&gt; get k3    <span class="hljs-comment">#因为要输入实行事务命令后，入队的命令才回执行。放弃了事务，所以入队的命名没有执行，所有get不到k3</span><br>(nil)<br><br></code></pre></td></tr></table></figure>

<h3 id="监控（watch"><a href="#监控（watch" class="headerlink" title="监控（watch)"></a>监控（watch)</h3><p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，什么时候都会出现问题，无论做什么都会加锁。</li>
<li>性能低下。</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>乐观，认为什么时候都不会出现错误，所以不会上锁！更新数据的时候去判断一下在此期间是否有人修改过这个数据</li>
</ul>
<p>正常成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 50  <br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> out 0<br>OK<br>127.0.0.1:6379&gt; watch money   <span class="hljs-comment">#监视money字段</span><br>OK<br>127.0.0.1:6379&gt; multi    <span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379&gt; decrby money 10  <span class="hljs-comment">#money自减10</span><br>QUEUED<br>127.0.0.1:6379&gt; incrby out 10   <span class="hljs-comment">#money自增10</span><br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>   <span class="hljs-comment">#执行事务，事务正常结束</span><br>1) (<span class="hljs-built_in">integer</span>) 40<br>2) (<span class="hljs-built_in">integer</span>) 10<br></code></pre></td></tr></table></figure>

<p>使用多线程修改money的值，<strong>watch可以当做redis的乐观锁操作</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; watch money   <span class="hljs-comment">#监视money</span><br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; decrby money 20   <br>QUEUED<br>127.0.0.1:6379&gt; incrby out 20<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>   <span class="hljs-comment">#执行事务，在这一步之前，使用多线程修改了money的值，执行事务后才会执行入队的命令，在执行decrby money 20 命令的时候会比较money的值与开启事务前是否一样，如果不一样执行失败</span><br>(nil)<br>127.0.0.1:6379&gt; unwatch    <span class="hljs-comment">#如果事务执行失败，先解锁</span><br>OK<br>127.0.0.1:6379&gt; watch money   <span class="hljs-comment">#重新监视money，因为已经修改了money的值（看下面那个程序）,所以money为50</span><br>OK<br>127.0.0.1:6379&gt; multi     <span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379&gt; decrby money 10   <br>QUEUED<br>127.0.0.1:6379&gt; incrby out 10   <br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>    <span class="hljs-comment">#执行事务   比对监视的值（money）是否发生改变</span><br>1) (<span class="hljs-built_in">integer</span>) 40<br>2) (<span class="hljs-built_in">integer</span>) 20<br></code></pre></td></tr></table></figure>

<p>多线程修改了money的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; incrby money 10<br>(<span class="hljs-built_in">integer</span>) 50<br></code></pre></td></tr></table></figure>

<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis是Redis官方推荐的java连接开发工具，使用java操作redis的中间件。</p>
<ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>编码测试</li>
</ol>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
<p>​    redis的操作命令在jedis中是方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pty</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建Jedis对象,公网ip，端口号</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;47.94.228.33&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//设置的密码</span><br>        jedis.auth(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//执行redis命令。</span><br>        System.out.println(jedis.getrange(<span class="hljs-string">&quot;k1&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>));<br>        System.out.println(jedis.getrange(<span class="hljs-string">&quot;k2&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SpringBoot整合redis"><a href="#SpringBoot整合redis" class="headerlink" title="SpringBoot整合redis"></a>SpringBoot整合redis</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><p>在新建springboot项目的时候，在nosql部分勾选redis。或者是直接导入依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在springboot2.x之后，原来使用的jedis被替换成了lettuce.</p>
<p>jedis：采用的是直连，多个线程操作的话不安全。如果想要避免不安全，使用jedis pool连接池。</p>
<p>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况，可以减少线程数据。</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br><span class="hljs-comment">//ConditionalOnMissingBean 这个注解的意思是如果不存在才生效，意思就是如果我们自己编写了一个redisTemplate，则这个Bean不生效。我们可以自己写一个来redisTemplate来替换官方的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>      <span class="hljs-comment">//默认的RedisTemplate 没有过多的设置，redis对象都是需要序列化</span><br>     <span class="hljs-comment">//泛型是object object 类型，我们后面需要强制转换&lt;string object&gt;</span><br>   RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>   template.setConnectionFactory(redisConnectionFactory);<br>   <span class="hljs-keyword">return</span> template;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//因为String是redis中最常用的类型，所以单独提出了一个bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>   StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>   template.setConnectionFactory(redisConnectionFactory);<br>   <span class="hljs-keyword">return</span> template;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2020/10/12/Linux/</url>
    <content><![CDATA[<h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><p>使用xshell工具在windows系统上连接Linux云服务器</p>
<a id="more"></a>

<ol>
<li>新建连接</li>
</ol>
<p><img src="images/blog/image-20201008124927869.png" alt="image-20201008124927869"></p>
<ol start="2">
<li>建立连接</li>
</ol>
<p><img src="images/blog/image-20201008125328043.png" alt="image-20201008125328043"></p>
<ol start="3">
<li>然后点击会话，输入用户名密码即可连接成功。</li>
</ol>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>使用xftp工具将本地的文件上传到云服务器</p>
<p><img src="images/blog/image-20201008130105924.png" alt="image-20201008130105924"></p>
<h2 id="走进Linux"><a href="#走进Linux" class="headerlink" title="走进Linux"></a>走进Linux</h2><h3 id="开机登录"><a href="#开机登录" class="headerlink" title="开机登录"></a>开机登录</h3><p>开机会启动许多程序，它们在Windows叫做服务，在Linux中叫做守护进程</p>
<p>开机成功后，会显示一个文本登录界面，这就是我们经常看到的登录界面。</p>
<p>在Linux中最高权限账户为root，可以操作一切！</p>
<h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><p><strong>Linux中没有错误就代表操作成功</strong></p>
<p>关机指令为：shutdown</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sync <span class="hljs-comment"># 将数据由内存同步到硬盘中。</span><br><br>shutdown <span class="hljs-comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><br>shutdown –h 10 <span class="hljs-comment"># 这个命令告诉大家，计算机将在10分钟后关机</span><br><br>shutdown –h now <span class="hljs-comment"># 立马关机</span><br><br>shutdown –h 20:25 <span class="hljs-comment"># 系统会在今天20:25关机</span><br><br>shutdown –h +10 <span class="hljs-comment"># 十分钟后关机</span><br><br>shutdown –r now <span class="hljs-comment"># 系统立马重启</span><br><br>shutdown –r +10 <span class="hljs-comment"># 系统十分钟后重启</span><br><br>reboot <span class="hljs-comment"># 就是重启，等同于 shutdown –r now</span><br><br>halt <span class="hljs-comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span><br></code></pre></td></tr></table></figure>

<p>注意：<strong>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</strong></p>
<h3 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h3><ol>
<li>一切皆文件</li>
<li>根目录 /， 所有的文件都挂载在这个节点下</li>
</ol>
<p>登录系统后，在当前命令窗口下输入命令：</p>
<p><code>ls /</code></p>
<p>就会看到如下图所示：可以查看所有的文件目录</p>
<p><img src="images/blog/image-20201008132435573.png" alt="image-20201008132435573"></p>
<p>树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下）</p>
<p><img src="images/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201008132509.jpg" alt="系统结构目录"></p>
<p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。<em>不要动</em></li>
<li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li>==<strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录==。</li>
<li>==<strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。==</li>
<li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。<em>不要动</em></li>
<li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。<em>存放突然关机的一些文件</em></li>
<li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。<em>会把一些本地文件挂载在这个目录下</em></li>
<li>==<strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。==</li>
<li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<em>不用管</em></li>
<li>==<strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。==</li>
<li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li>
<li>==<strong>/tmp</strong>：这个目录是用来存放一些临时文件的。<em>用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，比如说安装包</em>==</li>
<li>==<strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。==</li>
<li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li>
<li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li>
<li>==<strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。==</li>
<li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
<li>==<strong>www：</strong>存放服务器网站相关的资源，环境，网站的项目==</li>
</ul>
<h2 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><blockquote>
<p>绝对路径和相对路径</p>
</blockquote>
<p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<p><strong>绝对路径：</strong></p>
<p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p>
<p><strong>相对路径：</strong></p>
<p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！</p>
<blockquote>
<p>处理目录的常用命令</p>
</blockquote>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls: 列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录</li>
<li>rm: 移除文件或目录</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>ls （列出目录）</p>
</blockquote>
<p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls [-aAdfFhilnrRSt] 目录名称</span><br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a参数 ：all，查看全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-l ：列出所有的文件，包含文件的属性与权限等等数据，没有隐藏文件；(常用)</li>
</ul>
<p><strong>所有的Linux命令都可以组合使用</strong></p>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -al ~</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>cd （切换目录）</p>
</blockquote>
<p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 目录名[相对路径或绝对路径]<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到用户目录下</span><br>[root@kuangshen /]<span class="hljs-comment"># cd home  </span><br><br><span class="hljs-comment"># 使用 mkdir 命令创建 kuangstudy 目录</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir kuangstudy</span><br><br><span class="hljs-comment"># 进入 kuangstudy 目录</span><br>[root@kuangshen home]<span class="hljs-comment"># cd kuangstudy</span><br><br><span class="hljs-comment"># 回到上一级</span><br>[root@kuangshen kuangstudy]<span class="hljs-comment"># cd ..</span><br><br><span class="hljs-comment"># 回到根目录</span><br>[root@kuangshen kuangstudy]<span class="hljs-comment"># cd /</span><br><br><span class="hljs-comment"># 表示回到自己的家目录，即回到 /root 这个目录  </span><br>[root@kuangshen kuangstudy]<span class="hljs-comment"># cd ~</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>pwd ( 显示目前所在的目录 )</p>
</blockquote>
<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@kuangshen kuangstudy]</span><span class="hljs-selector-id">#pwd</span> <span class="hljs-selector-attr">[-P]</span><br></code></pre></td></tr></table></figure>

<p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单纯显示出目前的工作目录</span><br>[root@kuangshen ~]<span class="hljs-comment"># pwd</span><br>/root<br><br><span class="hljs-comment"># 如果是链接，要显示真实地址，可以使用 -P参数</span><br>[root@kuangshen /]<span class="hljs-comment"># cd bin</span><br>[root@kuangshen bin]<span class="hljs-comment"># pwd -P</span><br>/usr/bin<br></code></pre></td></tr></table></figure>

<blockquote>
<p>mkdir （创建新目录）</p>
</blockquote>
<p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">mkdir</span> [-mp] 目录名称<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！即直接创建<code>test1/test2/test3</code>三层文件夹</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入我们用户目录下</span><br>[root@kuangshen /]<span class="hljs-comment"># cd /home</span><br><br><span class="hljs-comment"># 创建一个 test 文件夹</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir test</span><br><br><span class="hljs-comment"># 创建多层级目录</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir test1/test2/test3/test4</span><br>mkdir: cannot create directory ‘test1/test2/test3/test4’:<br>No such file or directory  <span class="hljs-comment"># &lt;== 没办法直接创建此目录啊！</span><br><br><span class="hljs-comment"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir -p test1/test2/test3/test4</span><br><br><span class="hljs-comment"># 创建权限为 rwx--x--x 的目录。</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir -m 711 test2</span><br>[root@kuangshen home]<span class="hljs-comment"># ls -l</span><br>drwxr-xr-x 2 root root  4096 Mar 12 21:55 <span class="hljs-built_in">test</span><br>drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1<br>drwx--x--x 2 root root  4096 Mar 12 21:58 test2<br></code></pre></td></tr></table></figure>

<blockquote>
<p>rmdir ( 删除空的目录 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">rmdir</span> [-p] 目录名称<br></code></pre></td></tr></table></figure>

<p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 看看有多少目录存在？</span><br>[root@kuangshen home]<span class="hljs-comment"># ls -l</span><br>drwxr-xr-x 2 root root  4096 Mar 12 21:55 <span class="hljs-built_in">test</span><br>drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1<br>drwx--x--x 2 root root  4096 Mar 12 21:58 test2<br><br><span class="hljs-comment"># 可直接删除掉，没问题</span><br>[root@kuangshen home]<span class="hljs-comment"># rmdir test</span><br><br><span class="hljs-comment"># 因为尚有内容，所以无法删除！</span><br>[root@kuangshen home]<span class="hljs-comment"># rmdir test1</span><br>rmdir: failed to remove ‘test1’: Directory not empty<br><br><span class="hljs-comment"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span><br>[root@kuangshen home]<span class="hljs-comment"># rmdir -p test1/test2/test3/test4</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：这个 rmdir 仅能删除空的目录，如果下面存在文件，需要先删除文件，递归删除多个目录加上 -p 参数。</strong></p>
<p><strong>可以使用 rm 命令来删除非空目录。</strong></p>
<blockquote>
<p>cp ( 复制文件或目录 )</p>
</blockquote>
<p>语法：     </p>
<p>cp 原来的地方 新的地方！ </p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[root@www ~]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-attr">[-adfilprsu]</span> 来源档(source) 目标档(destination)<br><span class="hljs-selector-attr">[root@www ~]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-tag">source1</span> <span class="hljs-selector-tag">source2</span> <span class="hljs-selector-tag">source3</span> .... <span class="hljs-selector-tag">directory</span><br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li>
<li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@kuangshen home]<span class="hljs-comment"># cp install.sh  kuangstudy  #拷贝文件至目录  这里是将install.sh 由home拷贝到kuangstudy</span><br><br><span class="hljs-comment">#如果文件重复，会询问是否覆盖</span><br>[root@kuangshen home]<span class="hljs-comment"># cp install.sh  kuangstudy</span><br>cp: overwrite ‘kuangstudy/install.sh’? y <span class="hljs-comment"># n不覆盖，y为覆盖</span><br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>rm ( 移除文件或目录 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">rm</span> <span class="hljs-selector-attr">[-fir]</span> 文件或目录<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息，强制删除；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><br>[root@kuangshen home]<span class="hljs-comment"># rm -i install.sh</span><br>rm: remove regular file ‘install.sh’? y<br><span class="hljs-comment"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br><br><span class="hljs-comment"># 尽量不要在服务器上使用 rm -rf /  这个命令会删除系统中的所有文件（该文件夹下的所有东西都被删除），删库跑路就是这么操作的</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>mv  ( 移动文件与目录，或修改名称 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@www ~]<span class="hljs-comment"># mv [-fiu] source destination</span><br>[root@www ~]<span class="hljs-comment"># mv [options] source1 source2 source3 .... directory</span><br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：只更换比较新的文件</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制一个文件到当前目录</span><br>[root@kuangshen home]<span class="hljs-comment"># cp /root/install.sh /home</span><br><br><span class="hljs-comment"># 创建一个文件夹 test</span><br>[root@kuangshen home]<span class="hljs-comment"># mkdir test</span><br><br><span class="hljs-comment"># 将复制过来的文件移动到我们创建的目录，并查看</span><br>[root@kuangshen home]<span class="hljs-comment"># mv install.sh test</span><br>[root@kuangshen home]<span class="hljs-comment"># ls</span><br><span class="hljs-built_in">test</span><br>[root@kuangshen home]<span class="hljs-comment"># cd test</span><br>[root@kuangshen <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span><br>install.sh<br><br><span class="hljs-comment"># 将文件夹重命名，然后再次查看！</span><br>[root@kuangshen <span class="hljs-built_in">test</span>]<span class="hljs-comment"># cd ..</span><br>[root@kuangshen home]<span class="hljs-comment"># mv test mvtest</span><br>[root@kuangshen home]<span class="hljs-comment"># ls</span><br>mvtest<br></code></pre></td></tr></table></figure>



<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><blockquote>
<p>看懂文件属性</p>
</blockquote>
<p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组。</p>
<p><img src="images/blog/image-20201008202333515.png" alt="image-20201008202333515"></p>
<p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>==当为[ <strong>d</strong> ]则是目录==</li>
<li>==当为[ <strong>-</strong> ]则是文件；==</li>
<li>==若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；==</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<p><img src="images/blog/image-20201008203048944.png" alt="image-20201008203048944"></p>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。<em>第一个root位置表示属主，第二个root表示属组</em></p>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<p><strong>1、chgrp：更改文件属组</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">chgrp</span> <span class="hljs-selector-attr">[-R]</span> 属组名 文件名<br></code></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p>3vS_j:hG/n&lt;,</p>
<p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">chown</span> <span class="hljs-selector-attr">[–R]</span> 属主名 文件名<br><span class="hljs-selector-tag">chown</span> <span class="hljs-selector-attr">[-R]</span> 属主名：属组	名 文件名<br></code></pre></td></tr></table></figure>

<p>==<strong>3、chmod：更改文件9个属性（必须要掌握）</strong>==</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">chmod</span> <span class="hljs-selector-attr">[-R]</span> <span class="hljs-selector-tag">xyz</span> 文件或目录<br></code></pre></td></tr></table></figure>

<p>Linux文件属性有两种设置方法，一种是数字(常用的是数字），一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">r:<span class="hljs-number">4</span>     w:<span class="hljs-number">2</span>         x:<span class="hljs-number">1</span><br><br>可读可写不可执行    rw- <span class="hljs-number">6</span><br>可读可写可执行      rwx <span class="hljs-number">7</span><br>chmod <span class="hljs-number">777</span>  文件赋予所有用户可读可写可执行<br></code></pre></td></tr></table></figure>

<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chmod 770 filename<br><span class="hljs-comment"># 把filename设置权限为rwxrwx---</span><br></code></pre></td></tr></table></figure>



<h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>==cat 由第一行开始显示文件内容 ，==</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！看代码的时候希望显示行号</li>
<li>more 一页一页的显示文件内容 ==空格表示翻页，enter代表向下看一行 :f可以看到当前的行号==</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！==空格下翻页，上下键代表翻动页面！q命令退出==</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<p>网络配置目录：<code>cd /etc/sysconfig/network-scripts</code></p>
<p><img src="images/blog/image-20201008210213118.png" alt="image-20201008210213118"></p>
<p><strong>使用ifconfig来查看网络配置</strong></p>
<blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<p>语法：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span><span class="hljs-meta"> [-AbEnTv]</span><br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span><br>[root@kuangshen ~]<span class="hljs-comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br>DEVICE=eth0<br>BOOTPROTO=dhcp<br>ONBOOT=yes<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tac</p>
</blockquote>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@kuangshen ~]<span class="hljs-comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><br>ONBOOT=yes<br>BOOTPROTO=dhcp<br>DEVICE=eth0<br></code></pre></td></tr></table></figure>



<blockquote>
<p>nl  显示行号</p>
</blockquote>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nl</span> <span class="hljs-selector-attr">[-bnw]</span> 文件<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@kuangshen ~]<span class="hljs-comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span><br>1DEVICE=eth0<br>2BOOTPROTO=dhcp<br>3ONBOOT=yes<br></code></pre></td></tr></table></figure>



<blockquote>
<p>more  一页一页翻动</p>
</blockquote>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter   ：代表向下翻『一行』；</li>
<li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f    ：立刻显示出档名以及目前显示的行数；</li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@kuangshen etc]<span class="hljs-comment"># more /etc/csh.login</span><br>[root@iZ2ze1m5qjg1tjthcel6gcZ etc]<span class="hljs-comment"># more csh.login</span><br><span class="hljs-comment"># /etc/csh.login</span><br><br><span class="hljs-comment"># System wide environment and startup programs, for login setup</span><br><br><span class="hljs-keyword">if</span> ( ! <span class="hljs-variable">$&#123;?PATH&#125;</span> ) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> ( <span class="hljs-variable">$uid</span> == 0 ) <span class="hljs-keyword">then</span><br>		setenv PATH <span class="hljs-string">&quot;/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin&quot;</span><br>        <span class="hljs-keyword">else</span><br>		setenv PATH <span class="hljs-string">&quot;/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin&quot;</span><br>        endif<br><span class="hljs-keyword">else</span><br>	<span class="hljs-comment">#add sbin directories to the path</span><br>	foreach p ( /usr/<span class="hljs-built_in">local</span>/sbin /usr/sbin )<br>		switch (<span class="hljs-string">&quot;:<span class="hljs-variable">$&#123;PATH&#125;</span>:&quot;</span>)<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*:<span class="hljs-variable">$&#123;p&#125;</span>:*&quot;</span>:<br>			breaksw<br>		default:<br>			<span class="hljs-keyword">if</span> ( <span class="hljs-variable">$uid</span> == 0 ) <span class="hljs-keyword">then</span><br>                        	<span class="hljs-built_in">set</span> path = ( <span class="hljs-variable">$&#123;p&#125;</span> <span class="hljs-variable">$&#123;path:q&#125;</span> )<br>			<span class="hljs-keyword">else</span><br>--More--(47%)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>less  一页一页翻动，以下实例输出/etc/man.config文件的内容：</p>
</blockquote>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/字串  ：向下搜寻『字串』的功能；</li>
<li>?字串  ：向上搜寻『字串』的功能；</li>
<li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q   ：离开 less 这个程序；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@iZ2ze1m5qjg1tjthcel6gcZ etc]<span class="hljs-comment"># less csh.login</span><br><br><br><span class="hljs-comment"># /etc/csh.login</span><br><br><span class="hljs-comment"># System wide environment and startup programs, for login setup</span><br><br><span class="hljs-keyword">if</span> ( ! <span class="hljs-variable">$&#123;?PATH&#125;</span> ) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> ( <span class="hljs-variable">$uid</span> == 0 ) <span class="hljs-keyword">then</span><br>                setenv PATH <span class="hljs-string">&quot;/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin&quot;</span><br>        <span class="hljs-keyword">else</span><br>                setenv PATH <span class="hljs-string">&quot;/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin&quot;</span><br>        endif<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">#add sbin directories to the path</span><br>        foreach p ( /usr/<span class="hljs-built_in">local</span>/sbin /usr/sbin )<br>                switch (<span class="hljs-string">&quot;:<span class="hljs-variable">$&#123;PATH&#125;</span>:&quot;</span>)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*:<span class="hljs-variable">$&#123;p&#125;</span>:*&quot;</span>:<br>                        breaksw<br>                default:<br>                        <span class="hljs-keyword">if</span> ( <span class="hljs-variable">$uid</span> == 0 ) <span class="hljs-keyword">then</span><br>                                <span class="hljs-built_in">set</span> path = ( <span class="hljs-variable">$&#123;p&#125;</span> <span class="hljs-variable">$&#123;path:q&#125;</span> )<br>                        <span class="hljs-keyword">else</span><br>csh.login<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>head  取出文件前面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">head [-n <span class="hljs-built_in">number</span>] 文件<br></code></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>kuangshen etc]# head -n <span class="hljs-number">20</span> /etc/csh.login<br></code></pre></td></tr></table></figure>



<blockquote>
<p>tail  取出文件后面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">tail [-n <span class="hljs-built_in">number</span>] 文件<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@kuangshen etc]<span class="hljs-comment"># tail -n 20 /etc/csh.login</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>拓展：Linux 链接概念</p>
</blockquote>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为软链接（Symbolic Link）。</p>
<p>情况下，<strong>ln</strong> 命令产生硬链接。</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，<strong>即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问</strong>。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong> </p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。<strong>软链接文件有类似于 Windows 的快捷方式，如果删除了原文件，那么快捷方式也访问不了了</strong>。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<ul>
<li>创建连接： ln命令 </li>
<li>touch 创建文件</li>
<li>echo 输入字符串</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@kuangshen /]<span class="hljs-comment"># cd /home</span><br>[root@kuangshen home]<span class="hljs-comment"># touch f1 # 创建一个测试文件f1</span><br>[root@kuangshen home]<span class="hljs-comment"># ls</span><br>f1<br>[root@kuangshen home]<span class="hljs-comment"># ln f1 f2     # 创建f1的一个硬连接文件f2 默认是硬链接</span><br>[root@kuangshen home]<span class="hljs-comment"># ln -s f1 f3   # 创建f1的一个符号连接文件f3 加个-s参数 创建的是软连接</span><br>[root@kuangshen home]<span class="hljs-comment"># ls -li       # -i参数显示文件的inode节点信息</span><br>397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1<br>397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2<br>397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1<br></code></pre></td></tr></table></figure>

<p><img src="images/blog/image-20201008214542041.png" alt="image-20201008214542041"></p>
<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而软连接文件的 inode 节点不同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span><br>[root@kuangshen home]<span class="hljs-comment"># echo &quot;I am f1 file&quot; &gt;&gt;f1</span><br>[root@kuangshen home]<span class="hljs-comment"># cat f1</span><br>I am f1 file<br>[root@kuangshen home]<span class="hljs-comment"># cat f2</span><br>I am f1 file<br>[root@kuangshen home]<span class="hljs-comment"># cat f3</span><br>I am f1 file<br>[root@kuangshen home]<span class="hljs-comment"># rm -f f1</span><br>[root@kuangshen home]<span class="hljs-comment"># cat f2</span><br>I am f1 file<br>[root@kuangshen home]<span class="hljs-comment"># cat f3</span><br>cat: f3: No such file or directory<br></code></pre></td></tr></table></figure>

<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是软连接 f1 文件无效；</p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h3 id="vim编译器"><a href="#vim编译器" class="headerlink" title="vim编译器"></a>vim编译器</h3><blockquote>
<p>什么是Vim编辑器</p>
</blockquote>
<p>vim通过一些插件可以实现和IDE一样的查看</p>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。==（查看内容，编辑内容，保存内容）==</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p>
<p>vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><img src="images/blog/64116-20191222111829090-17043451.gif" alt="vim键盘图"></p>
<blockquote>
<p>三种使用模式</p>
</blockquote>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong></p>
<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式。使用ESC</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<p><strong>输入模式：</strong></p>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<p><strong>底线命令模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。光标移动到了最底下，就可以在这里输入一些底线命令了</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p><img src="images/blog/image-20201008220932366.png" alt="image-20201008220932366"></p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="images/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201008221127.jpg" alt="vim操作流程"></p>
<blockquote>
<p>完整的演示说明</p>
</blockquote>
<ol>
<li>新建或者编辑文件  <code>vim filename</code></li>
<li>按i a o 进入输入模式，编写内容</li>
<li>编写完成后按ESC退出编辑模式</li>
<li>按:进入底线模式  输入<code>wq</code>保存退出</li>
</ol>
<blockquote>
<p>Vim 按键说明</p>
</blockquote>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p><strong>第一部分：一般模式（命令模式）可用的光标移动、复制粘贴、搜索替换等</strong></p>
<table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行  配置文件中空格较多使用这个方便</td>
</tr>
<tr>
<td align="left">==n&lt; space&gt;==</td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td align="left">==n&lt; Enter&gt;==</td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">==/word==</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">==n==</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">==N==</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">==u==</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody></table>
<p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">==i, I==</td>
<td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">==[Esc]==</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">==:wq==</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">==:set nu==</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<p>以上标红的掌握熟练即可，其余的了解，我们平时使用VIM最多的就是修改下文件内容而已！</p>
<h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><p>一般在公司中，员工用的都不是root账户</p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<blockquote>
<p>用户账号的管理</p>
</blockquote>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<blockquote>
<p>添加账号 useradd</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">useradd</span> 选项 用户名<br></code></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>选项 :</p>
</li>
<li><ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，给用户指定组。</li>
<li>-m　使用者目录如不存在则自动建立。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li><p>用户名 :</p>
</li>
<li><ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen</span><br>[root@kuangshen home]<span class="hljs-comment"># useradd -m kuangshen</span><br></code></pre></td></tr></table></figure>

<p>在Linux中一切皆文件，这里的添加用户说白了就是在<code>/etc/password</code>文件中写入用户的信息  ,同时更新其他系统文件如/etc/shadow,/etc/grou等。</p>
<blockquote>
<p>删除帐号</p>
</blockquote>
<p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">userdel</span> 选项 用户名<br></code></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">[root@kuangshen <span class="hljs-built_in">home</span>]<span class="hljs-meta"># userdel -r kuangshen</span><br></code></pre></td></tr></table></figure>

<p>此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<blockquote>
<p>修改用户</p>
</blockquote>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">usermod</span> 选项 用户名<br></code></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>例如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"># usermod -s <span class="hljs-regexp">/bin/</span>ksh -d <span class="hljs-regexp">/home/</span>z –g developer kuangshen<br></code></pre></td></tr></table></figure>

<p>此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<p>修改完毕之后查看配置文件即可。</p>
<blockquote>
<p>Linux下如何切换用户</p>
</blockquote>
<p><img src="images/blog/image-20201009142632806.png" alt="image-20201009142632806"></p>
<p><img src="images/blog/image-20201009143240133.png" alt="image-20201009143240133"></p>
<p>1.切换用户的命令为：su username 【username是你的用户名哦】</p>
<p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p>
<p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p>
<p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p>
<p>$表示普通用户    </p>
<p>#表示超级用户，也就是root用户</p>
<p><img src="images/blog/image-20201009143755163.png" alt="image-20201009143755163"></p>
<blockquote>
<p>用户的密码设置</p>
</blockquote>
<p>我们一般通过root创建用户的时候，需要配置密码</p>
<p>在Linux上输入密码是不会显示出来的，正常数据就行了，不是电脑或系统的问题 </p>
<p>超级用户设置密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">passwd username:<br>new password<br>re password   <span class="hljs-comment">#确认密码</span><br></code></pre></td></tr></table></figure>

<p><img src="images/blog/image-20201009145025270.png" alt="image-20201009145025270"></p>
<p>普通用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Old password:<br>New password:<br>Re-enter new password:<br></code></pre></td></tr></table></figure>

<p><img src="images/blog/image-20201009145220437.png" alt="image-20201009145220437"></p>
<blockquote>
<p>锁定账户</p>
</blockquote>
<p>冻结账户之后，这个账户就不能再登录！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">passwd -l pty <span class="hljs-comment">#将pty这个用户锁定，锁定之后这个用户就不能再登录</span><br>passwd -d pty <span class="hljs-comment">#清楚pty这个用户的密码，没有密码无法登陆</span><br>passwd -u pty <span class="hljs-comment">#启用已被停止的pty这个用户，让他能再次登录</span><br></code></pre></td></tr></table></figure>



<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，<strong>如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建</strong>。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。==组的增加、删除和修改实际上就是对/etc/group文件的更新。==</p>
<blockquote>
<p>增加一个新的用户组使用groupadd命令</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupadd</span> 选项 用户组<br></code></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># groupadd group1</span><br></code></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># groupadd -g 101 group2</span><br></code></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<p><img src="images/blog/image-20201009172752807.png" alt="image-20201009172752807"></p>
<blockquote>
<p>如果要删除一个已有的用户组，使用groupdel命令</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupdel</span> 用户组<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># groupdel group1</span><br></code></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<blockquote>
<p>修改用户组的属性使用groupmod命令</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupmod</span> 选项 用户组<br></code></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 此命令将组group2的组标识号修改为102。</span><br><span class="hljs-attribute">groupmod</span> -g <span class="hljs-number">102</span> group<span class="hljs-number">2</span><br><br><span class="hljs-comment"># 将组group2的标识号改为10000，组名修改为group3。</span><br><span class="hljs-attribute">groupmod</span> –g <span class="hljs-number">10000</span> -n group<span class="hljs-number">3</span> group<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>切换组</p>
</blockquote>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">$ <span class="hljs-keyword">new</span><span class="hljs-type">grp</span> root<br></code></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<blockquote>
<p>/etc/passwd</p>
</blockquote>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">＃ cat <span class="hljs-regexp">/etc/</span>passwd<br><br><span class="hljs-attr">root:</span><span class="hljs-attr">x:</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-attr">Superuser:</span>/:<br><span class="hljs-attr">daemon:</span><span class="hljs-attr">x:</span><span class="hljs-number">1</span>:<span class="hljs-number">1</span>:System <span class="hljs-attr">daemons:</span>/<span class="hljs-attr">etc:</span><br><span class="hljs-attr">bin:</span><span class="hljs-attr">x:</span><span class="hljs-number">2</span>:<span class="hljs-number">2</span>:Owner of system <span class="hljs-attr">commands:</span>/<span class="hljs-attr">bin:</span><br><span class="hljs-attr">sys:</span><span class="hljs-attr">x:</span><span class="hljs-number">3</span>:<span class="hljs-number">3</span>:Owner of system <span class="hljs-attr">files:</span><span class="hljs-regexp">/usr/</span><span class="hljs-attr">sys:</span><br><span class="hljs-attr">adm:</span><span class="hljs-attr">x:</span><span class="hljs-number">4</span>:<span class="hljs-number">4</span>:System <span class="hljs-attr">accounting:</span><span class="hljs-regexp">/usr/</span><span class="hljs-attr">adm:</span><br><span class="hljs-attr">uucp:</span><span class="hljs-attr">x:</span><span class="hljs-number">5</span>:<span class="hljs-number">5</span>:UUCP <span class="hljs-attr">administrator:</span><span class="hljs-regexp">/usr/</span>lib/<span class="hljs-attr">uucp:</span><br><span class="hljs-attr">auth:</span><span class="hljs-attr">x:</span><span class="hljs-number">7</span>:<span class="hljs-number">21</span>:Authentication <span class="hljs-attr">administrator:</span><span class="hljs-regexp">/tcb/</span>files/<span class="hljs-attr">auth:</span><br><span class="hljs-attr">cron:</span><span class="hljs-attr">x:</span><span class="hljs-number">9</span>:<span class="hljs-number">16</span>:Cron <span class="hljs-attr">daemon:</span><span class="hljs-regexp">/usr/</span>spool/<span class="hljs-attr">cron:</span><br><span class="hljs-attr">listen:</span><span class="hljs-attr">x:</span><span class="hljs-number">37</span>:<span class="hljs-number">4</span>:Network <span class="hljs-attr">daemon:</span><span class="hljs-regexp">/usr/</span>net/<span class="hljs-attr">nls:</span><br><span class="hljs-attr">lp:</span><span class="hljs-attr">x:</span><span class="hljs-number">71</span>:<span class="hljs-number">18</span>:Printer <span class="hljs-attr">administrator:</span><span class="hljs-regexp">/usr/</span>spool/<span class="hljs-attr">lp:</span><br></code></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录<span class="hljs-keyword">Shell</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pty:x:1000:1000::/home/pty:/bin/bash<br><br><span class="hljs-comment">#pty: 用户名</span><br><span class="hljs-comment">#x：口令（登录密码，我们看不见）</span><br><span class="hljs-comment">#1000：用户标示</span><br><span class="hljs-comment">#1000：组标示</span><br><span class="hljs-comment">#/home/pty 主目录</span><br><span class="hljs-comment">#/bin/bash 登录shell</span><br></code></pre></td></tr></table></figure>

<p>登录口令放在/etc/shadow中</p>
<p>用户组的所有信息放在/etc/group中</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量</li>
<li>du：检查磁盘空间使用量</li>
</ul>
<blockquote>
<p>df</p>
</blockquote>
<p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">df [-ahikHTm] [目录或文件名]<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将容量结果以易读的容量格式显示出来</span><br>[root@kuangshen /]<span class="hljs-comment"># df -h</span><br>Filesystem     Size Used Avail Use% Mounted on<br>devtmpfs       869M     0 869M   0% /dev<br>tmpfs           879M 708K 878M   1% /dev/shm<br>tmpfs           879M 496K 878M   1% /run<br>tmpfs           879M     0 879M   0% /sys/fs/cgroup<br>/dev/vda1       40G  6.3G   32G  17% /<br>tmpfs           176M     0 176M   0% /run/user/0<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 /etc 底下的可用的磁盘容量以易读的容量格式显示</span><br><br>[root@kuangshen /]<span class="hljs-comment"># df -h /etc</span><br>Filesystem     Size Used Avail Use% Mounted on<br>/dev/vda1       40G  6.3G   32G  17% /<br></code></pre></td></tr></table></figure>

<blockquote>
<p>du</p>
</blockquote>
<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">du [-ahskm] 文件或目录名称<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G/M) 显示；</li>
<li>-s ：列出总量，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</span><br><span class="hljs-comment"># 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</span><br>[root@kuangshen home]<span class="hljs-comment"># du</span><br>16./redis<br>8./www/.oracle_jre_usage  <span class="hljs-comment"># 包括隐藏文件的目录</span><br>24./www<br>48.                        <span class="hljs-comment"># 这个目录(.)所占用的总量</span><br><span class="hljs-comment"># 将文件的容量也列出来</span><br>[root@kuangshen home]<span class="hljs-comment"># du -a</span><br>4./redis/.bash_profile<br>4./redis/.bash_logout    <br>....中间省略....<br>4./kuangstudy.txt <span class="hljs-comment"># 有文件的列表了</span><br>48.<br><span class="hljs-comment"># 检查根目录底下每个目录所占用的容量</span><br>[root@kuangshen home]<span class="hljs-comment"># du -sm /*</span><br>0/bin<br>146/boot<br>.....中间省略....<br>0/proc<br>.....中间省略....<br>1/tmp<br>3026/usr  <span class="hljs-comment"># 系统初期最大就是他了啦！</span><br>513/var<br>2666/www<br></code></pre></td></tr></table></figure>

<p>通配符 * 来代表每个目录。</p>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>对于我们开发人员来说，其实Linux更多偏向于使用即可</p>
<blockquote>
<p>什么是进程</p>
</blockquote>
<ol>
<li>在Linux中，每一个程序都是由自己的一个进程，每一个进程都有自己的id号</li>
<li>每一个进程都有一个父进程</li>
<li>进程可以有两种存在方式：前台！后台运行！</li>
<li>一般的话服务都是后台运行的，基本的程序都是前台运行的！</li>
</ol>
<blockquote>
<p>命令</p>
</blockquote>
<p><strong>ps</strong>查看当前系统中正在执行的各种进程的信息！</p>
<p>ps-xx:</p>
<ul>
<li>-a 显示当前终端运行的所有进程的信息</li>
<li>-u 以用户的信息显示进程</li>
<li>-x 显示后台运行进程的参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ps -aux 查看所有的进程</span><br>ps -aux|<br><br><span class="hljs-comment"># |  在Linux中这个叫做管道符    A|B  把A的结果作为输出操作B命令</span><br><span class="hljs-comment"># grep 查找文件中符合条件的字符串</span><br></code></pre></td></tr></table></figure>

<p>对我我们来说，这里目前只需要记住一个命令即可  ps-xxx|grep 进程名   查找该进程名的全部信息</p>
<p><strong>ps -ef:可以查看到父进程的信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -ef|grep mysql   <span class="hljs-comment">#看父进程我们一般可以通过目录树结构来查看！</span><br><br><span class="hljs-comment">#进程树</span><br>pstree -pu<br>	-p  显示父id<br>	-u  显示用户组<br></code></pre></td></tr></table></figure>

<p>结束进程：杀掉进程，等价于window结束任务</p>
<p>kill-9 进程的id 表示强制结束进程</p>
<p>一般不需要结束进程，但有时候java程序进入死循环可以使用这个杀死程序</p>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>安装软件一般有三种方式：rpm、解压缩、yum在线安装！</p>
<h3 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h3><ol>
<li>下载jdk rpm。去Oracle官网下载</li>
<li>使用ftp工具将文件上传到服务器</li>
<li>安装java环境</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检测当前系统是否存在java环境！ java -version</span><br><span class="hljs-comment"># 如果有的话就需要卸载  </span><br><span class="hljs-comment"># rpm -qa|grep jdk    #检测JDK版本信息</span><br><span class="hljs-comment"># rpm -e --nodeps jdk_(jdk版本)</span><br><br><span class="hljs-comment">#卸载完毕后即可安装jdk</span><br><span class="hljs-comment"># rpm -ivk rpm包   安装jdk</span><br></code></pre></td></tr></table></figure>

<p><img src="images/blog/image-20201009195244369.png" alt="image-20201009195244369"></p>
<p><img src="images/blog/image-20201009195752656.png" alt="image-20201009195752656"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看firewall服务状态</span><br>systemctl status firewalld<br><br><span class="hljs-comment"># 开启、重启、关闭、firewalld.service服务</span><br><span class="hljs-comment"># 开启</span><br>service firewalld start<br><span class="hljs-comment"># 重启</span><br>service firewalld restart<br><span class="hljs-comment"># 关闭</span><br>service firewalld stop<br><br><span class="hljs-comment"># 查看防火墙规则</span><br>firewall-cmd --list-all    <span class="hljs-comment"># 查看全部信息</span><br>firewall-cmd --list-ports  <span class="hljs-comment"># 只看端口信息</span><br><br><span class="hljs-comment"># 开启端口</span><br>开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent  <span class="hljs-comment">#开启80端口，如果是阿里云需要配置安全组规则</span><br>重启防火墙：systemctl restart firewalld.service  <span class="hljs-comment">#开启端口后要重启防火墙</span><br><br>命令含义：<br>--zone <span class="hljs-comment">#作用域</span><br>--add-port=80/tcp  <span class="hljs-comment">#添加端口，格式为：端口/通讯协议</span><br>--permanent   <span class="hljs-comment">#永久生效，没有此参数重启后失效</span><br></code></pre></td></tr></table></figure>



<h3 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h3><ol>
<li><p>在官网下载tomcat文件</p>
</li>
<li><p>解压这个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tar -zxvf apache-tomcat-9.0.22.tar.gz<br></code></pre></td></tr></table></figure>
</li>
<li><p>启动tomcat程序  <code>./xxx.sh</code>脚本即可运行</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行  ./startup.sh</span><br><span class="hljs-comment"># 结束  ./shoutdown.sh</span><br></code></pre></td></tr></table></figure>

<h3 id="Docker-yum安装）"><a href="#Docker-yum安装）" class="headerlink" title="Docker(yum安装）"></a>Docker(yum安装）</h3><p>我们现在是在Linux下执行，一定要联网，yum是在线安装！</p>
<blockquote>
<p>安装</p>
</blockquote>
<ol>
<li>安装我们的准备环境（安装gcc)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum -y install 包名    <span class="hljs-comment">#yum install 安装命令  -y 所有的提示都为y</span><br>yum -y install gcc<br>yum -y install gcc-c++<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>卸载docker旧版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum remove docker \<br>          docker-client \<br>          docker-client-latest \<br>          docker-common \<br>          docker-latest \<br>          docker-latest-logrotate \<br>          docker-logrotate \<br>          docker-engine<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>安装需要的软件包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>设置stable镜像仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  <span class="hljs-comment">#阿里云镜像</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li>更新yum软件包索引</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></td></tr></table></figure>

<ol start="6">
<li>安装Docker CE</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum -y install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>启动docker</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure>

<ol start="8">
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker version    <span class="hljs-comment">#查看docker版本号</span><br> <br>docker run hello-world  <span class="hljs-comment"># 跑hello-world程序</span><br> <br>docker images   <span class="hljs-comment">#查看docker镜像</span><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2022/05/29/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h2><h3 id="三种常见模式："><a href="#三种常见模式：" class="headerlink" title="三种常见模式："></a>三种常见模式：</h3><ul>
<li><p>正常模式</p>
<p>在正常模式下，我们可以使用快捷键。</p>
</li>
<li><p>插入模式/编辑模式</p>
<p>在这个模式下，程序猿可以输入内容。</p>
</li>
<li><p>命令行模式</p>
<p>在这个模式中，可以提供相关指令。</p>
<a id="more"></a>

</li>
</ul>
<h3 id="快捷键使用练习："><a href="#快捷键使用练习：" class="headerlink" title="快捷键使用练习："></a>快捷键使用练习：</h3><ul>
<li>yy：拷贝当前行</li>
<li>5yy：拷贝当前5行</li>
<li>dd：删除当前行</li>
<li>5dd：删除当前行向下的5行</li>
<li>在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个,N向上查找</li>
<li>设置文件行号：set nu，取消文件行号：set nonu</li>
<li>编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg</li>
<li>撤销输入：在正常模式下输入u</li>
<li>编辑文件，光标移动到某行：shift+g<ul>
<li>显示行号：set nu</li>
<li>输入行号这个数</li>
<li>输入shift+g</li>
</ul>
</li>
</ul>
<h2 id="关机、重启和用户登录注销"><a href="#关机、重启和用户登录注销" class="headerlink" title="关机、重启和用户登录注销"></a>关机、重启和用户登录注销</h2><ul>
<li>shutdown -h now：表示立即关机</li>
<li>shutdown -h 1：表示1分钟后关机</li>
<li>shutdown -r now：立即重启</li>
<li>halt：直接使用，关机</li>
<li>reboot：重启</li>
<li>sync：把内存的数据同步到磁盘上，<strong>当我们关机或者重启时，都应该先执行一下sync，防止数据丢失</strong>。</li>
<li>logout：注销用户，<strong>在图形运行级别无效，在运行级别3有效</strong>。</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>用户，组，家目录。</p>
<ol>
<li>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li>
<li>Linux的用户需要至少要属于一个组。</li>
</ol>
<ul>
<li>添加用户：useradd [选项] 用户名。</li>
<li>cd：表示change directory，切换目录。</li>
<li>当创建用户成功后，会自动的创建和用户同名的家目录。</li>
<li>也可以通过useradd -d 指定目录 新的用户名。</li>
<li>指定/修改密码：passwd 用户名</li>
<li>删除用户，保留家目录：userdel 用户名，<strong>一般保留家目录，因为干过的活要留着</strong>。</li>
<li>删除用户以及家目录：userdel -r 用户名</li>
<li>查询用户信息：id 用户名</li>
<li>切换用户：su - 切换用户名，<strong>从权限高切换到权限低的用户不需要输密码</strong>。</li>
<li>返回切换前的用户：exit</li>
<li>查看当前用户/登录用户：who am i</li>
<li>用户组：类似于角色，系统可以对有共性的多个用户进行统一的管理。</li>
<li>增加组：groupadd 组名</li>
<li>删除组：groupdel 组名</li>
<li>增加用户时直接加上组：useradd -g 用户组 用户名</li>
<li>修改用户组：usermod -g 用户组 用户名</li>
</ul>
<ol start="3">
<li>/etc/passwd 文件</li>
</ol>
<ul>
<li>用户（user）的配置文件，记录用户的各种信息。</li>
<li>每行的含义：用户名：口令：用户标识号：注释性描述：主目录：登录shell</li>
</ul>
<ol start="4">
<li>/etc/shadow 文件</li>
</ol>
<ul>
<li>口令配置文件</li>
<li>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li>
</ul>
<ol start="5">
<li>/etc/group 文件</li>
</ol>
<ul>
<li>组（group）的配置文件，记录Linux包含的组的信息。</li>
<li>每行含义：组名：口令：组标识号：组内用户列表</li>
</ul>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul>
<li><p>pwd：Print Working Directory，显示当前工作目录的绝对路径。</p>
</li>
<li><p>ls：-a：显示当前目录所有的文件和目录，包括隐藏的；-l：以列表的方式显示信息。</p>
</li>
<li><p>cd：cd ~：回到自己的家目录；cd ..：回到当前目录的上一级目录。</p>
</li>
<li><p>mkdir：创建目录；-p：创建多级目录。</p>
</li>
<li><p>rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。</p>
</li>
<li><p>touch：创建空文件。可以一次性创建多个文件</p>
</li>
<li><p>cp：拷贝文件到指定目录；-r：递归复制整个文件夹。强制覆盖不提示的方法：cp命令改为\cp</p>
</li>
<li><p>rm：移除文件或目录；-r：递归删除整个文件夹；-f：强制删除不提示。</p>
</li>
<li><p>mv：移动文件与目录或重命名，两种功能！</p>
</li>
<li><p>cat：查看文件内容。只能浏览文件，而不能修改文件。-n：显示行号。结尾加上 | more：分页显示，不会全部一下显示完。</p>
</li>
<li><p>more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键（Space）</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Enter</td>
<td>向下翻一行</td>
</tr>
<tr>
<td>q</td>
<td>立刻离开more，不再显示该文件内容</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>=</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>：f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
</li>
<li><p>less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。<strong>对于显示大型文件具有较高的效率。</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键（Space）</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>[pagedown]</td>
<td>向下翻一行</td>
</tr>
<tr>
<td>[pageup]</td>
<td>向上翻动一页</td>
</tr>
<tr>
<td>/字串</td>
<td>向下搜寻字串的功能；n向下找，N向上找</td>
</tr>
<tr>
<td>？子串</td>
<td>向上搜寻字串的功能；n向上找，N向下找   （n正向）</td>
</tr>
<tr>
<td>q</td>
<td>离开less这个程序</td>
</tr>
</tbody></table>
<ul>
<li><code>&gt;</code>指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。</li>
<li><code>&gt;&gt;</code>指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。</li>
<li>cat是查看，echo是写入，echo （内容） &gt;&gt; 文件</li>
<li>cal：显示当前月日历。</li>
<li>echo：输出内容到控制台。</li>
<li>head：显示文件的开头部分。-n 5：看前面5行内容。</li>
<li>tail：输出文件中尾部的内容。-n 5：看后面5行内容。-f：时事追踪该文档的所有更新</li>
<li>ln -s :建立软连接 </li>
<li>history: 查看历史指令</li>
</ul>
<h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><ul>
<li>date：显示当前日期和时间</li>
<li>date “+%Y”：显示当前年份</li>
<li>date “+%d”：显示当前月份</li>
<li>date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒</li>
<li>设置日期：date -s 字符串时间</li>
<li>cal：查看日历指令；cal 年份：显示某一年一整年的日历</li>
</ul>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><ul>
<li>find：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。<ul>
<li>find (搜索范围) -name (文件名)：按照指定的文件名查找模式查找文件。</li>
<li>find (搜索范围) -user (用户名)：按照指定的用户名查找模式查找文件。</li>
<li>find (搜索范围) -size (+多少/-多少/多少)：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少）</li>
<li><strong>查询 /目录下所有.txt的文件</strong>：find / -name *.txt</li>
<li>根据文件名删除文件：<code>find . -name 文件名 | xargs rm -rf</code></li>
</ul>
</li>
<li>locate： locate (搜索文件)<ul>
<li>可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</li>
<li>在第一次运行之前，<strong>必须使用updatedb指令创建locate数据库</strong>。</li>
</ul>
</li>
<li>grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。<ul>
<li>grep [选项] 查找内容 源文件</li>
<li>-n：显示匹配行及行号。</li>
<li>-i：忽略大小写字母。</li>
<li><code>cat hello.txt | grep &quot;yes&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><ul>
<li>gzip/gunzip：压缩文件/解压<ul>
<li>gzip (文件)：压缩为.gz文件，原来文件不保留。</li>
<li>gunzip (文件)：解压缩，同样也不保留源文件。</li>
</ul>
</li>
<li>zip/unzip：压缩文件/解压<ul>
<li>zip [选项] (压缩后文件xxx.zip) (将要压缩的文件)</li>
<li>unzip [选项] (要解压的文件xxx.zip)</li>
<li>zip -r：递归压缩，即压缩目录</li>
<li>unzip -d (目录)：指定解压后的文件的存放目录</li>
</ul>
</li>
<li>tar：打包指令，最后打包后的文件是.tar.gz的文件<ul>
<li>tar [选项] xxx.tar.gz (打包的内容)</li>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细信息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩</li>
<li>-x：解压.tar文件</li>
<li>压缩：tar -zcvf (压缩后文件名) (要压缩的文件)</li>
<li>解压：tar -zxvf (要解压的文件)</li>
<li>解压到指定目录：tar -zxvf (要解压的文件) -C (指定目录)，指定解压到的目录要存在。</li>
</ul>
</li>
</ul>
<h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>在Linux中每个用户必须属于一个组，不能独立于组外。每个文件有所有者、所在组、其他组概念</p>
<ol>
<li>所有者</li>
<li>所在组</li>
<li>其他组</li>
<li>改变用户所在组</li>
</ol>
<ul>
<li>文件/目录所有者：<ul>
<li>一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。</li>
<li>查看文件所有者：ls -ahl</li>
<li>修改文件所有者：chown (用户名) (文件名)</li>
<li>文件所在组不一定是文件所有者。</li>
</ul>
</li>
<li>组的创建<ul>
<li>groupadd (组名)</li>
</ul>
</li>
<li>文件/目录所在组<ul>
<li>修改文件所在组：chgrp (组名) (文件名)</li>
</ul>
</li>
<li>其他组<ul>
<li>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</li>
</ul>
</li>
<li>改变用户所在组<ul>
<li>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组</li>
<li>改变用户所在组：usermod -g 组名 用户名</li>
<li>改变用户登录的初始目录：usermod -d 目录名 用户名</li>
</ul>
</li>
</ul>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">-rw-r--r--.  1 zwj  root       0 4月   5 18:20 apple.txt<br></code></pre></td></tr></table></figure>

<p>第0位是符号类型</p>
<ul>
<li><p>文件类型：</p>
<ul>
<li>-：普通类型</li>
<li>d：目录</li>
<li>l：软连接  相当于快捷方式</li>
<li>c：字符设备【键盘、鼠标等】</li>
<li>b：块文件【硬盘】</li>
</ul>
</li>
<li><p>rw-：表示文件所有者权限（rw，读写）(第1-3位)</p>
</li>
<li><p>r–：表示文件所在组的用户的权限（r，只有读的权限）（第4-6位）</p>
</li>
<li><p>r–：表示文件其他组的用户的权限（r，只有读的权限）（第7-9位）</p>
</li>
<li><p>1：如果是文件，表示硬连接的数；如果是目录则表示该目录的子目录个数</p>
</li>
<li><p>zwj：文件所有者</p>
</li>
<li><p>root：文件所在组</p>
</li>
<li><p>0：文件的大小，0个字节；如果是目录，则统一为4096</p>
</li>
<li><p>July 1 13：40：文件最后的修改时间</p>
</li>
<li><p>apple.txt：文件名</p>
</li>
</ul>
<ul>
<li><p>rwx作用到文件：</p>
<ul>
<li>r：read，可读。读取查看。</li>
<li>w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li>
<li>x：execute，可执行。可以被执行。</li>
</ul>
</li>
<li><p>rwx作用到目录：</p>
<ul>
<li>r：可以读取，ls查看目录内容。</li>
<li>w：可以修改，目录内创建+删除+重命名目录。</li>
<li>x：可执行，可以进入该目录。</li>
</ul>
</li>
<li><p>修改权限 chmod</p>
<ul>
<li>修改文件或者目录的权限</li>
<li>u：所有者；g：所在组；o：其他人；a：所有人（u、g、o的总和）</li>
<li>chmod u=rwx，g=rx，o=x 文件目录名：分别权限</li>
<li>chmod o+w 文件目录名：给其他人都增加写的权限</li>
<li>chmod a-x 文件目录名：给所有的用户都减掉执行权限</li>
</ul>
</li>
<li><p>通过数字变更权限</p>
<ul>
<li>规则：r=4 w=2 x=1 rwx=4+2+1=7</li>
<li>chmod u=rwx，g=rx，o=x 文件目录名 <strong>等价于</strong> chmod 751 文件目录名</li>
</ul>
</li>
<li><p>修改文件所有者 chown</p>
<ul>
<li>chown newowner file：改变文件的所有者</li>
<li>chown newowner：newgroup file：改变文件的所有者和所在组</li>
<li>-R：如果是目录，则使其下所有子文件或目录递归生效</li>
</ul>
</li>
<li><p>修改文件所在组 chgrp</p>
<ul>
<li>chgrp newgroup file：改变文件的所有组</li>
<li>-R：如果是目录，则使其下所</li>
</ul>
</li>
</ul>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><ul>
<li><p>rond任务调度：crontab进行定时任务调度</p>
<ul>
<li>crontab [选项]</li>
<li>-e：编辑crontab定时任务</li>
<li>-l：查询crontab任务</li>
<li>-r：删除当前用户所有的crontab任务</li>
<li>service crond restart：重启任务调度</li>
<li>当保存退出后就生效了</li>
</ul>
<p><strong>快速入门</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"># 设置任务调度文件： <br>/etc/crontab<br><br>#设置个人任务调度,执行crontab -e命令，接着输入任务到调度文件，如：<br>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt     #每个* 之前有空格<br>意思是每小时的每分钟执行 ls -l /etc/ &gt; /tmp/to.txt 命令<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody></table>
</li>
<li><p>特殊符号说明</p>
<ul>
<li><code>*</code>：代表任何时间。比如第一个<code>*</code>就代表一小时中每分钟都执行一次的意思。</li>
<li><code>,</code>：代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</li>
<li><code>-</code>：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。</li>
<li><code>*/n</code>：代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令。</li>
</ul>
<p>** 特定时间执行任务案例</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>45 22 * * * 命令</td>
<td>22点45分执行命令</td>
</tr>
<tr>
<td>0 17 * * 1 命令</td>
<td>每周一的17点执行</td>
</tr>
<tr>
<td>0 5 1,15 * * 命令</td>
<td>每月的1号和15号的5点执行</td>
</tr>
<tr>
<td>40 4 * * 1-5 命令</td>
<td>每周一到周五的4点40执行</td>
</tr>
<tr>
<td>*/10 4 * * * 命令</td>
<td>每天的4点每隔10分钟执行</td>
</tr>
<tr>
<td>0 0 1,15 * 1 命令</td>
<td>每月1号和15号、周一的零点执行，星期和几号最好不要同时出现</td>
</tr>
</tbody></table>
<h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><blockquote>
<ol>
<li>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li>
<li>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li>
<li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</li>
<li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</li>
<li>ps -ef | grep atd //可以检测atd是否在运行    ps - ef 可以查看所有运行的进程</li>
</ol>
</blockquote>
<ul>
<li>atq：查看当前任务</li>
<li>atrm: 删除已经设置的任务，atrm 任务编号</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"># 两分钟后把时间写到xx.log<br>at now + 2 minutes  回车<br>at&gt; date &gt; /home/xx.log   输入完按两次 Ctrl+D<br><br>#两天后的下午5点执行 /bin/li/home<br>at 5pm + 2 days   回车<br>at&gt; /bin/ls/home  输入完按两次 Ctrl+D<br></code></pre></td></tr></table></figure>



<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><blockquote>
<p>Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</p>
<p>Linux采用了一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
</blockquote>
<ul>
<li><p>硬盘说明</p>
<ul>
<li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li>
<li>lsblk -f：查看当前系统的分区和挂载情况。（list block）</li>
<li>lsblk: 查看系统分区情况</li>
</ul>
</li>
<li><p>新增硬盘的操作</p>
<ul>
<li>虚拟机添加硬盘</li>
<li>分区：fdsk  /dev/sdb（sdb是新增加的硬盘的名字)</li>
<li>格式化：mkfs -t ext4 /dev/sdb1  (sdb1是刚才分区的名字)</li>
<li>挂载：新建目录：mkdir /home/newdisk；挂载：mount /dev/sdb1 /home/newdisk , ==将sdb1挂载到 /home/newdisk目录下，这样保存到 /home/newdisk目录下的文件就保存到 sdb1硬盘中==</li>
<li>设置可以自动挂载（永久挂载）：重启系统后，仍然可以挂载。vim etc/fstab 增加挂载信息。mount -a：生效</li>
<li>取消挂载：unmount /dev/sdb1</li>
</ul>
</li>
<li><p>磁盘情况查询：</p>
<ul>
<li>查询系统整体磁盘使用情况：df -h 、  df -l</li>
<li>查询指定目录的磁盘占用情况：du -h /目录，默认为当前目录<ul>
<li>-s：指定目录占用大小汇总</li>
<li>-h：带计量单位</li>
<li>-a：含文件</li>
<li>–max-depth=1：子目录深度</li>
<li>-c：列出明细的同时，增加汇总值</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘情况-工作实用指令</p>
<ol>
<li>统计/home文件夹下文件的个数：<code>ls -l /home | grep &quot;^-&quot; | wc -l</code>  <strong>wc的功能是进行统计，“^-” 是正则表达式，以-开头的</strong></li>
<li>统计/home文件夹下目录的个数：<code>ls -l /home | grep &quot;^d&quot; | wc -l</code></li>
<li>统计/home文件夹下文件的个数，包括子文件夹里的：<code>ls -lR /home | grep &quot;^-&quot; | wc -l</code></li>
<li>统计文件夹下目录的个数，包括子文件夹里的：<code>ls -lR /home | grep &quot;^d&quot; | wc -l</code></li>
<li>以树状显示目录结构：首先安装tree指令：yum install tree，tree</li>
</ol>
</li>
</ul>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><ul>
<li>指定固定IP：直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-eth33。修改如下只<ul>
<li>BOOTPROTO=static  <em>静态分配</em></li>
<li>IPADDR= 192.168.200.139  <em>ip地址</em></li>
<li>GETWAY=192.168.200.2<em>网关</em></li>
<li>DNS1=192.168.200.2 <em>域名解析器</em></li>
<li>重启网络服务 （service network restart)  或重启系统生效(reboot)</li>
</ul>
</li>
<li>设置主机名 : vim/etc/hostname</li>
<li>查看主机名:hostname</li>
<li>设置ip和主机名的映射关系<ul>
<li>windows:  C:\windows\System2\drivers\etc\hosts，添加映射关系</li>
<li>linux：在etc/hosts 文件中添加</li>
</ul>
</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul>
<li><p>在Linux中，每个执行的<strong>程序（代码）</strong>都称为一个进程。每个进程都分配一个ID号</p>
</li>
<li><p>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</p>
</li>
<li><p>每个进程都可能以两种方式存在：前台和后台</p>
<ul>
<li>前台进程：用户目前的屏幕上可以进行操作的。</li>
<li>后台进程：实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li>
</ul>
</li>
<li><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</p>
</li>
<li><p>显示系统执行的进程</p>
<ul>
<li>ps：查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。PID：进程识别号；TTY：终端机号；TIME：此进程所消耗的CPU时间；CMD：正在执行的命令或进程名</li>
<li>ps -a：显示当前终端的所有进程信息。</li>
<li>ps -u：以用户的格式显示进程信息。</li>
<li>ps -x：显示后台进程运行的参数。</li>
<li>ps -axu | grep xxx：过滤得到xxx的信息。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">System V展示风格<br><br>USER:用户名称<br><br>PID:进程号<br><br>%CPU:进程占用CPU的百分比<br><br>%MEM:进程占用物理内存的百分比<br><br>VSZ:进程占用的虚拟内存大小（单位:KB)<br><br>RSS:进程占用的物理内存大小(单位:KB)<br><br>TT:终端名称,缩写<br><br>STAT:进程状态，其中S-睡眠,s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等<br><br>STARTED:进程的启动时间<br><br>TIME:CPU时间，即进程使用CPU的总时间<br><br>COMMAND:启动进程所用的命令和参数，如果过长会被截断显示<br></code></pre></td></tr></table></figure>

<ul>
<li>ps -ef：以全格式显示当前所有的进程，查看进程的父进程。</li>
<li>-e：显示所有进程。</li>
<li>-f：全格式。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">UID:用户ID<br><br>PID:进程ID<br><br>PPID:父进程ID<br><br>C: CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低;数值越小，表明进程是IO密集型运算，执行优先级会提高<br><br>STIME:进程启动的时间<br><br>TTY:完整的终端名称<br><br>TIME:CPU时间<br><br>CMD:启动进程所用的命令和参数<br></code></pre></td></tr></table></figure>
</li>
<li><p>终止进程</p>
<ul>
<li>kill [选项] 进程号：通过进程号杀死进程</li>
<li>killall 进程名称：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</li>
<li>-9：表示强迫进程立刻停止</li>
<li>案例1：踢掉非法用户：kill 进程号</li>
<li>案例2：终止远程登录服务sshd，在适当时候再次重启sshd服务  :kill sshd对应的进程号， 重启： /bin/systemctl start sshd.service</li>
<li>案例3：终止多个gedit编辑器：killall 进程名称</li>
<li>案例4：强制杀掉一个终端：kill -9 进程号</li>
</ul>
</li>
<li><p>查看进程树：pstree [选项]</p>
<ul>
<li>-p：显示进程的PID</li>
<li>-u：显示进程的所属用户</li>
</ul>
</li>
</ul>
<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><ul>
<li><p>service管理指令：service 服务名 [start | stop | restart | reload | status]</p>
</li>
<li><p>在CentOS7.0之后，不再使用service，而是systemctl</p>
</li>
<li><p>查看防火墙情况：</p>
<ul>
<li>service iptables status</li>
<li>systemctl status firewalld（7.0之后的版本）</li>
</ul>
</li>
<li><p>运行级别：通常使用3和5，3是无图形界面，5有图形化界面</p>
<ul>
<li>查看或修改默认级别：vim /etc/inittab</li>
<li>systemctl get-default 查看当前的运行级别</li>
<li>systemctl set-default TARGENT.target 设置当前运行级别为3</li>
</ul>
</li>
<li><p>chkconfig：可以给每个服务的各个运行级别设置自启动/关闭</p>
<ul>
<li>查看xxx服务：chkconfig –list | grep xxx</li>
<li>查看服务的状态：chkconfig 服务名 –list</li>
<li>给服务的运行级别设置自启动：chkconfig –level 5 服务名 on/off</li>
<li>要所有运行级别关闭或开启：chkconfig 服务名 on/off</li>
</ul>
</li>
<li><p>systemctl管理指令</p>
<ul>
<li>基本语法:systemctl [start | stop | restart | status]服务名</li>
<li>systemctl指令管理的服务在/usr/lib/systemd/system查看</li>
<li>systemctl设置服务的自启动状态</li>
<li>systemctl list-unit-files [l grep 服务名](查看服务开机启动状态, grep可以进行过滤)</li>
<li>systemctl enable服务名(设置服务开机启动)</li>
<li>systemctl disable 服务名(关闭服务开机启动)</li>
<li>systemctl is-enabled服务名(查询某个服务是否是自启动的)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">systemctl status firewalld   #查看firewalld的状况<br>systemctl stop firewalld   #关闭防火墙<br>systemctl start firewalld #重启防火墙<br><br>#以上命令指示临时生效，当系统重启后还是回归以前的配置<br>#如果需要永久生效，使用systemctl [enable|disable] 服务名   进行修改 <br></code></pre></td></tr></table></figure>

<ul>
<li>windows 在 cmd下使用 telnet ip  端口号 可以连接端口</li>
</ul>
</li>
<li><p>端口设置</p>
<ul>
<li>打开端口：<code>firewall-cmd --permanent --add-port=端口号/协议</code>  如：<code>firewall-cmd --permanent --add-port=111/tcp</code></li>
<li>关闭端口：<code>firewall-cmd --permanent --remove-port-端口号/协议</code>   如：<code>frewall-cmd --permanent --remove-port=111/tcp</code></li>
<li>重新载入之后上面的操作才能够生效：<code>firewall-cmd --reload</code></li>
<li>查询端口是否开放： <code>firewall-cmd --query-port=端口号/协议</code></li>
<li>查看开放的所有端口：<code>firewall-cmd --zone=public --list-ports</code></li>
</ul>
</li>
</ul>
<h2 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h2><blockquote>
<p>top和ps命令很相似。它们都用来显示正在执行的进程。top和ps最大的不同之处在于top在执行一段时间可以更新正在运行的进程。</p>
</blockquote>
<ul>
<li>top [选项]<ul>
<li>-d 秒数：指定top命令每隔几秒更新。默认是3秒。</li>
<li>-i：使top不显示任何闲置或者僵死进程。</li>
<li>-p：通过指定监控进程ID来仅仅监控某个进程的状态。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">PID：进程号 <br><br>USER：进程所有者的用户名 ( 该 process 所属的使用者 )<br><br>PR：进程的优先级别 ( Priority 的简写，程序的优先执行顺序，越小越早被执行 )<br><br>NI：进程的优先级别数值 ( Nice 的简写，与 Priority 有关，也是越小越早被执行 )<br><br>VIRT：进程占用的虚拟内存值。<br><br>RES：进程占用的物理内存值。<br><br>SHR：进程使用的共享内存值。<br><br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br><br>%CPU：该进程占用的CPU使用率。<br><br>%MEM：该进程占用的物理内存和总内存的百分比。<br><br>TIME＋：该进程启动后占用的总的CPU时间 ( CPU 使用时间的累加 )<br><br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。<br></code></pre></td></tr></table></figure>

<ul>
<li>交互操作说明：(在top界面按下对应的选型)<ul>
<li>P：以CPU使用率排序，默认就是此项</li>
<li>M：以内存的使用率排序</li>
<li>N：以PID排序</li>
<li>q：退出top</li>
</ul>
</li>
<li>案例1：监控特定用户：==top查看进程；u输入用户名。==</li>
<li>案例2：终止指定的进程：==top查看进程；k输入要结束的进程号。==</li>
<li>案例3：指定系统状态更新的时间（每隔10秒自动更新，默认是3秒）：top -d 10</li>
</ul>
<h2 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h2><ul>
<li>netstat [选项]<ul>
<li>-an：按一定顺序排列输出</li>
<li>-p：显示哪个进程在调用</li>
</ul>
</li>
</ul>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><blockquote>
<p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成只有.RPM扩展名的文件。RPM是RedHat Package Manager( RedHat软件包管理工具)的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p>
<p>Linux的分发版本都有采用(suse,redhat, centos等等），可以算是公认的行业标准了.</p>
</blockquote>
<ul>
<li>rpm包的查询指令：<ul>
<li>rpm -qa：查询所安装的所有rpm软件包</li>
<li>rpm -qa | more</li>
<li>rpm -qa | grep xx</li>
<li>rpm -q xx：查询xx软件包是否安装</li>
<li>rpm -qi xx：查询软件包信息</li>
<li>rpm -ql xx：查询软件包中的文件</li>
<li>rpm -qf 文件全路径名：查询文件所属的软件包</li>
</ul>
</li>
<li>卸载rpm包：rpm -e 软件包名称<ul>
<li>删除时可能会发生依赖错误，忽视依赖强制删除的方法：rpm -e –nodeps 软件包名称</li>
</ul>
</li>
<li>安装rpm包：rpm -ivh 软件包全路径名称<ul>
<li>i=install：安装</li>
<li>v=verbose：提示</li>
<li>h=hash：进度条</li>
</ul>
</li>
</ul>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><blockquote>
<p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p>
</blockquote>
<ul>
<li>yum list | grep xx：查询yum服务器是否有需要安装的软件</li>
<li>yum install xx：安装指定的yum包</li>
<li>yum -y remove xx：卸载指定的yum包</li>
</ul>
<h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><ol>
<li><p>使用windows下载jdk1.8的压缩包，使用xftp传输给linux  <em>通常保存到/opt/xxx下</em></p>
</li>
<li><p>使用 <code>tar -zxvf xxx</code>解压文件</p>
</li>
<li><p>将压缩文件移动到<code>/usr/local/xxx</code>文件夹下,<em>最好先在usr/local下创建文件夹，再使用mv移动文件夹</em></p>
</li>
<li><p>配置环境变量 ：<code>vim /etc/profile</code>,添加如下命令:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">export JAVA_HOME=/usr/local/java/jdk1.8.0_321    #jdk1.8.0_321为你自己的文件夹名字<br>export PATH=$JAVA_HOME/bin:$PATH<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用<code>source /etc/profile</code>让刚才配置的环境变量生效</p>
</li>
<li><p>使用<code>echo $PATH</code>可以查看配置的环境变量是否生效</p>
</li>
</ol>
<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><blockquote>
<p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便裕兴程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p>
</blockquote>
<h3 id="Shell脚本的执行方式："><a href="#Shell脚本的执行方式：" class="headerlink" title="Shell脚本的执行方式："></a>Shell脚本的执行方式：</h3><ul>
<li>脚本格式要求：<ul>
<li>脚本以#!/bin/bash 开头</li>
<li>脚本需要有可执行权限</li>
</ul>
</li>
<li>脚本的常用执行方式：<ul>
<li>方式1（输入脚本的绝对路径或相对路径）<ul>
<li>首先要赋予xx.sh脚本的+x权限：chmod 744 myShell.sh</li>
<li>执行脚本：./myShell.sh</li>
</ul>
</li>
<li>方式2（sh+脚本）：<ul>
<li>说明：不用赋予+x权限，直接执行即可</li>
<li>sh ./myShell.sh</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h3><ul>
<li><p>shell变量的介绍</p>
<ul>
<li>Linux Shell的变量分为，系统变量和用户自定义变量</li>
<li>系统变量：<code>$HOME</code>、<code>$PWD</code>、<code>$SHELL</code>、<code>$USER</code>等等</li>
<li>显示当前shell中所有变量：set</li>
</ul>
</li>
<li><p>shell变量的定义</p>
<ul>
<li><p>基本语法</p>
<p>定义变量：变量名=值，**=两边不能有空格**</p>
<p>撤销变量：unset 变量名</p>
<p>声明静态变量：readonly 变量，注意：不能unset</p>
<p>输出变量： $变量名</p>
</li>
</ul>
</li>
<li><p>定义变量的规则</p>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</li>
<li>等号两侧不能有空格</li>
<li>变量名称一般习惯为大写</li>
</ul>
</li>
<li><p>将命令的返回值赋给变量</p>
<ul>
<li>A=`date`，使用反引号，运行里面的命令，并把结果返回给变量A</li>
<li>A=$(date)等价于上面</li>
</ul>
</li>
</ul>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><ul>
<li><p>基本语法</p>
<ul>
<li><p>export 变量名=变量值：将shell变量输出为环境变量/全局变量</p>
</li>
<li><p>source 配置文件：让修改后的配置文件信息立即生效</p>
</li>
<li><p>echo $变量名：查询环境变量的值</p>
</li>
<li><p>多行注释：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">:&lt;&lt;!<br>需要注释的内容<br>!<br></code></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><blockquote>
<p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息就可以使用到位置参数变量。比如： ./myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中传参100，200。</p>
</blockquote>
<ul>
<li>基本语法：<ul>
<li><code>$n</code>：n为数字，<code>$0</code>代表命令本身，<code>$1-$9</code>代表第一到第九个参数，10以上的参数需要用大括号包含，如<code>$&#123;10&#125;</code></li>
<li><code>$*</code>：这个变量代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体</li>
<li><code>$@</code>：这个变量也代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待</li>
<li><code>$#</code>：这个变量代表命令行中所有参数的个数</li>
</ul>
</li>
</ul>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><ul>
<li>shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</li>
<li>基本语法：<ul>
<li><code>$$</code>：当前进程的进程号（PID）</li>
<li><code>$!</code>：后台运行的最后一个进程的进程号（PID）</li>
<li><code>$?</code>：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确。</li>
<li>后台运行：./myShell.sh &amp;</li>
</ul>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>在Shell中进行各种运算操作</li>
<li>“<code>$</code>((运算式))”或“<code>$</code>[运算时]”</li>
<li>expr m + n，注意expr运算符间要有空格</li>
<li>expr m - n</li>
<li>expr <code>\*</code> / %，乘，除，取余</li>
</ul>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul>
<li>基本语法：[ condition ]，<strong>注意condition前后有空格！</strong></li>
<li>非空返回true，可使用$?验证（0为true，&gt;1为false）</li>
<li>两个整数比较<ul>
<li>=：字符串比较</li>
<li>-lt：小于</li>
<li>-le：小于等于</li>
<li>-eq：等于</li>
<li>-gt：大于</li>
<li>-ge：大于等于</li>
<li>-ne：不等于</li>
</ul>
</li>
<li>按照文件权限进行判断<ul>
<li>-r：有读的权限</li>
<li>-w：有写的权限</li>
<li>-x：有执行的权限</li>
</ul>
</li>
<li>按照文件类型进行判断<ul>
<li>-f：文件存在并且是一个常规的文件</li>
<li>-e：文件存在</li>
<li>-d：文件存在并且是一个目录</li>
</ul>
</li>
</ul>
<h3 id="流程控制if语句"><a href="#流程控制if语句" class="headerlink" title="流程控制if语句"></a>流程控制if语句</h3><ul>
<li><p>if判断基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>then<br>	代码<br>fi<br></code></pre></td></tr></table></figure>
</li>
<li><p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br><br> then<br>	程序<br>elif [ 条件判断式 ]<br>then<br>	程序<br>fi<br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="流程控制case语句"><a href="#流程控制case语句" class="headerlink" title="流程控制case语句"></a>流程控制case语句</h3><ul>
<li><p>case语句基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">case $变量名 in<br><br>“值1”)<br><br>	如果变量的值等于值1，则执行程序1<br><br>;;<br><br>“值2”)<br><br>	如果变量的值等于值2，则执行程序2<br><br>;;<br><br>…省略其他分支…<br><br>*)<br><br>如果变量的值都不是以上的值，则执行此程序<br><br>;;<br><br>esac<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="流程控制for循环"><a href="#流程控制for循环" class="headerlink" title="流程控制for循环"></a>流程控制for循环</h3><ul>
<li><p>for循环基本语法1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3…<br><br> do<br><br> 程序<br><br> done<br></code></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>for循环基本语法2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs shel">for ((初始值;循环控制条件;变量变化))<br><br> do<br><br> 程序<br><br> done<br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="流程控制while循环"><a href="#流程控制while循环" class="headerlink" title="流程控制while循环"></a>流程控制while循环</h3><ul>
<li><p>while循环基本语法1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]     #条件判断和括号之间有空格<br><br> do<br><br> 程序<br><br> done<br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="read读取控制台的输入"><a href="#read读取控制台的输入" class="headerlink" title="read读取控制台的输入"></a>read读取控制台的输入</h3><ul>
<li>read [选项] (参数)</li>
<li>-p：指定读取值时的提示符</li>
<li>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。</li>
<li>参数：变量：指定读取值的变量名</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>系统函数</p>
<ul>
<li>basename：<strong>返回完整路径最后/的部分，常用于获取文件名</strong><ul>
<li>basename [pathname] [suffix]</li>
<li>basename [string] [suffix]</li>
<li>basename命令会删掉所有的前缀包括最后一个/</li>
<li>选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</li>
</ul>
</li>
<li>dirname：返回完整路径最后/的前面的部分，常用于返回路径部分<ul>
<li>dirname 文件绝对路径：从给定的包含绝对路径的文件名中出去文件名（非目录部分），然后返回剩下的路径（目录部分）</li>
</ul>
</li>
<li><strong>反正两个系统函数都不要最后一个/</strong></li>
</ul>
</li>
<li><p>自定义函数</p>
<ul>
<li><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">function funname()<br><br>&#123;<br><br> Action;<br><br> [return int;]<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>调用直接写函数名：funname（不用写括号），然后在后面写参数</p>
</li>
</ul>
</li>
</ul>
<h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><blockquote>
<p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。<br>可以这样理解日志是用来记录重大事件的工具。</p>
</blockquote>
<ul>
<li><blockquote>
<ul>
<li>基本介绍<br>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。<br>可以这样理解日志是用来记录重大事件的工具。</li>
<li>系统常用的日志<br>/var/log/ 目录就是系统日志文件的保存位置</li>
</ul>
<table>
<thead>
<tr>
<th align="center">日志文件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/var/log/boot.log</td>
<td align="center">系统启动日志</td>
</tr>
<tr>
<td align="center">/var/log/cron</td>
<td align="center">记录与系统定时任务相关的日志</td>
</tr>
<tr>
<td align="center">/var/log/cups/</td>
<td align="center">记录打印信息的曰志</td>
</tr>
<tr>
<td align="center">/var/log/dmesg</td>
<td align="center">记录了系统在开机时内核自检的信总。也可以使用 dmesg 命令直接查看内核自检信息</td>
</tr>
<tr>
<td align="center">/var/log/btmp</td>
<td align="center">记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用 lastb 命令查看</td>
</tr>
<tr>
<td align="center">/var/log/lasllog</td>
<td align="center">记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件。不能直接用Vi查看，而要使用lastlog命令查看</td>
</tr>
<tr>
<td align="center">/var/log/mailog</td>
<td align="center">记录邮件信息的日志</td>
</tr>
<tr>
<td align="center">/var/log/message</td>
<td align="center">记录系统里要佶息的日志.这个日志文件中会记录 Linux 系统的绝大多数重要信息。如果系统出现问题，首先要检查的应该就是这个日志文件</td>
</tr>
<tr>
<td align="center">/var/log/secure</td>
<td align="center">记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>
</tr>
<tr>
<td align="center">/var/log/wtmp</td>
<td align="center">永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用 last 命令查看</td>
</tr>
<tr>
<td align="center">/var/tun/ulmp</td>
<td align="center">记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用 w、who、users 等命令查看</td>
</tr>
<tr>
<td align="center">除系统默认的日志之外，采用 RPM 包方式安装的系统服务也会默认把日志记录在 /var/log/ 目录中（源码包安装的服务日志存放在源码包指定的目录中）。不过这些日志不是由 rsyslogd 服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身的日志。以下介绍的日志目录在你的 Linux 上不一定存在，只有安装了相应的服务，日志才会出现。</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">日志文件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/var/log/httpd/</td>
<td align="center">RPM 包安装的apache取务的默认日志目录</td>
</tr>
<tr>
<td align="center">/var/log/mail/</td>
<td align="center">RPM 包安装的邮件服务的额外日志因录</td>
</tr>
<tr>
<td align="center">/var/log/samba/</td>
<td align="center">RPM色安装的Samba服务的日志目录</td>
</tr>
<tr>
<td align="center">/var/log/sssd/</td>
<td align="center">守护进程安全服务目录</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><strong>日志管理服务 rsyslogd</strong></li>
</ul>
<blockquote>
<p>CentOS 7.6日志服务是 rsyslogd，CentOS 6.x 日志服务是 syslogd，rsyslogd 功能更强大。rsyslogd 的使用、日志文件的格式，和 syslogd 服务兼容的。</p>
<ul>
<li>查询 Linux 中的 rsyslogd 服务是否启动<ul>
<li>ps aux | grep “rsyslog” | grep -v “grep”</li>
</ul>
</li>
<li>查询 rsyslogd 服务的自启动状态<ul>
<li>systemctl list-unit-files | grep rsyslog</li>
</ul>
</li>
<li>配置文件：/etc/rsyslog.conf<ul>
<li>编辑文件时的格式：*.*，其中第一个 * 代表日志类型，第二个 * 代表日志类别</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<table>
<thead>
<tr>
<th align="center">日志类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auth</td>
<td align="center">安全和认证相关消息，pam 产生的日志（不推荐使用 authpriv 替代）</td>
</tr>
<tr>
<td align="center">authpirv</td>
<td align="center">安全和认证相关信息，ssh、ftp 等登录信息的验证信息（私有的）</td>
</tr>
<tr>
<td align="center">cron</td>
<td align="center">系统定时任务 crond 和 at 产生的日志</td>
</tr>
<tr>
<td align="center">daemon</td>
<td align="center">和各个守护进程相关的日志</td>
</tr>
<tr>
<td align="center">ftp</td>
<td align="center">ftp 守护进程产生的日志</td>
</tr>
<tr>
<td align="center">kern</td>
<td align="center">内核产生的日志（不是用户进程产生的）</td>
</tr>
<tr>
<td align="center">lpr</td>
<td align="center">打印产生的日志</td>
</tr>
<tr>
<td align="center">mail</td>
<td align="center">邮件收发信息</td>
</tr>
<tr>
<td align="center">news</td>
<td align="center">与新闻服务器相关的日志</td>
</tr>
<tr>
<td align="center">syslog</td>
<td align="center">有syslogd服务产生的日志信息（虽然服务名称已经改了 rsyslogd 服务，但是很多配置都还是沿用了 syslogd 的，这里并没有修改服务名）</td>
</tr>
<tr>
<td align="center">user</td>
<td align="center">用户等级类别的日志信息</td>
</tr>
<tr>
<td align="center">uucp</td>
<td align="center">uucp 子系统的日志信息，uucp 时早期 Linux 系统进行数据传递的协议，后来也经常用在新闻组服务中</td>
</tr>
<tr>
<td align="center">local0-local7</td>
<td align="center">为本地使用预留的服务</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<table>
<thead>
<tr>
<th align="center">日志级别</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">debug</td>
<td align="center">一般的调试信息说明，日志通信最多</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">基本的通知信息</td>
</tr>
<tr>
<td align="center">notice</td>
<td align="center">普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td align="center">warning</td>
<td align="center">警告信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td align="center">err</td>
<td align="center">错误信息，一般达到 err 等级的信息已经可以影响到服务或系统的运行了</td>
</tr>
<tr>
<td align="center">crit</td>
<td align="center">严重错误信息，比 err 等级还要严重，系统或整个软件不能正常工作</td>
</tr>
<tr>
<td align="center">alert</td>
<td align="center">需要立刻修改的信息，比 crit 还要严重，必须立即采取行动</td>
</tr>
<tr>
<td align="center">emerg</td>
<td align="center">内核崩溃等重要信息，系统已经无法使用了</td>
</tr>
<tr>
<td align="center">none</td>
<td align="center">什么都不记录</td>
</tr>
<tr>
<td align="center">注意：日志级别从上到下，级别从低到高，记录信息越来越少，优先处理的等级就越高，危害就越大。</td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<ul>
<li><p>由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下4列：</p>
<ul>
<li>事件产生的时间</li>
<li>发生事件的服务器的主机名</li>
<li>产生事件的服务名或程序名</li>
<li>事件的具体信息</li>
</ul>
</li>
<li><p>日志管理服务应用实例</p>
<p>在 /etc/rsyslog.conf 中添加一个日志文件 /var/log/hsp.log，当有事件发送时，该文件会接收到信息并保存。</p>
<ul>
<li>在 /etc/rsyslog.conf 文件中增加如下命令</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">*.*                         <span class="hljs-regexp">/var/</span>log/hsp.log<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<ul>
<li>新建 /var/log/hsp.log 文件，重启系统，再查看该文件内容。</li>
</ul>
</blockquote>
<ul>
<li><strong>日志轮替</strong></li>
</ul>
<blockquote>
<ul>
<li><p>基本介绍</p>
<ul>
<li>日志是重要的系统文件，记录和保存了系统中所有的重要事件。但是日志文件也需要进行定期的维护，因为日志文件是不断增长的，如果完全不进行日志维护，而任由其随意递增，那么用不了多久，我们的硬盘就会被写满。</li>
<li>日志维护的最主要的工作就是把旧的日志文件删除，从而腾出空间保存新的日志文件。这项工作如果靠管理员手工来完成，那其实是非常烦琐的，而且也容易忘记。那么 Linux 系统是否可以自动完成日志的轮替工作呢？</li>
<li>logrotate 就是用来进行日志轮替（也叫日志转储）的，也就是把旧的日志文件移动并改名，同时创建一个新的空日志文件用来记录新日志，当旧日志文件超出保存的范围时就删除。</li>
</ul>
</li>
<li><p>日志轮替文件的命名规则</p>
<ul>
<li>日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围时就删除。那么，旧的日志文件改名之后，如何命名呢？主要依靠 /etc/logrotate.conf 配置文件中的“dateext”参数。</li>
<li>如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，如“secure-20130605”。这样日志文件名不会重叠，也就不需要对日志文件进行改名，只需要保存指定的日志个数，删除多余的日志文件即可。</li>
<li>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志；当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志；以此类推。</li>
</ul>
</li>
<li><p>配置文件：/etc/logrotate.conf</p>
<p>可以设置全局的日志轮替规则，当然也可以单独给某个日志文件指定策略。</p>
<p>在这个配置文件中，主要分为三部分：</p>
<ul>
<li>第一部分是默认设置，如果需要转储的日志文件没有特殊配置，则遵循默认设置的参数；</li>
<li>第二部分是读取 /etc/logrotate.d/ 目录中的日志轮替的子配置文件，也就是说，在 /etc/logrotate.d/ 目录中的所有符合语法规则的子配置文件也会进行日志轮替；</li>
<li>第三部分是对 wtmp 和 btmp 日志文件的轮替进行设定，如果此设定和默认参数冲突，则当前设定生效（如 wtmp 的当前参数设定的轮替时间是每月，而默认参数的轮替时间是每周，则对 wtmp 这个日志文件来说，轮替时间是每月，当前的设定参数生效）。</li>
</ul>
</li>
<li><p>logrotate 配置文件的主要参数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">daily</td>
<td align="center">日志的轮替周期是毎天</td>
</tr>
<tr>
<td align="center">weekly</td>
<td align="center">日志的轮替周期是每周</td>
</tr>
<tr>
<td align="center">monthly</td>
<td align="center">日志的轮控周期是每月</td>
</tr>
<tr>
<td align="center">rotate 数宇</td>
<td align="center">保留的日志文件的个数。0指没有备份</td>
</tr>
<tr>
<td align="center">compress</td>
<td align="center">当进行日志轮替时，对旧的日志进行压缩</td>
</tr>
<tr>
<td align="center">create mode owner group</td>
<td align="center">建立新日志，同时指定新日志的权限与所有者和所属组。如 create 0600 root utmp</td>
</tr>
<tr>
<td align="center">mail address</td>
<td align="center">当进行日志轮替时.输出内存通过邮件发送到指定的邮件地址</td>
</tr>
<tr>
<td align="center">missingok</td>
<td align="center">如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td align="center">nolifempty</td>
<td align="center">如果曰志为空文件，則不进行日志轮替</td>
</tr>
<tr>
<td align="center">minsize 大小</td>
<td align="center">日志轮替的最小值。也就是日志一定要达到这个最小值才会进行轮持，否则就算时间达到也不进行轮替</td>
</tr>
<tr>
<td align="center">size 大小</td>
<td align="center">日志只有大于指定大小才进行日志轮替，而不是按照时间轮替，如 size 100k</td>
</tr>
<tr>
<td align="center">dateext</td>
<td align="center">使用日期作为日志轮替文件的后缀，如 secure-20130605</td>
</tr>
<tr>
<td align="center">sharedscripts</td>
<td align="center">在此关键宇之后的脚本只执行一次</td>
</tr>
<tr>
<td align="center">prerotate/cndscript</td>
<td align="center">在日志轮替之前执行脚本命令。endscript 标识 prerotate 脚本结束</td>
</tr>
<tr>
<td align="center">postrolaie/endscripl</td>
<td align="center">在日志轮替之后执行脚本命令。endscripi 标识 postrotate 脚本结束</td>
</tr>
</tbody></table>
<ul>
<li><p>把自己的日志加入日志轮替</p>
<p>如果有些日志默认没有加入日志轮替（比如源码包安装的服务的日志，或者自己添加的日志），那么这些日志默认是不会进行日志轮替的，这样当然不符合我们对日志的管理要求。如果需要把这些日志也加入日志轮替，那该如何操作呢？</p>
<p>这里有两种方法：</p>
<ul>
<li>第一种方法是直接在 /etc/logrotate.conf 配置文件中写入该日志的轮替策略，从而把日志加入轮替；</li>
<li>第二种方法是在 /etc/logrotate.d/ 目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被包含到主配置文件中，所以也可以把日志加入轮替。<br>推荐第二种方法，因为系统中需要轮替的日志非常多，如果全部直接写入 /etc/logrotate.conf 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</li>
</ul>
</li>
<li><p>日志轮替服务应用实例</p>
<p>对于自己设置的 /var/log/hsp.log 日志，不是系统默认日志，而是通过 /etc/rsyslog.conf 配置文件自己生成的日志，所以默认这个日志是不会进行轮替的。如果需要把这个日志加入。就采用第二种方法，在 /etc/logrotate.d/ 目录中建立此日志的轮替文件。</p>
<ul>
<li>先创建 /etc/logrotate.d/hsplog 轮替文件</li>
<li>在文件中写入命令，即事先约定好的日志轮替规则</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">/var/<span class="hljs-built_in">log</span>/hsp.<span class="hljs-built_in">log</span> &#123;<br>     missingok<br>     daily<br>     copytruncate<br>     rotate <span class="hljs-number">7</span><br>     nolifempty<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<ul>
<li>日志轮替机制原理<ul>
<li>logrotate 在很多 Linux 发行版上都是默认安装的。系统会定时运行 logrotate，一般是每天一次。系统是这么实现按天执行的。crond 会每天定时执行 /etc/cron.daily 目录下的脚本，而这个目录下有个文件叫 logrotate。logrotate 通过这个文件依赖定时任务执行的。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>查看内存日志</strong></li>
</ul>
<blockquote>
<ul>
<li>基本介绍<br>日志管理工具 journalctl 是CentOS 7上专有的日志管理工具，该工具是从 message 这个文件里读取信息。Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf</li>
<li>journalctl 用法<ul>
<li>查看所有日志（默认情况下 ，只保存本次启动的日志）：journalctl</li>
<li>查看内核日志（不显示应用日志）：journalctl -k</li>
<li>查看系统本次启动的日志：journalctl -b</li>
<li>实时滚动显示最新日志：journalctl -f</li>
<li>显示尾部的最新10行日志：journalctl -n </li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端设计开发</title>
    <url>/2020/10/12/%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h3 id="1-1基本标签"><a href="#1-1基本标签" class="headerlink" title="1.1基本标签"></a>1.1基本标签</h3><ul>
<li><p>h 标签 ：标题，一共有六级，从h1到h6</p>
</li>
<li><p>p 标签： 段落</p>
</li>
<li><p>br 标签：换行</p>
</li>
<li><p>文本格式化标签</p>
<a id="more"></a>

<ul>
<li>strong：粗体</li>
<li>em： 斜体</li>
<li>ins：下划线</li>
<li>del： 删除线</li>
</ul>
</li>
<li><p>img：图像标签，用来定义一个图像，其中img标签中有一些属性：</p>
<ul>
<li>src：图片的路径，可以是本地的图片，也可以是网上的图片。本地的路径可以写相对路径也可以写绝对路径，推荐使用相对路径。</li>
<li>alt：图片的替代文本，当图片不能够显示的时候会显示出alt中的值</li>
<li>title：当图片显示的时候，把鼠标放在图片上面会显示出title中的值</li>
<li>height、width：设置图片的高度或宽度，单位是像素(px)，推荐只设置一个，如果只设置宽度（高度），那么另一个就会等比例的放大缩小；如果设置了两个，就会使图像失真。</li>
</ul>
</li>
<li><p>a 标签：超链接标签，从一个页面跳到另一个页面  </p>
<ul>
<li>href：跳转页面的url地址，可以是绝对路径也可以是相对路径</li>
<li>target：用于指定链接页面的打开方式，其中_self为默认值，在当前页面打开， _blank在新窗口中打开页面</li>
<li>在href的值中使用 # 来进行占位，表示这是一个空链接。 <code>&lt;a href=&quot;#&quot;/&gt;</code>。</li>
<li>如果在href里面的地址是一个文件湖畔这压缩包，会下载这个文件。</li>
<li>网页中的各种元素，如文本、图像、表格、音频、视频等都可以添加超链接。</li>
<li>锚点连接：当我们点击链接，可以快速定位到页面中的某个位置，可以用来做书签<ul>
<li>找到目标位置标签，为其添加一个id属性=xxx,如<code>&lt;h1 id=two&gt;第二集介绍&lt;/h1&gt;</code></li>
<li>在链接文本的href属性中，设置属性值为 **#名字 **的形式，如<code>&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>table 标签：表格标签，表格主要用于显示、展示数据。</p>
<ul>
<li>tr 标签用于定义表格中的行，必须嵌套在table标签中。</li>
<li>td 标签用于定义表格中的单元格，必须嵌套在tr 标签中，td中的文本就是表格的数据</li>
<li>th 标签表示html表格的表头部分，th标签的文本会加粗居中显示。一般第一行的文本会用th而不是td。</li>
<li>thead：用于定义头部，没有什么显示，只是为了更好区分表格的结构，thead内部必须拥有tr标签。</li>
<li>tbody：用于定义表格的主题，主要用于放数据本体。</li>
<li>下面是table标签的一些属性，要写在table标签内，后期会使用css来修改这些样式<ul>
<li>align：设置表格的位置：居中，靠左对齐，靠右对齐….</li>
<li>border：设置表格边框</li>
<li>cellpadding：设置文字与单元边沿的距离，可以理解为设置单元格的长度</li>
<li>cellspacing：设置单元格之前的空白</li>
<li>width、height：设置表格的宽度或高度。</li>
<li>caption: 设置表格的标题</li>
<li>rowspan:纵向合并单元格，rowspan=”xxx”，填写合并单元格的数量，同时将被合并的单元格td删掉。</li>
<li>colspan:横向合并单元格，colspan=”xxx”，填写合并单元格的数量，同时将被合并的单元格td删掉。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>pty<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>刘德华<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>列表标签</p>
<ul>
<li>无序列表：<code>&lt;ul&gt;</code>，一般以项目符号呈现列表项，列表项使用<code>&lt;li&gt;</code>标签定义。<ul>
<li>ul标签中只能饿嵌套 li 标签，不能直接输入文字或者使用其他标签。</li>
<li>li 标签相当于一个容器，里面可以输入文字或使用其他标签。</li>
</ul>
</li>
<li>有序列表：<code>&lt;ol&gt;</code>，有排列顺序的列表，其各个列表项会按照一定的顺序排列，列表项用<code>&lt;li&gt;</code>标签定义。<ul>
<li>ol标签中只能饿嵌套 li 标签，不能直接输入文字或者使用其他标签。</li>
<li>li 标签相当于一个容器，里面可以输入文字或使用其他标签。</li>
</ul>
</li>
<li>自定义列表：<code>&lt;dl&gt;</code>，用于定义描述列表，这个与<code>&lt;dt&gt;</code>(定义项目/名字)和<code>&lt;dd&gt;</code>(描述每一个项目/名字)一起使用<ul>
<li>dl 里面只能出现dt 和dd</li>
<li>dt和dd个数没有限制，经常是一个dt对应多个dd。</li>
</ul>
</li>
</ul>
</li>
<li><p>表单标签</p>
<ul>
<li>表单域：使用form标签来定义表单域，form会把他范围内的表单元素信息提交给服务器</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;url地址：表单数据提交的服务器地址&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;提交方式：get/post&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;表单域名称&quot;</span></span><br><span class="hljs-tag">      各种表单元素控件</span><br>      &lt;/form&gt;<br></code></pre></td></tr></table></figure>

<p>表单元素控件：</p>
<ul>
<li>input：input包含一个type属性值，可以设置不同的type属性值来指定不同的控件类型。<ul>
<li>text：文本框，可以输入任何文字。</li>
<li>password：密码框，输入的文字会被掩盖，看不到真实内容。</li>
<li>radio：单选框，实现多选一，单选框的选项需要有相同的name属性值才能够实现多选一。</li>
<li>checkbox：复选框，实现多选效果 ，复选框也需要相同的name属性值。</li>
<li>checked：用于复选框和单选框，设置这个属性后，被设置的属性在加载的时候就会选中。<code>checked=&quot;checked&quot;</code></li>
<li>submit：提交按钮，会把表单域的信息提交给服务器，可以使用value修改按钮里面的值。</li>
<li>reset：重置按钮，还原表单元素初始的默认状态，可以使用value修改按钮里面的值。</li>
<li>button：普通按钮，后期结合js,可以作为js的启动按钮。</li>
<li>file：文件域，上传文件使用的。</li>
<li>label：用于绑定一个表单元素，当点击label标签内的文本时，浏览器会自动将焦点转到或者选择对应的表单元素上，用来增加用户体验。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--label标签的for属性值应与input标签的id属性值相同,将本来放在外面的文本使用label标签包围--&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;man&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;man&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;woman&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;woman&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>select表单元素：如果有多个选项让用户选择，并且想要节约空间，我们可以使用<select>标签定义下拉列表</select></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">	<span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项4<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>----------------------------------------------------------------------------------------<br>			籍贯：<span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>湖南<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>湖北<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">option</span> &gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>select中至少包含一对<option></option></li>
<li>在<option>中定义selected=”selected”是，当前选项为默认选中项。</option></li>
</ul>
</li>
<li><p>textarea表单元素：当输入的文字很多的时候，文本框<input type="text">不在适用，这时候应该使用textarea标签，常用于评论，留言。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">	<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br>		文本内容<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>-------------------------------------------------------------------------------------<br>	留言板：<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>		哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈<br>		哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>cols=”每行中输入的字符数”，row=”显示的行数”，在实际开发中使用css样式来改变大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2标签属性的注意点"><a href="#1-2标签属性的注意点" class="headerlink" title="1.2标签属性的注意点"></a>1.2标签属性的注意点</h3><ol>
<li>一个标签可以有多个属性，属性必须写在标签名的后面</li>
<li>属性之间不分先后顺序，但必须使用空格间隔</li>
<li>属性采取键值对的格式，即<code>key=&quot;value&quot;</code>。</li>
</ol>
<h3 id="1-3-绝对路径和相对路径"><a href="#1-3-绝对路径和相对路径" class="headerlink" title="1.3 绝对路径和相对路径"></a>1.3 绝对路径和相对路径</h3><ul>
<li><p>相对路径：以引用文件所在的文件夹为基础，而建立出的目录路径。</p>
<table>
<thead>
<tr>
<th>../</th>
<th>上一级路径</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>下一级路径</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li>绝对路径：指这个文件的绝对位置，直接到达目标位置，通常是以盘符开始的路径</li>
</ul>
<h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><h3 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h3><p>css由两个主要的部分构成：选择器以及一条或多条声明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">选择器 &#123;<br>	样式一;<br>	样式二;<br>	&#125;<br><span class="hljs-comment">#样式使用键值对的方式  key:value,选择器用于指定给哪个标签设置样式，花括号里面是该对象设置的具体样式。</span><br><span class="hljs-comment">#多个键值对之间使用分号（;）间隔</span><br></code></pre></td></tr></table></figure>

<h3 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>标签选择器是指用HTML标签名作为选择器，按照标签名称分类，为页面中的某一类标签指定统一的CSS样式。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">标签名&#123;<br>	属性1: 属性值1;<br>	属性2: 属性值2;<br>	属性3: 属性值3;<br>	属性4: 属性值4;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><p>实现差异化选择，比如说只要修改p标签里面的其中几个。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">.类名&#123;<br>	属性1: 属性值1;<br>	属性2: 属性值2;<br>	属性3: 属性值3;<br>	属性4: 属性值4;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>类选择器使用<code>.</code>进行标识，后面紧跟类名（我们自己定义的，不要使用html标签作为类名）。</li>
<li>使用<code>class</code>为标签添加类名，多个标签可以具有相同的类名，相当于给标签分了一个组。</li>
<li>不要使用纯数字、中文等命名（纯数字好像不起作用）。</li>
</ul>
<h5 id="类选择器–多类名"><a href="#类选择器–多类名" class="headerlink" title="类选择器–多类名"></a>类选择器–多类名</h5><p>一个标签具有多个类，相当于一个标签具有多个分组</p>
<p>多类名定义格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;标签名 class=<span class="hljs-string">&quot;类名1 类名2 类名3 ...&quot;</span>&gt;xxx&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>在标签class属性中写多个类名。</li>
<li>多个类名之前使用空格分开。</li>
<li>这个标签就会具有两个类的样式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">	<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">		<span class="hljs-selector-class">.font12</span>&#123;</span><br>			font-size: 12px;<br>		&#125;<br><span class="css">		<span class="hljs-selector-class">.red</span>&#123;</span><br>			color: red;<br>		&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red font12&quot;</span>&gt;</span>pty<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-comment">&lt;!--同时具有red类和font12两个类的样式--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><p>id选择器可以为标有特定id的html标签指定特有的样式。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">#id名&#123;<br>		属性1: 属性值1;<br>		属性2: 属性值2;<br>		属性3: 属性值3;<br>		属性4: 属性值4;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>id选择器使用<code>#</code>来标识，后面紧跟id名（自定义，不要使用html标签名作为id名）</li>
<li>使用id属性为标签设置id名，id名是唯一的，两个标签是不能拥有相同的id。类似于身份证号。</li>
<li>类选择器在修改样式的时候使用的最多，id选择器一般用于页面唯一性的元素上，经常和js搭配使用。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </li>
</ul>
<h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><p>通配符选择器选取页面中所有标签</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">*&#123;<br>	属性1: 属性值1;<br>	属性2: 属性值2;<br>	属性3: 属性值3;<br>	属性4: 属性值4;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>通配符选择器使用<code>*</code>来标识，可以选择页面中的所有标签</li>
</ul>
<h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><p>复合选择器由两个及以上的基础选择器通过不同方式组合在一起。</p>
<h5 id="后代选择器（重要）"><a href="#后代选择器（重要）" class="headerlink" title="后代选择器（重要）"></a>后代选择器（重要）</h5><p>后代选择器可以选择父元素里面的后代元素。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">元素1 元素2&#123;样式声明&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>选择元素1里面的元素2进行修改</li>
<li>两个元素中间使用<strong>空格</strong>隔开</li>
<li>元素1为父元素，元素2为后代元素。</li>
<li>元素1和元素2可以为任意的基础选择器</li>
</ul>
<h5 id="子元素选择器（重要）"><a href="#子元素选择器（重要）" class="headerlink" title="子元素选择器（重要）"></a>子元素选择器（重要）</h5><p>选择父元素中的子元素（只选择子元素)</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">元素1&gt;元素2&#123;样式声明&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>只选择父元素里面的子元素，不会选择孙子元素（子元素的子元素），这是和后代选择器不同的地方。</li>
<li>两个元素之间使用&gt;隔开。</li>
<li>修改的是元素2而不是元素1。</li>
</ul>
<h5 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h5><p>并集选择器可以选择多组标签，并为他们定义相同的样式，通常用于集体声明。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">元素1,元素2&#123;样式声明&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>选择元素1和元素2一起进行修改。</li>
<li>两个元素之间使用逗号隔开，逗号可以理解成和的意思。</li>
<li>任何形式的选择器都可以作为并集选择器的一部分，比如上面说的子元素选择器和后代选择器。</li>
</ul>
<h3 id="css字体属性"><a href="#css字体属性" class="headerlink" title="css字体属性"></a>css字体属性</h3><p>字体属性用于定义字体、大小、粗细、文字样式…..</p>
<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>使用font-family属性定义文本的字体。</p>
<p>语法：</p>
<pre><code>        选择器&#123;
            font-family:字体1,字体2 ;
        &#125;</code></pre>
<ul>
<li>font-family后面可以填写多种字体，各种字体之间必须使用英文状态下的逗号隔开。</li>
<li>如果写了多种字体，会优先使用第一种字体，如果没有安装这种字体，就会去使用第二种，以此类推。</li>
<li>一般来说，如果有空格隔开的多个单词组成的字体名称，使用引号将其括起来，单双引号均可。</li>
<li>开发中通常是直接给body设置字体。</li>
</ul>
<h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>使用font-size属性定义字体大小</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	font-size: xxpx;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>px(像素)大小似乎我们网页的最常用的单位。</li>
<li>不同浏览器的默认字体大小不一致，尽量给字体设置一个准确值。</li>
<li>通常直接给body设置字体大小。</li>
</ul>
<h4 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h4><p>使用font-weight属性设置文本字体的粗细。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	font-weight: normal/bold/直接写数字;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>常用的有三种表现形式 normal/bold/直接写数字，推荐直接写数字。</li>
<li>normal相当于直接写数字的 400，是默认的粗细。</li>
<li>bold定义粗体，相当于直接写数字的700。</li>
<li>直接写数字来设置字体的粗细，后面不用加px，如<code>font-weight: 700</code>。</li>
</ul>
<h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><p>语法</p>
<pre><code>    选择器&#123;
        font-style: normal/italic
    &#125;</code></pre>
<ul>
<li>nomal为正常样式。</li>
<li>italic为斜体。</li>
</ul>
<h4 id="字体的复合属性"><a href="#字体的复合属性" class="headerlink" title="字体的复合属性"></a>字体的复合属性</h4><p>上面我们学了css如何定义字体属性，但是如果使用上面的格式代码太冗长了，因此我们通常将上述属性写在一起。</p>
<p>语法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	font: font-style font-weight font-size/line-height font-family;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>复合属性其实就是简写的方式。</li>
<li>使用font属性时，必须按照上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开。</li>
<li>不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性。否则font将不起作用。</li>
</ul>
<h3 id="css文本属性"><a href="#css文本属性" class="headerlink" title="css文本属性"></a>css文本属性</h3><p>css Text(文本)属性可以定义文本的外观，比如文本的颜色，对齐文本，装饰文本，文本缩进，行间距等等。</p>
<h4 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h4><p>color属性用于定义文本的颜色</p>
<p>语法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	color: 预定义的颜色值/十六进制/RGB代码<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>预定义的颜色值 即一些颜色的英文名，如red,blue,green。</li>
<li>十六进制 #FF0000,#FF6600  使用6位十六进制的数来表示。</li>
<li>RGB代码  rgb(255,0,0)</li>
<li>这些颜色不需要记，开发中使用取色器来取色，最常用的是十六进制表示。</li>
</ul>
<h4 id="对齐文本"><a href="#对齐文本" class="headerlink" title="对齐文本"></a>对齐文本</h4><p>text-align属性用于设置元素文本内容的水平对齐方式（左对齐，居中对齐，右对齐）</p>
<pre><code>选择器&#123;
    text-align: left/center/right
&#125;</code></pre>
<ul>
<li>left 左对齐 默认</li>
<li>center 居中对齐</li>
<li>right 右对齐</li>
</ul>
<h4 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h4><p>text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	text-decoration: none/underline/overline/line-through<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>none 没有装饰线 默认值  <em>最常用</em></p>
</li>
<li><p>underline 下划线 ，a标签自带下划线 <em>常用</em></p>
</li>
<li><p>overline 上划线 <em>几乎不用</em></p>
</li>
<li><p>line-through 删除线  <em>不常用</em></p>
<h4 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h4></li>
</ul>
<p>text-indent属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	text-indent: xxxem;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>em是一个相对单位，就是当前一个字体的大小。如果当前字体没有设置大小，就会按照父元素的文字大小。</li>
<li>段落首行缩进两个字，<code>text-indent: 2em</code>，不管字体有多大，都是缩进两个字符。</li>
</ul>
<h4 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h4><p>line-height属性用国语设置行间的距离（行高），可以控制文字与行之间的距离。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">选择器&#123;<br>	line-height: xxxpx;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="css的引入方式"><a href="#css的引入方式" class="headerlink" title="css的引入方式"></a>css的引入方式</h3><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>内部样式表是写到html页面内部，将所有的css代码抽取出来，单独放到一个<style>标签中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br>	a&#123;<br>		text-decoration: none;<br>	&#125;<br>	p&#123;<br>		text-indent: 2em;<br>	&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>可以控制整个页面的样式。</li>
</ul>
<h4 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h4><p>行内样式表是在元素标签内部的style属性中设定css样式，适合于修改简单的样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-decoration: none;&quot;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>style其实就是标签的属性。</li>
<li>可以控制当前的标签的样式。</li>
</ul>
<h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>样式单独写到css文件中，之后把css文件引入到HTML页面中使用。开发中使用最多的就是这种。</p>
<p>引入外部样式表分为两步：</p>
<ol>
<li>新建一个后缀名为.css的样式文件，把所有的css代码都放入从文件中。</li>
<li>在html中使用<link>标签引入css文件。</li>
</ol>
<h3 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h3><h4 id="快速生成HTML结构语法"><a href="#快速生成HTML结构语法" class="headerlink" title="快速生成HTML结构语法"></a>快速生成HTML结构语法</h4><ol>
<li>生成标签，直接输入标签名+tab键即可，比如div 然后tab键，就可以生成<div> </div>。</li>
<li>如果想要同时生成多个相同标签，加上*就可以了，如div * 3 +tab,就可以快速生成3个div。</li>
<li>如果是有父子关系的标签，可以用&gt;,比如 ul&gt;li +tab就可以了。</li>
<li>如果是有兄弟关系的标签，可以用+ 比如div+p  tab。</li>
<li>如果生成带有类名或者id名的标签，直接写 标签名.类名 或者 标签名#id名 tab键就可以了。</li>
<li>如果生成的div的类名是有顺序的，可以用自增符号$ 如.demo$*5  生成5个div标签，class为demo1-demo5。</li>
<li>如果想要在生成的标签内部写内容可以用{}。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  div+tab  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  p*5 tab  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- ul&gt;li*5 tab--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- div+p tab--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- .demo   p#two tab--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- div.demo$*5 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- div&#123;hahah&#125;*5 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hahah<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hahah<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hahah<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hahah<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hahah<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="快速生成CSS样式"><a href="#快速生成CSS样式" class="headerlink" title="快速生成CSS样式"></a>快速生成CSS样式</h4><p>采取简写形式即可。</p>
<ol>
<li>比如w200 按tab可以生成width:200px;</li>
<li>td 按 tab可以生成text-decoration: none;</li>
</ol>
</style></p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2022/05/29/docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul>
<li>docker pull：拉取镜像</li>
<li>docker images：查看安装的镜像</li>
<li>docker rmi：删除镜像</li>
<li>docker push：推送镜像到远程服务器</li>
<li>docker save ：将镜像导出到磁盘    <code>docker save -o nginx.tar nginx:latest</code>   将nginx:latest 镜像导出到磁盘,文件名叫nginx.tar</li>
<li>docker load：将本地文件加载进docker <code>docker load -i nginx.tar</code>   将nginx.tar 加载进docker</li>
</ul>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><ul>
<li>docker run：创建并运行容器<ul>
<li><code>docker run --name mn-p 80:80 -d nginx</code></li>
<li>– name：给容器起一个名字</li>
<li>-p 端口映射，左边是宿主机端口，右边是容器端口</li>
<li>-d 后台运行容器</li>
<li>nginx 镜像名称</li>
</ul>
</li>
<li>docker pause: 让容器从运行到暂停</li>
<li>docker unpause： 从暂停到运行</li>
<li>docker start：从停止到运行</li>
<li>docker stop：容器从运行到停止</li>
<li>docker ps：查看所有运行的容器及状态<ul>
<li>-a：可以看到被停止的容器信息</li>
</ul>
</li>
<li>docker logs：查看容器运行的日志<ul>
<li>-f  持续查看日志，和linux中的tail一样，会显示最新的日志</li>
</ul>
</li>
<li>docker exec：进入容器执行命令<ul>
<li><code>docker exec -it mn bash</code></li>
<li>-it：给当前进入的容器创建一个标准输入输出端，允许我们与容器交互</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
</li>
<li>docker rm：删除指定容器<ul>
<li>-f：强制删除容器</li>
</ul>
</li>
<li>docker cp 容器名称 容器内路径 宿主机路径 ：复制容器内的文件到宿主机上</li>
<li>docker export 容器名称 &gt; 名称.tar：将容器导出为一个tar归档文件</li>
<li>cat 名称.tar | docker import -镜像用户/镜像名:镜像版本号: 从tar包中的内容创建一个新的文件系统再导入为镜像</li>
</ul>
<h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><ul>
<li>docker volume create： 创建数据卷</li>
<li>docker volume ls： 查看所有数据卷</li>
<li>docker volume inspact：查看某个数据卷具体信息，mountpoint为挂载点</li>
<li>docker volume rm：删除某个指定的数据卷</li>
<li>docker volume prune：删除没使用的数据卷</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220504221503531.png" alt="image-20220504221503531"></p>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote>
<p>docker compose 可以基于compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容易</p>
<p>compose文件是一个文本文件，通过指定定义集群中的每个容器如何运行</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505210454160.png" alt="image-20220505210454160"></p>
<h1 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>我安装的是7.6.2版本，可以到<code>hub.docker.com</code>上查看支持的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker pull elasticsearch:7.6.2<br></code></pre></td></tr></table></figure>



<h2 id="启动Elasticsearch"><a href="#启动Elasticsearch" class="headerlink" title="启动Elasticsearch"></a>启动Elasticsearch</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name elascticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; -e &quot;discover.type=single-node&quot; elasticsearch:7.6.2<br></code></pre></td></tr></table></figure>

<ul>
<li>9300端口是使用tcp客户端连接使用的端口；9200端口是通过http协议连接es使用的端口；</li>
<li>-e ES_JAVA_OPTS=”-Xms64m -Xmx512m” 是配置内存大小，如果不配置，我的虚拟机因为内存小，会变得很卡</li>
<li>-e “discover.type=single-node” 单节点启动</li>
</ul>
<h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=9200/tcp<br></code></pre></td></tr></table></figure>





<h1 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h1><h2 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>kibana和Elasticsearch的关系类似于navicat和mysql的关系。kibana可以查看Elasticsearch中的数据，并且提供一些语法提示。</p>
<p><strong>安装的kibana版本需要和Elasticsearch的版本一致</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker pull kibana:7.6.2<br></code></pre></td></tr></table></figure>



<h2 id="启动kibana"><a href="#启动kibana" class="headerlink" title="启动kibana"></a>启动kibana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name kibana -p 5601:5601 kibana:7.6.2<br></code></pre></td></tr></table></figure>



<h2 id="将kibana和Elasticsearch进行关联"><a href="#将kibana和Elasticsearch进行关联" class="headerlink" title="将kibana和Elasticsearch进行关联"></a>将kibana和Elasticsearch进行关联</h2><p>由于kibana和elasticsearch是运行在docker中的，因此两个之间是相互独立的，没有关联，由于Elasticsearch的9200端口和宿主机的9200端口进行了映射，因此我们可以通过宿主机的9200找到Elasticsearch。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入kibana</span><br>docker exec -it kibana:7.6.2<br><br><span class="hljs-meta">#</span><span class="bash">进入config文件夹</span><br>cd config<br><br><span class="hljs-meta">#</span><span class="bash">修改kibana.yml,注意没有vim指令</span><br>vi kibana.yml<br><span class="hljs-meta">#</span><span class="bash">将elasticsearch.hosts 修改为当前的主机号和端口号</span><br>elasticsearch.hosts: [ &quot;http://192.168.217.4:9200&quot; ]<br></code></pre></td></tr></table></figure>



<h2 id="重启kibana"><a href="#重启kibana" class="headerlink" title="重启kibana"></a>重启kibana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker restart kibana<br></code></pre></td></tr></table></figure>



<h2 id="开放端口-1"><a href="#开放端口-1" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=5601/tcp<br></code></pre></td></tr></table></figure>





<h1 id="一键启动kibana和Elasticsearch"><a href="#一键启动kibana和Elasticsearch" class="headerlink" title="一键启动kibana和Elasticsearch"></a>一键启动kibana和Elasticsearch</h1><h2 id="编写composs"><a href="#编写composs" class="headerlink" title="编写composs"></a>编写composs</h2><p>当我们重新启动一个kibana的容器，都需要重新将他与elasticsearch关联起来。</p>
<p>同时两个服务也是需要一同启动的因此我们编写一个compose，同时启动两个服务，并且写好配置，将kibana的kibana.yml与宿主机的配置文件进行关联，这样就不需要每次都修改kibana内部的文件。</p>
<h3 id="复制kibana配置文件"><a href="#复制kibana配置文件" class="headerlink" title="复制kibana配置文件"></a>复制kibana配置文件</h3><p>将配置文件复制到宿主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">创建文件夹</span><br>mkdir /opt/es-kibana<br>cd /opt/es-kibana<br><span class="hljs-meta">#</span><span class="bash">复制文件</span><br>docker cp kibana:/usr/share/kibana/config/kibana.yml /opt/es-kibana<br><span class="hljs-meta">#</span><span class="bash">修改文件内容，因为下面配置了compose，所以可以直接写网络名称</span><br>elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ]<br></code></pre></td></tr></table></figure>



<h3 id="编写Compose文件"><a href="#编写Compose文件" class="headerlink" title="编写Compose文件"></a>编写Compose文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">编写文件</span><br>vim docker-compose.yml<br></code></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.3&quot;</span>													<span class="hljs-comment">#指定语法的版本格式</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config:</span><br>  <span class="hljs-attr">plugin:</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">es:</span><br><span class="hljs-attr">services:</span>														<span class="hljs-comment">#定义服务</span><br>   <span class="hljs-attr">elasticsearch:</span>												<span class="hljs-comment">#服务名称</span><br>     <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch:7.6.2</span>									<span class="hljs-comment">#镜像</span><br>     <span class="hljs-attr">ports:</span>														<span class="hljs-comment">#端口映射</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9200:9200&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9300:9300&quot;</span><br>     <span class="hljs-attr">networks:</span>                                                  <span class="hljs-comment">#网络</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;es&quot;</span><br>     <span class="hljs-attr">environment:</span>												<span class="hljs-comment">#容器内部环境变量</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.type=single-node&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms64m -Xmx512m&quot;</span><br>     <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">data:/usr/share/elasticsearch/data</span>                    <span class="hljs-comment">#挂载数据卷</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">config:/usr/share/elasticsearch/config</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">plugin:/usr/share/elasticsearch/plugins</span><br><br>   <span class="hljs-attr">kibana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:7.6.2</span><br>    <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5601:5601&quot;</span> <br>    <span class="hljs-attr">networks:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;es&quot;</span> <br>    <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/kibana_config/kibana.yml</span><br><br></code></pre></td></tr></table></figure>



<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<br><br>chmod +x /usr/local/bin/docker-compose<br><br>docker-compose -v <br></code></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在 docker-compose.yml的当前路径下</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure>





<h1 id="docker启动mysql"><a href="#docker启动mysql" class="headerlink" title="docker启动mysql"></a>docker启动mysql</h1><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d mysql:latest             以后台的方式运行 mysql 版本的镜像，生成一个容器。<br>    --name mysql                           容器名为 mysql<br>    -e MYSQL_ROOT_PASSWORD=123456          设置登陆密码为 123456，登陆用户为 root<br>    -p 3306:3306                           将容器内部 3306 端口映射到 主机的 3306 端口，即通过 主机的 3306 可以访问容器的 3306 端口<br>    -v /usr/mydata/mysql/log:/var/log/mysql    将容器的 日志文件夹 挂载到 主机的相应位置<br>    -v /usr/mydata/mysql/data:/var/lib/mysql   将容器的 数据文件夹 挂载到 主机的相应位置<br>    -v /usr/mydata/mysql/conf:/etc/mysql/conf.d   将容器的 自定义配置文件夹 挂载到主机的相应位置<br>    <br>【查看容器是否启动：】<br>docker ps -a<br></code></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /usr/mydata/mysql/log:/var/log/mysql -v /usr/mydata/mysql/data:/var/lib/mysql -v /usr/mydata/mysql/conf:/etc/mysql/conf.d mysql:8.0.2<br></code></pre></td></tr></table></figure>



<p><strong>在启动mysql的时候需要挂载数据卷，否则如果容器被删除，那么数据库中的数据将全部丢失，这是一个很严重的问题，可以使用 -v 挂载数据卷到宿主机。其次由于没有配置数据库，因此数据库的默认编码是<code>latin1</code>，这时如果插入中文数据会报错，因此我们需要修改配置。使用<code> SHOW VARIABLES LIKE &#39;character%&#39;</code>可以查看编码设置。</strong></p>
<p><strong>上面的命令已经挂载了数据卷，-v  ：前面的是宿主机的路径，后面是容器的路径。我们在宿主机的conf目录下创建my.cnf文件，然后将下面代码复制到my.cnf文件即可</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[client]<br>default_character_set=utf8<br>[mysqld]<br>collation_server = utf8_general_ci<br>character_set_server = utf8<br></code></pre></td></tr></table></figure>



<h1 id="docker安装rabbitmq"><a href="#docker安装rabbitmq" class="headerlink" title="docker安装rabbitmq"></a>docker安装rabbitmq</h1><h2 id="拉取镜像-2"><a href="#拉取镜像-2" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p><code>docker pull rabbitmq:3.8.8</code>   后面不选择版本默认是最新版</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220412175244314.png" alt="image-20220412175244314"></p>
<h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name=rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3.8.8<br>-d 表示后台启动<br>--name 给容器起个名字，这样后面可以根据名字操作容器<br>-p 映射端口<br>rabbitmq:3.8.8 如果没写后面的版本号，会默认启动最新版，没有最新版会下载<br></code></pre></td></tr></table></figure>



<h2 id="开放端口-2"><a href="#开放端口-2" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent -add-p=15672/tcp<br>filewall-cmd --permanent -add-p=5672/tcp<br></code></pre></td></tr></table></figure>

<p><strong>开放服务器5672、15672两个端口</strong></p>
<h2 id="安装web管理页面"><a href="#安装web管理页面" class="headerlink" title="安装web管理页面"></a>安装web管理页面</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入rabbitmq容器</span><br>docker exec -it rabbitmq /bin/bash<br><span class="hljs-meta">#</span><span class="bash">启动插件</span><br>rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure>

<p><strong>此时可以使用服务器ip:15672 进行访问，默认用户名密码都为guest</strong></p>
<h2 id="安装延时插件"><a href="#安装延时插件" class="headerlink" title="安装延时插件"></a>安装延时插件</h2><ol>
<li><p>下载插件：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">下载地址</a></p>
</li>
<li><p>将插件传输到linux系统中，我是使用xftp上传到 /opt目录下</p>
</li>
<li><p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将插件拷贝到容器</span><br>docker cp /opt/rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq:/plugins   #前面是插件在linux中的地址，后面的rabbitmq是容器的名字<br><span class="hljs-meta">#</span><span class="bash"> 进入容器内部</span><br>docker exec -it rabbitmq /bin/bash  #rabbimq是容器名字<br><span class="hljs-meta">#</span><span class="bash"> 进入plugins</span><br>cd plugins<br><span class="hljs-meta">#</span><span class="bash"> 安装插件</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入管理页面，看到type有<code>x-delayed-message</code>则成功安装延时插件</p>
</li>
</ol>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220412180709472.png" alt="image-20220412180709472"></p>
<h1 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h1><p><strong>首先在宿主机创建一个redis目录，然后将默认的redis.conf文件复制到该目录下。如果没有，可以使用下面提供的配置。然后修改redis.conf目录下的配置，主要修改：<code>bind</code>，注释或者改为允许连接的ip地址，一般设置为0.0.0.0；<code>requirepass</code> 设置密码；·<code>daemonize</code>修改为no，不是后台启动，否则与docker run -d 冲突。</strong></p>
<p><strong>然后使用下面的命令启动redis</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p6379:6379 --name redis -v /usr/mydata/redis/redis.conf:/etc/redis/redis.conf -v /us<br>r/mydata/redis/data:/data -d redis:6.2.6 redis-server /etc/redis/redis.conf<br></code></pre></td></tr></table></figure>

<p><code>redis-server /etc/redis/redis.conf</code>表示读取redis.conf文件启动redis，由于容器内的redis.conf文件和宿主机的关联起来，因此读取的是宿主机的配置文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"># Redis configuration file example.<br><br>#<br><br># Note that in order to read the configuration file, Redis must be<br><br># started with the file path as first argument:<br><br>#<br><br># ./redis-server /path/to/redis.conf<br><br> <br><br># Note on units: when memory size is needed, it is possible to specify<br><br># it in the usual form of 1k 5GB 4M and so forth:<br><br>#<br><br># 1k =&gt; 1000 bytes<br><br># 1kb =&gt; 1024 bytes<br><br># 1m =&gt; 1000000 bytes<br><br># 1mb =&gt; 1024*1024 bytes<br><br># 1g =&gt; 1000000000 bytes<br><br># 1gb =&gt; 1024*1024*1024 bytes<br><br>#<br><br># units are case insensitive so 1GB 1Gb 1gB are all the same.<br><br> <br><br>################################## INCLUDES ###################################<br><br> <br><br># Include one or more other config files here.  This is useful if you<br><br># have a standard template that goes to all Redis servers but also need<br><br># to customize a few per-server settings.  Include files can include<br><br># other files, so use this wisely.<br><br>#<br><br># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;<br><br># from admin or Redis Sentinel. Since Redis always uses the last processed<br><br># line as value of a configuration directive, you&#x27;d better put includes<br><br># at the beginning of this file to avoid overwriting config change at runtime.<br><br>#<br><br># If instead you are interested in using includes to override configuration<br><br># options, it is better to use include as the last line.<br><br>#<br><br># include /path/to/local.conf<br><br># include /path/to/other.conf<br><br> <br><br>################################## MODULES #####################################<br><br> <br><br># Load modules at startup. If the server is not able to load modules<br><br># it will abort. It is possible to use multiple loadmodule directives.<br><br>#<br><br># loadmodule /path/to/my_module.so<br><br># loadmodule /path/to/other_module.so<br><br> <br><br>################################## NETWORK #####################################<br><br> <br><br># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens<br><br># for connections from all the network interfaces available on the server.<br><br># It is possible to listen to just one or multiple selected interfaces using<br><br># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.<br><br>#<br><br># Examples:<br><br>#<br><br># bind 192.168.1.100 10.0.0.1<br><br># bind 127.0.0.1 ::1<br><br>#<br><br># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the<br><br># internet, binding to all the interfaces is dangerous and will expose the<br><br># instance to everybody on the internet. So by default we uncomment the<br><br># following bind directive, that will force Redis to listen only into<br><br># the IPv4 loopback interface address (this means Redis will be able to<br><br># accept connections only from clients running into the same computer it<br><br># is running).<br><br>#<br><br># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES<br><br># JUST COMMENT THE FOLLOWING LINE.<br><br># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>#bind 127.0.0.1<br><br> <br><br># Protected mode is a layer of security protection, in order to avoid that<br><br># Redis instances left open on the internet are accessed and exploited.<br><br>#<br><br># When protected mode is on and if:<br><br>#<br><br># 1) The server is not binding explicitly to a set of addresses using the<br><br>#    &quot;bind&quot; directive.<br><br># 2) No password is configured.<br><br>#<br><br># The server only accepts connections from clients connecting from the<br><br># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain<br><br># sockets.<br><br>#<br><br># By default protected mode is enabled. You should disable it only if<br><br># you are sure you want clients from other hosts to connect to Redis<br><br># even if no authentication is configured, nor a specific set of interfaces<br><br># are explicitly listed using the &quot;bind&quot; directive.<br><br>protected-mode no<br><br> <br><br># Accept connections on the specified port, default is 6379 (IANA #815344).<br><br># If port 0 is specified Redis will not listen on a TCP socket.<br><br>port 6379<br><br> <br><br># TCP listen() backlog.<br><br>#<br><br># In high requests-per-second environments you need an high backlog in order<br><br># to avoid slow clients connections issues. Note that the Linux kernel<br><br># will silently truncate it to the value of /proc/sys/net/core/somaxconn so<br><br># make sure to raise both the value of somaxconn and tcp_max_syn_backlog<br><br># in order to get the desired effect.<br><br>tcp-backlog 511<br><br> <br><br># Unix socket.<br><br>#<br><br># Specify the path for the Unix socket that will be used to listen for<br><br># incoming connections. There is no default, so Redis will not listen<br><br># on a unix socket when not specified.<br><br>#<br><br># unixsocket /tmp/redis.sock<br><br># unixsocketperm 700<br><br> <br><br># Close the connection after a client is idle for N seconds (0 to disable)<br><br>timeout 0<br><br> <br><br># TCP keepalive.<br><br>#<br><br># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence<br><br># of communication. This is useful for two reasons:<br><br>#<br><br># 1) Detect dead peers.<br><br># 2) Take the connection alive from the point of view of network<br><br>#    equipment in the middle.<br><br>#<br><br># On Linux, the specified value (in seconds) is the period used to send ACKs.<br><br># Note that to close the connection the double of the time is needed.<br><br># On other kernels the period depends on the kernel configuration.<br><br>#<br><br># A reasonable value for this option is 300 seconds, which is the new<br><br># Redis default starting with Redis 3.2.1.<br><br>tcp-keepalive 300<br><br> <br><br>################################# GENERAL #####################################<br><br> <br><br># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.<br><br># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.<br><br>daemonize no<br><br> <br><br># If you run Redis from upstart or systemd, Redis can interact with your<br><br># supervision tree. Options:<br><br>#   supervised no      - no supervision interaction<br><br>#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode<br><br>#   supervised systemd - signal systemd by writing READY=1 to <span class="hljs-formula">$NOTIFY_SOCKET</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">supervised no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and removes it at exit.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># nothing bad happens, the server will start and run normally.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">pidfile /var/run/redis_6379.pid</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the server verbosity level.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This can be one of:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># warning (only very important / critical messages are logged)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">loglevel notice</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the log file name. Also the empty string can be used to force</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis to log on the standard output. Note that if you use standard</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">logfile &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># syslog-enabled no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the syslog identity.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># syslog-ident redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># syslog-facility local0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">databases 16</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that normally a logo is displayed only in interactive sessions.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">always-show-logo yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ SNAPSHOTTING  ################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Save the DB on disk:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   Will save the DB if both the given number of seconds and the given</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   number of write operations against the DB occurred.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   In the example below the behaviour will be to save:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   after 60 sec if at least 10000 keys changed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   It is also possible to remove all the previously configured save</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   points by adding a save directive with a single empty string argument</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   like in the following example:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   save &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">save 900 1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">save 300 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">save 60 10000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (at least one save point) and the latest background save failed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disaster will happen.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the background saving process will start working again Redis will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># automatically allow writes again.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However if you have setup your proper monitoring of the Redis server</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># continue to work as usual even if there are problems with disk,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># permissions, and so forth.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">stop-writes-on-bgsave-error yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">rdbcompression yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This makes the format more resistant to corruption but there is a performance</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for maximum performances.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tell the loading code to skip the check.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">rdbchecksum yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The filename where to dump the DB</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">dbfilename dump.rdb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The working directory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The DB will be written inside this directory, with the filename specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Append Only File will also be created inside this directory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that you must specify a directory here, not a file name.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">dir ./</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################# REPLICATION #################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   +------------------+      +---------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   |      Master      | ---&gt; |    Replica    |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   | (receive writes) |      |  (exact copy) |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   +------------------+      +---------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    a given number of replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    master if the replication link is lost for a relatively small amount of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    network partition replicas automatically try to reconnect to masters</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    and resynchronize with them.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># directive below) it is possible to tell the replica to authenticate before</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># starting the replication synchronization process, otherwise the master will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># refuse the replica request.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># masterauth &lt;master-password&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When a replica loses its connection with the master, or when the replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is still in progress, the replica can act in two different ways:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    data set may just be empty if this is the first synchronization.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    COMMAND, POST, HOST: and LATENCY.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-serve-stale-data yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># You can configure a replica instance to accept writes or not. Writing against</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a replica instance may be useful to store some ephemeral data (because data</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># written on a replica will be easily deleted after resync with the master) but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># may also cause problems if clients are writing to it because of a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># misconfiguration.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Since Redis 2.6 by default replicas are read-only.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note: read only replicas are not designed to be exposed to untrusted clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Still a read only replica exports by default all the administrative commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># administrative / dangerous commands.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-read-only yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Replication SYNC strategy: disk or socket.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -------------------------------------------------------</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -------------------------------------------------------</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># New replicas and reconnecting replicas that are not able to continue the replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># process just receiving differences, need to do what is called a &quot;full</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># synchronization&quot;. An RDB file is transmitted from the master to the replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The transmission can happen in two different ways:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#                 file on disk. Later the file is transferred by the parent</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#                 process to the replicas incrementally.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#              RDB file to replica sockets, without touching the disk at all.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># can be queued and served with the RDB file as soon as the current child producing</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the RDB file finishes its work. With diskless replication instead once</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the transfer starts, new replicas arriving will be queued and a new transfer</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will start when the current one terminates.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># time (in seconds) before starting the transfer in the hope that multiple replicas</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will arrive and the transfer can be parallelized.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># works better.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">repl-diskless-sync no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to the replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># new replicas arriving, that will be queued for the next RDB transfer, so the server</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># waits a delay in order to let more replicas arrive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">repl-diskless-sync-delay 5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Replicas send PINGs to server in a predefined interval. It&#x27;s possible to change</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this interval with the repl_ping_replica_period option. The default value is 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-ping-replica-period 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The following option sets the replication timeout for:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is important to make sure that this value is greater than the value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># every time there is low traffic between the master and the replica.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-timeout 60</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Linux kernels using a default configuration.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># be reduced but more bandwidth will be used for replication.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># be a good idea.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">repl-disable-tcp-nodelay no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica data when replicas are disconnected for some time, so that when a replica</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># wants to reconnect again, often a full resync is not needed, but a partial</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># resync is enough, just passing the portion of data the replica missed while</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disconnected.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The bigger the replication backlog, the longer the time the replica can be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The backlog is only allocated once there is at least a replica connected.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-backlog-size 1mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># After a master has no longer connected replicas for some time, the backlog</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will be freed. The following option configures the amount of seconds that</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># need to elapse, starting from the time the last replica disconnected, for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the backlog buffer to be freed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that replicas never free the backlog for timeout, since they may be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># resynchronize&quot; with the replicas: hence they should always accumulate backlog.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A value of 0 means to never release the backlog.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-backlog-ttl 3600</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The replica priority is an integer number published by Redis in the INFO output.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is used by Redis Sentinel in order to select a replica to promote into a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master if the master is no longer working correctly.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A replica with a low priority number is considered better for promotion, so</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for instance if there are three replicas with priority 10, 100, 25 Sentinel will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># pick the one with priority 10, that is the lowest.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However a special priority of 0 marks the replica as not able to perform the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># role of master, so a replica with priority of 0 will never be selected by</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis Sentinel for promotion.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default the priority is 100.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-priority 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># N replicas connected, having a lag less or equal than M seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The N replicas need to be in &quot;online&quot; state.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the last ping received from the replica, that is usually sent every second.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are available, to the specified number of seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># min-replicas-to-write 3</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># min-replicas-max-lag 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Setting one or the other to 0 disables the feature.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># min-replicas-max-lag is set to 10.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A Redis master is able to list the address and port of the attached</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># offers this information, which is used, among other tools, by</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis Sentinel in order to discover replica instances.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Another place where this info is available is in the output of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;ROLE&quot; command of a master.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The listed IP and address normally reported by a replica is obtained</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in the following way:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   IP: The address is auto detected by checking the peer address</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   of the socket used by the replica to connect with the master.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   Port: The port is communicated by the replica during the replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   handshake, and is normally the port that the replica is using to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   listen for connections.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used, the replica may be actually reachable via different IP and port</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># pairs. The following two options can be used by a replica in order to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and ROLE will report those values.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There is no need to use both the options if you need to override just</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the port or the IP address.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica-announce-ip 5.5.5.5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica-announce-port 1234</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################## SECURITY ###################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># commands.  This might be useful in environments in which you do not trust</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># others with access to the host running redis-server.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This should stay commented out for backward compatibility and because most</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># people do not need auth (e.g. they run their own servers).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 150k passwords per second against a good box. This means that you should</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># use a very strong password otherwise it will be very easy to break.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># requirepass foobared</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Command renaming.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is possible to change the name of dangerous commands in a shared</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># hard to guess so that it will still be available for internal-use tools</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># but not available for general clients.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Example:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is also possible to completely kill a command by renaming it into</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># an empty string:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># rename-command CONFIG &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Please note that changing the name of commands that are logged into the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># AOF file or transmitted to replicas may cause problems.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################### CLIENTS ####################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set the max number of connected clients at the same time. By default</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># able to configure the process file limit to allow for the specified limit</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the max number of allowed clients is set to the current file limit</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># an error &#x27;max number of clients reached&#x27;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxclients 10000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################## MEMORY MANAGEMENT ################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When the memory limit is reached Redis will try to remove keys</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to reply to read-only commands like GET.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># from the used memory count, so that network problems / resyncs will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of more keys, and so forth until the database is completely emptied.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxmemory &lt;bytes&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is reached. You can select among five behaviors:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-random -&gt; Remove a random key among the ones with an expire set.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># LRU means Least Recently Used</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># LFU means Least Frequently Used</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># randomized algorithms.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       operations, when there are no suitable keys for eviction.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       At the date of writing these commands are: set setnx setex append</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       getset mset msetnx exec sort</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default is:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxmemory-policy noeviction</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used less recently, you can change the sample size using the following</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># configuration directive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxmemory-samples 5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (unless it is promoted to master after a failover or manually). It means</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that the eviction of keys will be just handled by the master, sending the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># DEL commands to the replica as keys evict in the master side.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># what you want, however if your replica is writable, or you want the replica to have</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a different memory setting, and you are sure all the writes performed to the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica are idempotent, then you may change this default (but be sure to understand</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># what you are doing).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that since the replica by default does not evict, it may end using more</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># be larger on the replica, or data structures may sometimes take more memory and so</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># forth). So make sure you monitor your replicas and make sure they have enough</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># memory to never hit a real out-of-memory condition before the master hits</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the configured maxmemory setting.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica-ignore-maxmemory yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################# LAZY FREEING ####################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># deletion of the object. It means that the server stops processing new commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># aggregated value containing millions of elements, the server can block for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a long time (even seconds) in order to complete the operation.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are executed in constant time. Another thread will incrementally free the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># object in the background as fast as possible.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># following scenarios:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    in order to make room for new data, without going over the specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    memory limit.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    EXPIRE command) must be deleted from memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    already exist. For example the RENAME command may delete the old key</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    itself removes any old content of the specified key in order to replace</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    it with the specified string.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 4) During replication, when a replica performs a full resynchronization with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    its master, the content of the whole database is removed in order to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    load the RDB file just transferred.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># like if DEL was called. However you can configure each case specifically</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># was called, using the following configuration directives:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lazyfree-lazy-eviction no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lazyfree-lazy-expire no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lazyfree-lazy-server-del no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-lazy-flush no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################## APPEND ONLY MODE ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># good enough in many applications, but an issue with the Redis process or</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the configured save points).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Append Only File is an alternative persistence mode that provides</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># much better durability. For instance using the default data fsync policy</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># dramatic event like a server power outage, or a single write if something</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># still running correctly.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># with the better durability guarantees.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Please check http://redis.io/topics/persistence for more information.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">appendonly no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">appendfilename &quot;appendonly.aof&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis supports three different modes:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># everysec: fsync only one time every second. Compromise.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># it wants, for better performances (but if you can live with the idea of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># everysec.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># More details please check the following article:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If unsure, use &quot;everysec&quot;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># appendfsync always</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">appendfsync everysec</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># appendfsync no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># saving process (a background save or AOF log background rewriting) is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this currently, as even performing fsync in a different thread will block</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># our synchronous write(2) call.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that will prevent fsync() from being called in the main process while a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This means that while another child is saving, the durability of Redis is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># default Linux settings).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">no-appendfsync-on-rewrite no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Automatic rewrite of the append only file.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the AOF at startup is used).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This base size is compared to the current size. If the current size is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is reached but it is still pretty small.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># rewrite feature.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">auto-aof-rewrite-percentage 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">auto-aof-rewrite-min-size 64mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This may happen when the system where Redis is running</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data=ordered option (however this can&#x27;t happen when Redis itself</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># crashes or aborts but the operating system still works correctly).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis can either exit with an error when this happens, or load as much</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data as possible (the default now) and start if the AOF file is found</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to be truncated at the end. The following option controls this behavior.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and refuses to start. When the option is set to no, the user requires</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the server.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the server will still exit with an error. This option only applies when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will be found.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">aof-load-truncated yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   [RDB file][AOF tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tail.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">aof-use-rdb-preamble yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ LUA SCRIPTING  ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Max execution time of a Lua script in milliseconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># still in execution after the maximum allowed time and will start to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># reply to queries with an error.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When a long running script exceeds the maximum execution time only the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used to stop a script that did not yet called write commands. The second</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is the only way to shut down the server in the case a write command was</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># termination of the script.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lua-time-limit 5000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ REDIS CLUSTER  ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster node enable the cluster support uncommenting the following:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-enabled yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Make sure that instances running in the same system do not have</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># overlapping cluster configuration file names.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-config-file nodes-6379.conf</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for it to be considered in failure state.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Most other internal time limits are multiple of the node timeout.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-node-timeout 15000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A replica of a failing master will avoid to start a failover if its data</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># looks too old.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There is no simple way for a replica to actually have an exact measure of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    in order to try to give an advantage to the replica with the best</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    replication offset (more data from the master processed).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    of the failover a delay proportional to their rank.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Every single replica computes the time of the last interaction with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    its master. This can be the last ping or command received (if the master</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    disconnection with the master (if the replication link is currently down).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    If the last interaction is too old, the replica will not try to failover</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    at all.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the failover if, since the last interaction with the master, the time</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># elapsed is greater than:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica will not try to failover if it was not able to talk with the master</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for longer than 310 seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># elect a replica at all.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to a value of 0, which means, that replicas will always try to failover the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master regardless of the last time they interacted with the master.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># offset rank).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the cluster will always be able to continue.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-replica-validity-factor 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that are left without working replicas. This improves the cluster ability</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in case of failure if it has no working replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># given number of other working replicas for their old master. This number</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will migrate only if there is at least 1 other working replica for its master</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and so forth. It usually reflects the number of replicas you want for every</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master in your cluster.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># one replica). To disable migration just set it to a very large value.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in production.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-migration-barrier 1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However sometimes you want the subset of the cluster which is working,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to continue to accept queries for the part of the key space that is still</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># option to no.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-require-full-coverage yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master during master failures. However the master can still perform a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># manual failover, if forced to do so.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This is useful in different scenarios, especially in the case of multiple</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data center operations, where we want one side to never be promoted if not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in the case of a total DC failure.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-replica-no-failover no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In order to setup your cluster make sure to read the documentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># available at http://redis.io web site.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">########################## CLUSTER DOCKER/NAT support  ########################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Docker and other containers).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In order to make Redis Cluster working in such environments, a static</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># configuration where each node knows its public address is needed. The</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># following two options are used for this scope, and are:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># * cluster-announce-ip</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># * cluster-announce-port</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># * cluster-announce-bus-port</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Each instruct the node about its address, client port, and cluster message</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># bus port. The information is then published in the header of the bus packets</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># so that other nodes will be able to correctly map the address of the node</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># publishing the information.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will be used instead.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 10000 will be used as usually.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Example:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-announce-ip 10.1.1.5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-announce-port 6379</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-announce-bus-port 6380</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################## SLOW LOG ###################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># execution time. The execution time does not include the I/O operations</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># like talking with the client, sending the reply and so forth,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># but just the time needed to actually execute the command (this is the only</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># stage of command execution where the thread is blocked and can not serve</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># other requests in the meantime).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># command to get logged, and the other parameter is the length of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># queue of logged commands.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to one second. Note that a negative number disables the slow log, while</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a value of zero forces the logging of every command.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">slowlog-log-slower-than 10000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">slowlog-max-len 128</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ LATENCY MONITOR ##############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Redis latency monitoring subsystem samples different operations</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># at runtime in order to collect data related to possible sources of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># latency of a Redis instance.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Via the LATENCY command this information is available to the user that can</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># print graphs and obtain reports.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The system only logs operations that were performed in a time equal or</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># greater than the amount of milliseconds specified via the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to zero, the latency monitor is turned off.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># impact, that while very small, can be measured under big load. Latency</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># monitoring can easily be enabled at runtime using the command</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">latency-monitor-threshold 0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################# EVENT NOTIFICATION ##############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For instance if keyspace events notification is enabled, and a client</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># messages will be published via Pub/Sub:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># PUBLISH __keyspace@0__:foo del</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># PUBLISH __keyevent@0__:del foo</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is possible to select the events that Redis will notify among a set</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of classes. Every class is identified by a single character:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  $</span>     String commands<br><br>#  l     List commands<br><br>#  s     Set commands<br><br>#  h     Hash commands<br><br>#  z     Sorted set commands<br><br>#  x     Expired events (events generated every time a key expires)<br><br>#  e     Evicted events (events generated when a key is evicted for maxmemory)<br><br>#  A     Alias for g<span class="hljs-formula">$lshzxe, so that the &quot;AKE&quot; string means all the events.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  are disabled.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#           event name, use:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  notify-keyspace-events Elg</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#             name __keyevent@0__:expired use:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">  notify-keyspace-events Ex</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  By default all notifications are disabled because most users don&#x27;t need</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  specify at least one of K or E, no events will be delivered.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#notify-keyspace-events &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################### ADVANCED CONFIG ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># threshold. These thresholds can be configured using the following directives.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hash-max-ziplist-entries 512</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hash-max-ziplist-value 64</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The number of entries allowed per internal list node can be specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># as a fixed maximum size or a maximum number of elements.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># per list node.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">list-max-ziplist-size -2</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Lists may also be compressed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 0: disable all list compression</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    going from either the head or tail&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    but compress all nodes between them.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># etc.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">list-compress-depth 0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of 64 bit signed integers.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The following configuration setting sets the limit in the size of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># set in order to use this special memory saving encoding.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">set-max-intset-entries 512</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># elements of a sorted set are below the following limits:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">zset-max-ziplist-entries 128</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">zset-max-ziplist-value 64</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this limit, it is converted into the dense representation.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># dense representation is more memory efficient.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hll-sparse-max-bytes 3000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Streams macro node max size / items. The stream data structure is a radix</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># it is possible to configure how big a single node can be in bytes, and the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maximum number of items it may contain before switching to a new node when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># appending new stream entries. If any of the following settings are set to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># value.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">stream-node-max-bytes 4096</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">stream-node-max-entries 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># by the hash table.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default is to use this millisecond 10 times every second in order to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If unsure:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to queries with 2 milliseconds delay.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># want to free memory asap when possible.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">activerehashing yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that are not reading data from the server fast enough for some reason (a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># publisher can produce them).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The limit can be set differently for the three different classes of clients:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># normal -&gt; normal clients including MONITOR clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica  -&gt; replica clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the soft limit is reached and remains reached for the specified number of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># seconds (continuously).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the limit for 10 seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># without asking (in a push way), but just after a request, so only</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># than it can read.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Instead there is a default limit for pubsub and replica clients, since</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># subscribers and replicas receive data in a push fashion.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">client-output-buffer-limit normal 0 0 0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the query buffer. However you can configure it here if you have very special</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># needs, such us huge multi/exec requests or alike.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># client-query-buffer-limit 1gb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># here.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># proto-max-bulk-len 512mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis calls an internal function to perform many background tasks, like</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># never requested, and so forth.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># handled with more precision.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 100 only in environments where very low latency is required.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hz 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Normally it is useful to have an HZ value which is proportional to the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># number of clients connected. This is useful in order, for instance, to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># avoid too many clients are processed for each background task invocation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to avoid latency spikes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># which will temporary raise when there are many connected clients.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When dynamic HZ is enabled, the actual configured HZ will be used as</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used as needed once more clients are connected. In this way an idle</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># instance will use very little CPU time while a busy instance will be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># more responsive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">dynamic-hz yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># big latency spikes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">aof-rewrite-incremental-fsync yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When redis saves RDB file, if the following option is enabled</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># big latency spikes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">rdb-save-incremental-fsync yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># idea to start with the default settings and only change them after investigating</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># understand what the two parameters mean before changing them.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this way:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3. The counter is incremented only if R &lt; P.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># counter changes with a different number of accesses with different</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># logarithmic factors:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># NOTE: The above table was obtained by running the following commands:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   redis-benchmark -n 1000000 incr foo</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   redis-cli object freq foo</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to accumulate hits.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># less &lt;= 10).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># decay the counter every time it happens to be scanned.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># lfu-log-factor 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># lfu-decay-time 1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># even in production and manually tested by multiple engineers for some</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># time.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># What is active defragmentation?</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -------------------------------</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># thus allowing to reclaim back memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># away all the data and create it again. However thanks to this feature</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in an &quot;hot&quot; way, while the server is running.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Basically when the fragmentation is over a certain level (see the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># configuration options below) Redis will start to create new copies of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will cause the fragmentation to drop back to normal values.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Important things to understand:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    This is the default with Linux builds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    issues.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a good idea to leave the defaults untouched.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Enabled active defragmentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># activedefrag yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-ignore-bytes 100mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Minimum percentage of fragmentation to start active defrag</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-threshold-lower 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-threshold-upper 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Minimal effort for defrag in CPU percentage</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-cycle-min 5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Maximal effort for defrag in CPU percentage</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-cycle-max 75</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the main dictionary scan</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-max-scan-fields 1000</span><br></code></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2022/07/13/RPC/</url>
    <content><![CDATA[<h1 id="01-什么是-RPC？原理是什么？"><a href="#01-什么是-RPC？原理是什么？" class="headerlink" title="01 什么是 RPC？原理是什么？"></a>01 什么是 RPC？原理是什么？</h1><h2 id="1-什么是-RPC？"><a href="#1-什么是-RPC？" class="headerlink" title="1. 什么是 RPC？"></a>1. 什么是 RPC？</h2><p>RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p>
<p>为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p>
<p>RPC 能帮助我们做什么呢？  简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p>
<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>
<p>一言蔽之：RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</p>
<h2 id="2-RPC-原理是什么？"><a href="#2-RPC-原理是什么？" class="headerlink" title="2. RPC 原理是什么？"></a>2. RPC 原理是什么？</h2><p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 6 个部分实现的：</p>
<ol>
<li>客户端（服务消费端） ：调用远程方法的一端。</li>
<li>客户端 Stub（桩） ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>
<li>网络传输 ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li>
<li>服务端 Stub（桩） ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li>
<li>服务端（服务提供端） ：提供远程方法的一端。</li>
</ol>
<p>具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704120100609.png" alt="image-20220704120100609"></p>
<ol>
<li>服务消费端（client）以本地调用的方式调用远程服务；</li>
<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；</li>
<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: RpcRequest；</li>
<li>服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li>
<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；</li>
<li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:RpcResponse ，这样也就得到了最终结果。over!</li>
</ol>
<p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p>
<p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p>
<p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p>
<h1 id="02-常见RPC框架介绍"><a href="#02-常见RPC框架介绍" class="headerlink" title="02 常见RPC框架介绍"></a>02 常见RPC框架介绍</h1><h2 id="常见RPC框架介绍"><a href="#常见RPC框架介绍" class="headerlink" title="常见RPC框架介绍"></a>常见RPC框架介绍</h2><p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC这些。   如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704120316871.png" alt="image-20220704120316871"></p>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：</p>
<ol>
<li>面向接口的远程方法调用</li>
<li>智能容错和负载均衡</li>
<li>服务自动注册和发现。</li>
</ol>
<p>简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。</p>
<p>截止到今天（2020-07-14） ， Dubbo 目前已经有接近 32.9k 的 Star 。</p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<p>可以说 Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！<br>如果要进一步学习的学习的话，这里有参考文档：</p>
<ol>
<li>Github ：<a href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a></li>
<li>官网：<a href="https://dubbo.apache.org/zh-cn/">https://dubbo.apache.org/zh-cn/</a></li>
</ol>
<h3 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a>Motan</h3><p>motan 是今年(2016 年)新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上流传的资料也比较少。</p>
<p>很多人喜欢拿 motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：<strong>motan 更像是一个精简版的 dubbo，可能是借鉴了 Dubbo 的思想，motan 的设计更加精简，功能更加纯粹。</strong></p>
<p>不过，我不推荐你在实际项目中使用 motan。<strong>如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</strong></p>
<p>如果要进一步学习的学习的话，这里有参考文档：</p>
<p>1<br>从 motan 看 RPC 框架设计：<a href="http://kriszhang.com/motan-rpc-impl/">http://kriszhang.com/motan-rpc-impl/</a><br>2<br>motan 中文文档：<a href="https://github.com/weibocom/motan/wiki/zh_overview">https://github.com/weibocom/motan/wiki/zh_overview</a></p>
<h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704120441271.png" alt="image-20220704120441271"></p>
<p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p>
<p>通过 ProtoBuf 定义接口和数据类型还挺繁琐的，虽然 gRPC 确实很多亮点的地方，但是我还是选择 Dubbo。</p>
<p>如果要进一步学习的学习的话，这里有参考文档：</p>
<ol>
<li>Github：<a href="https://github.com/grpc/grpc">https://github.com/grpc/grpc</a></li>
<li>官网：<a href="https://grpc.io/">https://grpc.io/</a></li>
</ol>
<h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>
<p>Thrift支持多种不同的编程语言，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等（相比于 gRPC 支持的语言更多 ）。</p>
<ol>
<li>官网：<a href="https://thrift.apache.org/">https://thrift.apache.org/</a></li>
<li>Thrift 简单介绍：<a href="https://www.jianshu.com/p/8f25d057a5a9">https://www.jianshu.com/p/8f25d057a5a9</a></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是因为它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p>
<p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。最重要的是其在国内有很多成功的案例比如当当网、滴滴等等。下图展示了 Dubbo 的生态系统。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704123904515.png" alt="image-20220704123904515"></p>
<p>另外 ，Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704123920049.png" alt="image-20220704123920049"></p>
<p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨语言调用的话，可以考虑一下 Thrift 和 gRPC。</p>
<p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。</p>
<h1 id="03-如何自己实现一个-RPC-框架？"><a href="#03-如何自己实现一个-RPC-框架？" class="headerlink" title="03 如何自己实现一个 RPC 框架？"></a>03 如何自己实现一个 RPC 框架？</h1><p>如果让你自己设计 RPC 框架你会如何设计？</p>
<p>一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。</p>
<p>为了便于小伙伴们理解，我们先从一个最简单的 RPC 框架使用示意图开始。这也是 <a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 目前的架构 。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124159909.png" alt="image-20220704124159909"></p>
<p>从上图我们可以看出：<strong>服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。</strong></p>
<p>作为 RPC 框架领域的佼佼者Dubbo的架构如下图所示,和我们上面画的大体也是差不多的。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124232741.png" alt="image-20220704124232741"></p>
<p>下面我们再来看一个比较完整的 RPC 框架使用示意图如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124257969.png" alt="image-20220704124257969"></p>
<p>参考上面这张图，我们简单说一下设计一个最基本的 RPC 框架的思路或者说实现一个最基本的 RPC 框架需要哪些东西：</p>
<h3 id="1-注册中心"><a href="#1-注册中心" class="headerlink" title="1.注册中心"></a>1.注册中心</h3><p>注册中心首先是要有的。比较推荐使用 Zookeeper 作为注册中心。当然了，你也可以使用 Nacos ，甚至是 Redis。</p>
<p>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</p>
<p>关于 ZooKeeper 的更多介绍可以看我总结的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#_1-%E5%89%8D%E8%A8%80">《ZooKeeper相关概念总结》</a></p>
<p>当然了，如果你想通过文件来存储服务地址的话也是没问题的，不过性能会比较差。</p>
<p><strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<p>我们再来结合 Dubbo 的架构图来理解一下！</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124408934.png" alt="image-20220704124408934"></p>
<p>上述节点简单说明：</p>
<ul>
<li>Provider： 暴露服务的服务提供方</li>
<li>Consumer： 调用远程服务的服务消费方</li>
<li>Registry： 服务注册与发现的注册中心</li>
<li>Monitor： 统计服务的调用次数和调用时间的监控中心</li>
<li>Container： 服务运行容器</li>
</ul>
<p>调用关系说明：</p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="2-网络传输"><a href="#2-网络传输" class="headerlink" title="2.网络传输"></a>2.网络传输</h3><p><strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</strong></p>
<p>网络传输具体实现你可以使用<strong>Socket</strong>（ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p>
<p>你也可以使用同步非阻塞的 I/O 模型<strong>NIO</strong> ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择！</p>
<p>我先简单介绍一下 Netty ，后面的文章中我会详细介绍到。</p>
<ol>
<li><strong>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</strong></li>
<li>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li>
<li>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ol>
<h3 id="3-序列化和反序列化"><a href="#3-序列化和反序列化" class="headerlink" title="3.序列化和反序列化"></a>3.序列化和反序列化</h3><p>要在网络传输数据就要涉及到序列化。为什么需要序列化和反序列化呢？ </p>
<p>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其序列化为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次反序列化。</p>
<p>另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124723073.png" alt="image-20220704124723073"></p>
<p>JDK 自带的序列化，只需实现<code> java.io.Serializable</code>接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。</p>
<p>现在比较常用序列化的有 <strong>hessian、kyro、protostuff</strong> ……。我会在下一篇文章中简单对比一下这些序列化方式。</p>
<h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><p>动态代理也是需要的。很多人可能不清楚为啥需要动态代理？我来简单解释一下吧！</p>
<p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p>
<p>讲完了代理模式，再来说动态代理在 RPC 框架中的作用。</p>
<p>前面第一节的时候，我们就已经提到 ：<strong>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。</strong></p>
<p>怎样才能屏蔽程方法调用的底层细节呢？</p>
<p>答案就是<strong>动态代理。</strong>简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。</p>
<p>相关文章： <a href="https://javaguide.cn/java/basis/proxy.html#_1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式详解：静态代理+JDK/CGLIB 动态代理实战</a></p>
<h3 id="5-负载均衡"><a href="#5-负载均衡" class="headerlink" title="5.负载均衡"></a>5.负载均衡</h3><p>负载均衡也是需要的。为啥？</p>
<p>举个例子：我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p>
<h3 id="6-传输协议"><a href="#6-传输协议" class="headerlink" title="6.传输协议"></a>6.传输协议</h3><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</p>
<p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据。</strong>这有一点像密文传输的感觉。</p>
<p>通常一些标准的 RPC 协议包含下面这些内容：</p>
<ul>
<li>魔数 ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。</li>
<li>序列化器编号 ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。</li>
<li>消息体长度 ： 运行时计算出来。</li>
<li>……</li>
</ul>
<p>如果你想看 guide-rpc-framework 的 RPC 协议设计的话，可以在 Netty 编解码器相关的类中找到。</p>
<h2 id="实现一个最基本的-RPC-框架需要哪些技术？"><a href="#实现一个最基本的-RPC-框架需要哪些技术？" class="headerlink" title="实现一个最基本的 RPC 框架需要哪些技术？"></a>实现一个最基本的 RPC 框架需要哪些技术？</h2><p>刚刚我们已经聊了如何实现一个 RPC 框架，下面我们就来看看实现一个最基本的 RPC 框架需要哪些技术吧！</p>
<p>按照我实现的这一款基于 Netty+Kyro+Zookeeper 实现的 RPC 框架来说的话，你需要下面这些技术支撑：</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ol>
<li>动态代理机制；</li>
<li>序列化机制以及各种序列化框架的对比，比如 hession2、kyro、protostuff；</li>
<li>线程池的使用；</li>
<li>CompletableFuture 的使用；</li>
<li>……</li>
</ol>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ol>
<li>使用 Netty 进行网络传输；</li>
<li>ByteBuf 介绍；</li>
<li>Netty 粘包拆包；</li>
<li>Netty 长连接和心跳机制；</li>
<li>……</li>
</ol>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ol>
<li>基本概念；</li>
<li>数据结构；</li>
<li>如何使用 Netflix 公司开源的 zookeeper 客户端框架 Curator 进行增删改查；</li>
<li>……</li>
</ol>
<h1 id="04-序列化介绍以及序列化协议选择"><a href="#04-序列化介绍以及序列化协议选择" class="headerlink" title="04 序列化介绍以及序列化协议选择"></a>04 序列化介绍以及序列化协议选择</h1><h2 id="序列化和反序列化相关概念"><a href="#序列化和反序列化相关概念" class="headerlink" title="序列化和反序列化相关概念"></a>序列化和反序列化相关概念</h2><p>什么是序列化?什么是反序列化?</p>
<p>如果我们需要持久化Java对象比如将Java对象保存在文件中，或者在网络传输Java对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li>序列化： 将数据结构或对象转换成二进制字节流的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li>
</ul>
<p>对于Java这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而class 对应的是对象类型。</p>
<p>维基百科是如是介绍序列化的：</p>
<blockquote>
<p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote>
<p><strong>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125247053.png" alt="image-20220704125247053"></p>
<p><a href="https://www.corejavaguru.com/java/serialization/interview-questions-1">https://www.corejavaguru.com/java/serialization/interview-questions-1</a></p>
<h2 id="实际开发中有哪些用到序列化和反序列化的场景"><a href="#实际开发中有哪些用到序列化和反序列化的场景" class="headerlink" title="实际开发中有哪些用到序列化和反序列化的场景"></a>实际开发中有哪些用到序列化和反序列化的场景</h2><ol>
<li>对象在进行网络传输（比如远程方法调用RPC的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li>
<li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li>
</ol>
<h2 id="序列化协议对应于TCP-IP-4层模型的哪一层？"><a href="#序列化协议对应于TCP-IP-4层模型的哪一层？" class="headerlink" title="序列化协议对应于TCP/IP 4层模型的哪一层？"></a>序列化协议对应于TCP/IP 4层模型的哪一层？</h2><p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125359908.png" alt="image-20220704125359908"></p>
<p>如上图所示，<u>OSI七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么</u>？</p>
<p>因为，OSI七层协议模型中的应用层、表示层和会话层对应的都是TCP/IP 四层模型中的应用层，所以序列化协议属于TCP/IP协议应用层的一部分。</p>
<h2 id="常见序列化协议对比"><a href="#常见序列化协议对比" class="headerlink" title="常见序列化协议对比"></a>常见序列化协议对比</h2><p>JDK自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kyro、protostuff。</p>
<p>下面提到的都是基于二进制的序列化协议，像 JSON 和 XML这种属于文本类序列化方式。虽然 JSON 和 XML可读性比较好，但是性能较差，一般不会选择。</p>
<h3 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h3><p>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的序列化号</p>
</blockquote>
<p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p>
<ol>
<li><strong>不支持跨语言调用 :</strong> 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p>
<p>guide-rpc-framework  就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 19:29:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        Kryo kryo = <span class="hljs-keyword">new</span> Kryo();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>             Output output = <span class="hljs-keyword">new</span> Output(byteArrayOutputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;Serialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);<br>             Input input = <span class="hljs-keyword">new</span> Input(byteArrayInputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span><br>            Object o = kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;Deserialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>Github 地址：<a href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a> 。</p>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是却可以让 Protobuf 没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf包含序列化格式的定义、各种语言的库以及一个IDL编译器。正常情况下你需要定义proto文件，然后使用IDL编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// protobuf的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <br><span class="hljs-comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span><br>message Person &#123;<br>  <span class="hljs-comment">//string类型字段</span><br>  string name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// int 类型字段</span><br>  int32 age = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>Github地址：<a href="https://github.com/protocolbuffers/protobuf%E3%80%82">https://github.com/protocolbuffers/protobuf。</a></p>
<h3 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h3><p>由于Protobuf的易用性，它的哥哥 Protostuff  诞生了。</p>
<p>protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<p>Gihub地址：<a href="https://github.com/protostuff/protostuff%E3%80%82">https://github.com/protostuff/protostuff。</a></p>
<h3 id="hession"><a href="#hession" class="headerlink" title="hession"></a>hession</h3><p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125745480.png" alt="image-20220704125745480"></p>
<p>dubbo RPC默认启用的序列化方式是 hession2 ,但是，Dubbo对hessian2进行了修改，不过大体结构还是差不多。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Kryo 是专门针对Java语言序列化方式并且性能非常好，如果你的应用是专门针对Java语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/</a>)</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125819700.png" alt="image-20220704125819700"></p>
<p>像Protobuf、 ProtoStuff、hession这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p>
<h2 id="其他推荐阅读"><a href="#其他推荐阅读" class="headerlink" title="其他推荐阅读"></a>其他推荐阅读</h2><ol>
<li>美团技术团队-序列化和反序列化：<a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></li>
<li>在Dubbo中使用高效的Java序列化（Kryo和FST）: <a href="https://dubbo.apache.org/zh-cn/docs/user/serialization.html">https://dubbo.apache.org/zh-cn/docs/user/serialization.html</a></li>
</ol>
<h1 id="05-Socket-网络通信实战"><a href="#05-Socket-网络通信实战" class="headerlink" title="05 Socket 网络通信实战"></a>05 Socket 网络通信实战</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>guide-rpc-framework 的第一版使用的是 JDK 提供了 socket 进行网络编程。为了搞懂具体原理，我们首先要学会使用 Socket 进行网络通信。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704130001809.png" alt="image-20220704130001809"></p>
<h2 id="2-什么是-Socket-套接字"><a href="#2-什么是-Socket-套接字" class="headerlink" title="2. 什么是 Socket(套接字)"></a>2. 什么是 Socket(套接字)</h2><p>Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操作套接字的时候，和我们读写文件很像。套接字是 IP 地址与端口的组合，套接字 Socket=（IP 地址：端口号）。</p>
<p>要通过互联网进行通信，至少需要一对套接字：</p>
<ol>
<li>运行于服务器端的 Server Socket。</li>
<li>运行于客户机端的 Client Socket</li>
</ol>
<p>在 Java 开发中使用 Socket 时会常用到两个类，都在 java.net 包中：</p>
<ol>
<li><code>Socket:</code> 一般用于客户端</li>
<li><code>ServerSocket: </code>用于服务端</li>
</ol>
<h2 id="3-Socket-网络通信过程"><a href="#3-Socket-网络通信过程" class="headerlink" title="3. Socket 网络通信过程"></a>3. Socket 网络通信过程</h2><p>Socket 网络通信过程如下图所示：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704130115513.png" alt="image-20220704130115513"></p>
<p><a href="https://www.javatpoint.com/socket-programming">https://www.javatpoint.com/socket-programming</a></p>
<p>Socket 网络通信过程简单来说分为下面 4 步：</p>
<ol>
<li>建立服务端并且监听客户端请求</li>
<li>客户端请求，服务端和客户端建立连接</li>
<li>两端之间可以传递数据</li>
<li>关闭资源</li>
</ol>
<p>对应到服务端和客户端的话，是下面这样的。</p>
<p><strong>服务器端：</strong></p>
<ol>
<li>创建 ServerSocket 对象并且绑定地址（ip）和端口号(port)：server.bind(new InetSocketAddress(host, port))</li>
<li>通过 accept()方法监听客户端请求</li>
<li>连接建立后，通过输入流读取客户端发送的请求信息</li>
<li>通过输出流向客户端发送响应信息</li>
<li>关闭相关资源</li>
</ol>
<p><strong>客户端：</strong></p>
<ol>
<li>创建Socket 对象并且连接指定的服务器的地址（ip）和端口号(port)：socket.connect(inetSocketAddress)</li>
<li>连接建立后，通过输出流向服务器端发送请求信息</li>
<li>通过输入流获取服务器响应的信息</li>
<li>关闭相关资源</li>
</ol>
<h2 id="4-Socket-网络通信实战"><a href="#4-Socket-网络通信实战" class="headerlink" title="4. Socket 网络通信实战"></a>4. Socket 网络通信实战</h2><h3 id="4-1-服务端"><a href="#4-1-服务端" class="headerlink" title="4.1. 服务端"></a>4.1. 服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServer.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-comment">//1.创建 ServerSocket 对象并且绑定一个端口</span><br>        <span class="hljs-keyword">try</span> (ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(port);) &#123;<br>            Socket socket;<br>            <span class="hljs-comment">//2.通过 accept()方法监听客户端请求</span><br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-keyword">null</span>) &#123;<br>                logger.info(<span class="hljs-string">&quot;client connected&quot;</span>);<br>                <span class="hljs-keyword">try</span> (ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                     ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br>                   <span class="hljs-comment">//3.通过输入流读取客户端发送的请求信息</span><br>                    Message message = (Message) objectInputStream.readObject();<br>                    logger.info(<span class="hljs-string">&quot;server receive message:&quot;</span> + message.getContent());<br>                    message.setContent(<span class="hljs-string">&quot;new content&quot;</span>);<br>                    <span class="hljs-comment">//4.通过输出流向客户端发送响应信息</span><br>                    objectOutputStream.writeObject(message);<br>                    objectOutputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloServer helloServer = <span class="hljs-keyword">new</span> HelloServer();<br>        helloServer.start(<span class="hljs-number">6666</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>ServerSocket</code> 的 <code>accept（）</code> 方法是阻塞方法，也就是说 <code>ServerSocket</code> 在调用 <code>accept（)</code>等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p>
<p>很明显，我上面演示的代码片段有一个很严重的问题：只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。 如下图所示：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704130352083.png" alt="image-20220704130352083"></p>
<p>对应的 Java 代码可能是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>   <span class="hljs-comment">// 创建 socket 连接</span><br>&#125;).start();<br></code></pre></td></tr></table></figure>



<p>但是，这样会导致一个很严重的问题：<strong>资源浪费。</strong></p>
<p>我们知道线程是很宝贵的资源，如果我们为每一次连接都用一个线程处理的话，就会导致线程越来越多，最后达到了极限之后，就无法再创建线程处理请求了。处理的不好的话，甚至可能直接就宕机掉了。</p>
<p>很多人就会问了：那有没有改进的方法呢？</p>
<p>当然有！ 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadFactory threadFactory = Executors.defaultThreadFactory();<br>ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">100</span>), threadFactory);<br>threadPool.execute(() -&gt; &#123;<br>     <span class="hljs-comment">// 创建 socket 连接</span><br> &#125;);<br></code></pre></td></tr></table></figure>



<p><strong>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的 BIO 模型的事实，因此无法从根本上解决问题。</strong></p>
<p><strong>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。</strong> 由于使用同步非阻塞的 I/O 模型 <strong>NIO</strong> 来进行网络编程真的太麻烦了。你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择（前面的章节提到过，后面的章节会详细讲解如何使用 Netty 进行网络编程）！</p>
<h3 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2. 客户端"></a>4.2. 客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 16:56:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloClient.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">send</span><span class="hljs-params">(Message message, String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-comment">//1. 创建Socket对象并且指定服务器的地址和端口号</span><br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(host, port)) &#123;<br>            ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            <span class="hljs-comment">//2.通过输出流向服务器端发送请求信息</span><br>            objectOutputStream.writeObject(message);<br>            <span class="hljs-comment">//3.通过输入流获取服务器响应的信息</span><br>            ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloClient helloClient = <span class="hljs-keyword">new</span> HelloClient();<br>        helloClient.send(<span class="hljs-keyword">new</span> Message(<span class="hljs-string">&quot;content from client&quot;</span>), <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;client receive message:&quot;</span> + message.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>发送的消息实体类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 17:02:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String content;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>首先运行服务端，然后再运行客户端，控制台输出如下：</strong></p>
<p>服务端:</p>
<p>Bash</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">[main] INFO github.javaguide.socket.HelloServer - client connected<br>[main] INFO github.javaguide.socket.HelloServer - server receive message:content from client<br></code></pre></td></tr></table></figure>



<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">client receive message:<span class="hljs-keyword">new</span> content<br></code></pre></td></tr></table></figure>



<p>好的！我们的第一个使用 Socket 进行网络编程的案例已经完成了。</p>
<p>下一篇我们来看看如何使用 Netty 进行网络编程。</p>
<h1 id="06-Netty从入门到网络通信实战"><a href="#06-Netty从入门到网络通信实战" class="headerlink" title="06 Netty从入门到网络通信实战"></a>06 Netty从入门到网络通信实战</h1><h2 id="Netty-介绍"><a href="#Netty-介绍" class="headerlink" title="Netty 介绍"></a>Netty 介绍</h2><p>简单用 3 点概括一下 Netty 吧！</p>
<ol>
<li><strong>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架</strong>，使用它可以快速简单地开发网络应用程序。</li>
<li>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li>
<li>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h2 id="Netty-特点"><a href="#Netty-特点" class="headerlink" title="Netty 特点"></a>Netty 特点</h2><p>根据官网的描述，我们可以总结出下面一些特点：</p>
<ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li>
<li>简单而强大的线程模型。</li>
<li>自带编解码器解决 TCP 粘包/拆包问题。</li>
<li>自带各种协议栈。</li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。</li>
<li>社区活跃</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty 比如我们经常接触的 Dubbo、RocketMQ 等等。</li>
<li>……</li>
</ul>
<ol start="3">
<li>使用 Netty 能做什么？</li>
</ol>
<p>这个应该是老铁们最关心的一个问题了，凭借自己的了解，简单说一下，理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做网络通信 :</p>
<ol>
<li>作为 RPC 框架的网络通信工具 ： 我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务指点的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！</li>
<li>实现一个自己的 HTTP 服务器 ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。</li>
<li>实现一个即时通讯系统 ： 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。</li>
<li>消息推送系统 ：市面上有很多消息推送系统都是基于 Netty 来做的。</li>
<li>……</li>
</ol>
<h2 id="哪些开源项目用到了-Netty？"><a href="#哪些开源项目用到了-Netty？" class="headerlink" title="哪些开源项目用到了 Netty？"></a>哪些开源项目用到了 Netty？</h2><p>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</p>
<p>可以说大量的开源项目都用到了 Netty，所以掌握 Netty 有助于你更好的使用这些开源项目并且让你有能力对其进行二次开发。</p>
<p>实际上还有很多很多优秀的项目用到了 Netty,Netty 官方也做了统计，统计结果在这里：</p>
<p><a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a> 。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704150216533.png" alt="image-20220704150216533"></p>
<h2 id="Netty-使用-kryo-序列化传输对象实战"><a href="#Netty-使用-kryo-序列化传输对象实战" class="headerlink" title="Netty 使用 kryo 序列化传输对象实战"></a>Netty 使用 kryo 序列化传输对象实战</h2><h3 id="传输实体类"><a href="#传输实体类" class="headerlink" title="传输实体类"></a>传输实体类</h3><p>我们首先定义两个对象，这两个对象是客户端与服务端进行交互的实体类。 客户端将 RpcRequest 类型的对象发送到服务端，服务端进行相应的处理之后将得到结果 RpcResponse 对象返回给客户端。</p>
<h4 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h4><p><code>RpcRequest.java </code>：客户端请求实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponse</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> String message;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="初始化客户端"><a href="#初始化客户端" class="headerlink" title="初始化客户端"></a>初始化客户端</h4><p><strong>客户端中主要有一个用于向服务端发送消息的<code>sendMessage()</code>方法，通过这个方法你可以将消息也就是<code>RpcRequest</code> 对象发送到服务端，并且你可以同步获取到服务端返回的结果也就是<code>RpcResponse</code> 对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 20:48:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Bootstrap b;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = host;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化相关资源比如 EventLoopGroup, Bootstrap</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        EventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        b = <span class="hljs-keyword">new</span> Bootstrap();<br>        KryoSerializer kryoSerializer = <span class="hljs-keyword">new</span> KryoSerializer();<br>        b.group(eventLoopGroup)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                <span class="hljs-comment">// 连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span><br>                <span class="hljs-comment">//  如果 15 秒之内没有发送数据给服务端的话，就发送一次心跳请求</span><br>                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         自定义序列化编解码器</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-comment">// RpcResponse -&gt; ByteBuf</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse.class));<br>                        <span class="hljs-comment">// ByteBuf -&gt; RpcRequest</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest.class));<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                    &#125;<br>                &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到服务端</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcRequest 消息体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 服务端返回的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title">sendMessage</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture f = b.connect(host, port).sync();<br>            logger.info(<span class="hljs-string">&quot;client connect  &#123;&#125;&quot;</span>, host + <span class="hljs-string">&quot;:&quot;</span> + port);<br>            Channel futureChannel = f.channel();<br>            logger.info(<span class="hljs-string">&quot;send message&quot;</span>);<br>            <span class="hljs-keyword">if</span> (futureChannel != <span class="hljs-keyword">null</span>) &#123;<br>                futureChannel.writeAndFlush(rpcRequest).addListener(future -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                        logger.info(<span class="hljs-string">&quot;client send message: [&#123;&#125;]&quot;</span>, rpcRequest.toString());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        logger.error(<span class="hljs-string">&quot;Send failed:&quot;</span>, future.cause());<br>                    &#125;<br>                &#125;);<br>               <span class="hljs-comment">//阻塞等待 ，直到Channel关闭</span><br>                futureChannel.closeFuture().sync();<br>               <span class="hljs-comment">// 将服务端返回的数据也就是RpcResponse对象取出</span><br>                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br>                <span class="hljs-keyword">return</span> futureChannel.attr(key).get();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception when connect server:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>sendMessage()</code>方法分析：</p>
<ol>
<li>首先初始化了一个 <code>Bootstrap</code></li>
<li>通过 <code>Bootstrap</code> 对象连接服务端</li>
<li>通过 <code>Channel</code> 向服务端发送消息<code>RpcRequest</code></li>
<li>发送成功后，阻塞等待 ，直到<code>Channel</code>关闭</li>
<li>拿到服务端返回的结果 <code>RpcResponse</code></li>
</ol>
<h4 id="自定义-ChannelHandler-处理服务端消息"><a href="#自定义-ChannelHandler-处理服务端消息" class="headerlink" title="自定义 ChannelHandler 处理服务端消息"></a>自定义 ChannelHandler 处理服务端消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RpcResponse rpcResponse = (RpcResponse) msg;<br>            logger.info(<span class="hljs-string">&quot;client receive msg: [&#123;&#125;]&quot;</span>, rpcResponse.toString());<br>            <span class="hljs-comment">// 声明一个 AttributeKey 对象</span><br>            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br>            <span class="hljs-comment">// 将服务端的返回结果保存到 AttributeMap 上，AttributeMap 可以看作是一个Channel的共享数据源</span><br>            <span class="hljs-comment">// AttributeMap的key是AttributeKey，value是Attribute</span><br>            ctx.channel().attr(key).set(rpcResponse);<br>            ctx.channel().close();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        logger.error(<span class="hljs-string">&quot;client caught exception&quot;</span>, cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NettyClientHandler</code>用于读取服务端发送过来的 <code>RpcResponse</code> 消息对象，并将 <code>RpcResponse</code> 消息对象保存到<code> AttributeMap</code> 上，<code>AttributeMap</code> 可以看作是一个<code>Channel</code>的共享数据源。</p>
<p>这样的话，我们就能通过 channel 和 key 将数据读取出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br><span class="hljs-keyword">return</span> futureChannel.attr(key).get();<br></code></pre></td></tr></table></figure>



<p>这个额外提一下<code> AttributeMap</code> ,<code>AttributeMap</code> 是一个接口，但是类似于 <code>Map</code> 数据结构 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeMap</span> </span>&#123;<br><br>    &lt;T&gt; <span class="hljs-function">Attribute&lt;T&gt; <span class="hljs-title">attr</span><span class="hljs-params">(AttributeKey&lt;T&gt; key)</span></span>;<br><br>    &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttr</span><span class="hljs-params">(AttributeKey&lt;T&gt; key)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>Channel </code>实现了<code> AttributeMap</code> 接口，这样也就表明它存在了<code>AttributeMap</code> 相关的属性。 每个 <code>Channel</code>上的<code>AttributeMap</code>属于共享数据。<code>AttributeMap</code> 的结构，和<code>Map</code>很像，我们可以把 key 看作是<code>AttributeKey</code>，value 看作是<code>Attribute</code>，我们可以根据 <code>AttributeKey</code>找到对应的<code>Attribute</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeMap</span>, <span class="hljs-title">ChannelOutboundInvoker</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="初始化服务端"><a href="#初始化服务端" class="headerlink" title="初始化服务端"></a>初始化服务端</h4><p><code>NettyServer</code> 主要作用就是开启了一个服务端用于接受客户端的请求并处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NettyServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        KryoSerializer kryoSerializer = <span class="hljs-keyword">new</span> KryoSerializer();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span><br>                    .childOption(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">// 是否开启 TCP 底层心跳机制</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcRequest.class));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcResponse.class));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">// 绑定端口，同步等待绑定成功</span><br>            ChannelFuture f = b.bind(port).sync();<br>            <span class="hljs-comment">// 等待服务端监听端口关闭</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception when start server:&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="自定义-ChannelHandler-处理客户端消息"><a href="#自定义-ChannelHandler-处理客户端消息" class="headerlink" title="自定义 ChannelHandler 处理客户端消息"></a>自定义 ChannelHandler 处理客户端消息</h4><p><code>NettyServerHandler</code> 用于接收客户端发送过来的消息并返回结果给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RpcRequest rpcRequest = (RpcRequest) msg;<br>            logger.info(<span class="hljs-string">&quot;server receive msg: [&#123;&#125;] ,times:[&#123;&#125;]&quot;</span>, rpcRequest, atomicInteger.getAndIncrement());<br>            RpcResponse messageFromServer = RpcResponse.builder().message(<span class="hljs-string">&quot;message from server&quot;</span>).build();<br>            ChannelFuture f = ctx.writeAndFlush(messageFromServer);<br>            f.addListener(ChannelFutureListener.CLOSE);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        logger.error(<span class="hljs-string">&quot;server catch exception&quot;</span>,cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><h4 id="自定义编码器"><a href="#自定义编码器" class="headerlink" title="自定义编码器"></a>自定义编码器</h4><p><strong><code>NettyKryoEncoder </code>是我们自定义的编码器。它负责处理”出站”消息，将消息格式转换为字节数组然后写入到字节数据的容器<code>ByteBuf</code>对象中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义编码器。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 网络传输需要通过字节流来实现，ByteBuf 可以看作是 Netty 提供的字节数据的容器，使用它会让我们更加方便地处理字节数据。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月25日 19:43:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyKryoEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Serializer serializer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; genericClass;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将对象转换为字节码然后写入到 ByteBuf 对象中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, Object o, ByteBuf byteBuf)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (genericClass.isInstance(o)) &#123;<br>            <span class="hljs-comment">// 1. 将对象转换为byte</span><br>            <span class="hljs-keyword">byte</span>[] body = serializer.serialize(o);<br>            <span class="hljs-comment">// 2. 读取消息的长度</span><br>            <span class="hljs-keyword">int</span> dataLength = body.length;<br>            <span class="hljs-comment">// 3.写入消息对应的字节数组长度,writerIndex 加 4</span><br>            byteBuf.writeInt(dataLength);<br>            <span class="hljs-comment">//4.将字节数组写入 ByteBuf 对象中</span><br>            byteBuf.writeBytes(body);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义解码器"><a href="#自定义解码器" class="headerlink" title="自定义解码器"></a>自定义解码器</h4><p><code>NettyKryoDecoder</code>是我们自定义的解码器。它负责处理”入站”消息，它会从<code>ByteBuf</code>中读取到业务对象对应的字节序列，然后再将字节序列转换为我们的业务对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义解码器。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月25日 19:42:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyKryoDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Serializer serializer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; genericClass;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Netty传输的消息长度也就是对象序列化后对应的字节数组的大小，存储在 ByteBuf 头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BODY_LENGTH = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解码 ByteBuf 对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 解码器关联的 ChannelHandlerContext 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in  &quot;入站&quot;数据，也就是 ByteBuf 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 解码之后的数据对象需要添加到 out 对象里面</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;<br><br>        <span class="hljs-comment">//1.byteBuf中写入的消息长度所占的字节数已经是4了，所以 byteBuf 的可读字节必须大于 4，</span><br>        <span class="hljs-keyword">if</span> (in.readableBytes() &gt;= BODY_LENGTH) &#123;<br>            <span class="hljs-comment">//2.标记当前readIndex的位置，以便后面重置readIndex 的时候使用</span><br>            in.markReaderIndex();<br>            <span class="hljs-comment">//3.读取消息的长度</span><br>            <span class="hljs-comment">//注意： 消息长度是encode的时候我们自己写入的，参见 NettyKryoEncoder 的encode方法</span><br>            <span class="hljs-keyword">int</span> dataLength = in.readInt();<br>            <span class="hljs-comment">//4.遇到不合理的情况直接 return</span><br>            <span class="hljs-keyword">if</span> (dataLength &lt; <span class="hljs-number">0</span> || in.readableBytes() &lt; <span class="hljs-number">0</span>) &#123;<br>                log.error(<span class="hljs-string">&quot;data length or byteBuf readableBytes is not valid&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//5.如果可读字节数小于消息长度的话，说明是不完整的消息，重置readIndex</span><br>            <span class="hljs-keyword">if</span> (in.readableBytes() &lt; dataLength) &#123;<br>                in.resetReaderIndex();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 6.走到这里说明没什么问题了，可以序列化了</span><br>            <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[dataLength];<br>            in.readBytes(body);<br>            <span class="hljs-comment">// 将bytes数组转换为我们需要的对象</span><br>            Object obj = serializer.deserialize(body, genericClass);<br>            out.add(obj);<br>            log.info(<span class="hljs-string">&quot;successful decode ByteBuf to Object&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="自定义序列化接口"><a href="#自定义序列化接口" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h4><p><code>Serializer</code> 接口主要有两个方法一个用于序列化，一个用户反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 要序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 字节数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">byte</span>[] serialize(Object obj);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 序列化后的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="实现序列化接口"><a href="#实现序列化接口" class="headerlink" title="实现序列化接口"></a>实现序列化接口</h4><p>下面是我自定义 kryo 序列化实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于 Kryo 不是线程安全的。每个线程都应该有自己的 Kryo，Input 和 Output 实例。</span><br><span class="hljs-comment">     * 所以，使用 ThreadLocal 存放 Kryo 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        Kryo kryo = <span class="hljs-keyword">new</span> Kryo();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        kryo.setReferences(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//默认值为true,是否关闭注册行为,关闭之后可能存在序列化问题，一般推荐设置为 true</span><br>        kryo.setRegistrationRequired(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//默认值为false,是否关闭循环引用，可以提高性能，但是一般不推荐设置为 true</span><br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>             Output output = <span class="hljs-keyword">new</span> Output(byteArrayOutputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;序列化失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);<br>             Input input = <span class="hljs-keyword">new</span> Input(byteArrayInputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span><br>            Object o = kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;反序列化失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>自定义序列化异常类<code> SerializeException</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializeException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>启动服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">new</span> NettyServer(<span class="hljs-number">8889</span>).run();<br></code></pre></td></tr></table></figure>

<p>启动客户端并发送 4 次消息给服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">RpcRequest rpcRequest = RpcRequest.builder()<br>  .interfaceName(<span class="hljs-string">&quot;interface&quot;</span>)<br>  .methodName(<span class="hljs-string">&quot;hello&quot;</span>).build();<br>NettyClient nettyClient = <span class="hljs-keyword">new</span> NettyClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8889</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  nettyClient.sendMessage(rpcRequest);<br>&#125;<br>RpcResponse rpcResponse = nettyClient.sendMessage(rpcRequest);<br>System.out.println(rpcResponse.toString());<br></code></pre></td></tr></table></figure>

<p>客户端控制台输出：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704205539793.png" alt="image-20220704205539793"></p>
<p>服务端控制台输出：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704205554308.png" alt="image-20220704205554308"></p>
<h1 id="静态代理-JDK-CGLIB-动态代理实战"><a href="#静态代理-JDK-CGLIB-动态代理实战" class="headerlink" title="静态代理+JDK/CGLIB 动态代理实战"></a>静态代理+JDK/CGLIB 动态代理实战</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704205727047.png" alt="image-20220704205727047"></p>
<p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsProxy</span><span class="hljs-params">(SmsService smsService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.smsService = smsService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method send()&quot;</span>);<br>        smsService.send(message);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method send()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SmsService smsService = <span class="hljs-keyword">new</span> SmsServiceImpl();<br>        SmsProxy smsProxy = <span class="hljs-keyword">new</span> SmsProxy(smsService);<br>        smsProxy.send(<span class="hljs-string">&quot;java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs BASH">before method send()<br>send message:java<br>after method send()<br></code></pre></td></tr></table></figure>



<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理、CGLIB 动态代理</strong>等等。</p>
<p>guide-rpc-framework 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>
<p>另外，虽然 guide-rpc-framework 没有用到 <strong>CGLIB 动态代理 ，我们这里还是简单介绍一下其使用</strong>以及和JDK 动态代理的对比。</p>
<h3 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-function"><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-function"><span class="hljs-params">                                      InvocationHandler h)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalArgumentException</span><br><span class="hljs-function"></span>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li>loader :类加载器，用于加载代理对象。</li>
<li>interfaces : 被代理类实现的一些接口；</li>
<li>h : 实现了 InvocationHandler 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的<code>invoke</code>方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>invoke() </code>方法有下面三个参数：</p>
<ol>
<li><code>proxy</code> :动态生成的代理类</li>
<li><code>method </code>: 与代理类对象调用的方法相对应</li>
<li><code>args </code>: 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。</strong> 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h4 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h4><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) </code>方法创建代理对象；</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>3.定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 11:23:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        Object result = method.invoke(target, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>invoke() </code>方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是<code>invoke()</code>方法，然后 <code>invoke() </code>方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkProxyFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(), <span class="hljs-comment">// 目标类的类加载</span><br>                target.getClass().getInterfaces(),  <span class="hljs-comment">// 代理需要实现的接口，可指定多个</span><br>                <span class="hljs-keyword">new</span> DebugInvocationHandler(target)   <span class="hljs-comment">// 代理对象对应的自定义 InvocationHandler</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>getProxy() </code>：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="hljs-keyword">new</span> SmsServiceImpl());<br>smsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure>



<h3 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和<code> Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor </code>并重写<code> intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodInterceptor</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span></span>&#123;<br>    <span class="hljs-comment">// 拦截被代理类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="hljs-function"><span class="hljs-params">                               MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ol>
<li>obj :被代理的对象（需要增强的对象）</li>
<li>method :被拦截的方法（需要增强的方法）</li>
<li>args :方法入参</li>
<li>methodProxy :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor </code>中的<code> intercept</code> 方法。</p>
<h4 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h4><ol>
<li>定义一个类；</li>
<li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li>
<li>通过 Enhancer 类的 create()创建代理类；</li>
</ol>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliSmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           被代理的对象（需要增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        Object object = methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> DebugMethodInterceptor());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br>aliSmsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure>



<h2 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h2><ol>
<li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h2 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h2><ol>
<li>灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li>JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>
<p>文中涉及到的所有源码，你可以在这里找到：<a href="https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy">https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy</a> 。</p>
<h1 id="ZooKeeper常用命令-Curator使用详解"><a href="#ZooKeeper常用命令-Curator使用详解" class="headerlink" title="ZooKeeper常用命令+ Curator使用详解"></a>ZooKeeper常用命令+ Curator使用详解</h1><p>guide-rpc-framework 使用了 Zookeeper 来存储服务的相关信息 ，并且使用的是 ZooKeeper Java客户端  Curator 来对 ZooKeeper 进行增删改查等操作。</p>
<p>所以，本文就简单介绍一下 ZooKeeper常用命令 以及 Curator 的基本使用。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。</p>
<p>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！</p>
<h2 id="ZooKeeper-安装和使用"><a href="#ZooKeeper-安装和使用" class="headerlink" title="ZooKeeper 安装和使用"></a>ZooKeeper 安装和使用</h2><h3 id="使用Docker-安装-zookeeper"><a href="#使用Docker-安装-zookeeper" class="headerlink" title="使用Docker 安装 zookeeper"></a>使用Docker 安装 zookeeper</h3><p>a.使用 Docker 下载 ZooKeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker pull zookeeper:3.5.8<br></code></pre></td></tr></table></figure>



<p>b.运行 ZooKeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8<br></code></pre></td></tr></table></figure>



<h3 id="连接-ZooKeeper-服务"><a href="#连接-ZooKeeper-服务" class="headerlink" title="连接 ZooKeeper 服务"></a>连接 ZooKeeper 服务</h3><p>a.进入ZooKeeper容器中</p>
<p>先使用 <code>docker ps</code> 查看 ZooKeeper 的 ContainerID，然后使用 <code>docker exec -it ContainerID /bin/bash</code> 命令进入容器中。</p>
<p>b.先进入 bin 目录,然后通过  <code>./zkCli.sh -server 127.0.0.1:2181</code>命令连接ZooKeeper 服务
﻿</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin# cd bin<br></code></pre></td></tr></table></figure>



<p>如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705165251545.png" alt="image-20220705165251545"></p>
<h3 id="常用命令演示"><a href="#常用命令演示" class="headerlink" title="常用命令演示"></a>常用命令演示</h3><h4 id="查看常用命令-help-命令"><a href="#查看常用命令-help-命令" class="headerlink" title="查看常用命令(help 命令)"></a>查看常用命令(help 命令)</h4><p>通过 <code>help</code> 命令查看 ZooKeeper 常用命令</p>
<h4 id="创建节点-create-命令"><a href="#创建节点-create-命令" class="headerlink" title="创建节点(create 命令)"></a>创建节点(create 命令)</h4><p>通过 create 命令在根目录创建了 node1 节点，与它关联的字符串是”node1”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”<br></code></pre></td></tr></table></figure>



<p>通过 create 命令在根目录创建了 node1 节点，与它关联的内容是数字 123</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123<br>Created /node1/node1.1<br></code></pre></td></tr></table></figure>



<h4 id="更新节点数据内容-set-命令"><a href="#更新节点数据内容-set-命令" class="headerlink" title="更新节点数据内容(set 命令)"></a>更新节点数据内容(set 命令)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 11] set /node1 &quot;set node1&quot;<br></code></pre></td></tr></table></figure>



<h4 id="获取节点的数据-get-命令"><a href="#获取节点的数据-get-命令" class="headerlink" title="获取节点的数据(get 命令)"></a>获取节点的数据(get 命令)</h4><p>get 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 <code>set </code>命令已经将节点数据内容改为 “set node1”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">set node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x4b<br>mtime = Sun Jan 20 10:41:10 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 9<br>numChildren = 1<br></code></pre></td></tr></table></figure>



<h4 id="查看某个目录下的子节点-ls-命令"><a href="#查看某个目录下的子节点-ls-命令" class="headerlink" title="查看某个目录下的子节点(ls 命令)"></a>查看某个目录下的子节点(ls 命令)</h4><p>通过 ls 命令查看根目录下的节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 37] ls /<br>[dubbo, ZooKeeper, node1]<br></code></pre></td></tr></table></figure>



<p>通过 ls 命令查看 node1 目录下的节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /node1<br>[node1.1]<br></code></pre></td></tr></table></figure>



<p>ZooKeeper 中的 ls 命令和 linux 命令中的 ls 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）</p>
<h4 id="查看节点状态-stat-命令"><a href="#查看节点状态-stat-命令" class="headerlink" title="查看节点状态(stat 命令)"></a>查看节点状态(stat 命令)</h4><p>通过 <code>stat</code> 命令查看节点状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 10] stat /node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure>



<p>上面显示的一些信息比如 cversion、aclVersion、numChildren 等等，我在上面 “<a href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#_1-%E5%89%8D%E8%A8%80">ZooKeeper 相关概念总结(入门)</a>” 这篇文章中已经介绍到。</p>
<h4 id="查看节点信息和状态-ls2-命令"><a href="#查看节点信息和状态-ls2-命令" class="headerlink" title="查看节点信息和状态(ls2 命令)"></a>查看节点信息和状态(ls2 命令)</h4><p><code>ls2</code> 命令更像是  <code>ls</code> 命令和 <code>stat </code>命令的结合。 ls2 命令返回的信息包括 2 部分：</p>
<ol>
<li>子节点列表</li>
<li>当前节点的 stat 信息。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1<br>[node1.1]<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure>



<h4 id="删除节点-delete-命令"><a href="#删除节点-delete-命令" class="headerlink" title="删除节点(delete 命令)"></a>删除节点(delete 命令)</h4><p>这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1<br></code></pre></td></tr></table></figure>



<p>在后面我会介绍到 Java 客户端 API 的使用以及开源 ZooKeeper 客户端 ZkClient 和 Curator 的使用。</p>
<h2 id="ZooKeeper-Java客户端-Curator简单使用"><a href="#ZooKeeper-Java客户端-Curator简单使用" class="headerlink" title="ZooKeeper Java客户端 Curator简单使用"></a>ZooKeeper Java客户端 Curator简单使用</h2><p>Curator 是Netflix公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705165754955.png" alt="image-20220705165754955"></p>
<p>下面我们就来简单地演示一下 Curator 的使用吧！</p>
<p>Curator4.0+版本对ZooKeeper 3.5.x支持比较好。开始之前，请先将下面的依赖添加进你的项目。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="连接-ZooKeeper-客户端"><a href="#连接-ZooKeeper-客户端" class="headerlink" title="连接 ZooKeeper 客户端"></a>连接 ZooKeeper 客户端</h3><p>通过 CuratorFrameworkFactory 创建 CuratorFramework 对象，然后再调用  CuratorFramework 对象的 start() 方法即可！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE_SLEEP_TIME = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_RETRIES = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span><br>RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(BASE_SLEEP_TIME, MAX_RETRIES);<br>CuratorFramework zkClient = CuratorFrameworkFactory.builder()<br>    <span class="hljs-comment">// the server to connect to (can be a server list)</span><br>    .connectString(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>)<br>    .retryPolicy(retryPolicy)<br>    .build();<br>zkClient.start();<br></code></pre></td></tr></table></figure>



<p>对于一些基本参数的说明：</p>
<ul>
<li><code>baseSleepTimeMs</code>：重试之间等待的初始时间</li>
<li><code>maxRetries</code> ：最大重试次数</li>
<li><code>connectString </code>：要连接的服务器列表</li>
<li><code>retryPolicy </code>：重试策略</li>
</ul>
<h3 id="数据节点的增删改查"><a href="#数据节点的增删改查" class="headerlink" title="数据节点的增删改查"></a>数据节点的增删改查</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>我们在 <a href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#_1-%E5%89%8D%E8%A8%80">ZooKeeper常见概念解读</a>中介绍到，我们通常是将 znode 分为 4 大类：</p>
<ul>
<li>持久（PERSISTENT）节点 ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li>临时（EPHEMERAL）节点 ：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点 只能做叶子节点 ，不能创建子节点。</li>
<li>持久顺序（PERSISTENT_SEQUENTIAL）节点 ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001 、/node1/app0000000002 。</li>
<li>临时顺序（EPHEMERAL_SEQUENTIAL）节点 ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<p>你在使用的 ZooKeeper 的时候，会发现  <code>CreateMode</code> 类中实际有 7种 znode 类型 ，但是用的最多的还是上面介绍的 4 种。</p>
<p>a.创建持久化节点</p>
<p>你可以通过下面两种方式创建持久化的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意:下面的代码会报错，下文说了具体原因</span><br>zkClient.create().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br>zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00002&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>但是，你运行上面的代码会报错，这是因为的父节点<code>node1</code>还未创建。</p>
<p>你可以先创建父节点 <code>node1</code> ，然后再执行上面的代码就不会报错了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.create().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>更推荐的方式是通过下面这行代码， <code>creatingParentsIfNeeded() </code><strong>可以保证父节点不存在的时候自动创建父节点，这是非常有用的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>b.创建临时节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>c.创建节点并指定数据内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容，获取到的是 byte数组</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.checkExists().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//不为null的话，说明节点创建成功</span><br></code></pre></td></tr></table></figure>



<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>a.删除一个子节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.delete().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>b.删除一个节点以及其下的所有子节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>



<h4 id="获取-更新节点数据内容"><a href="#获取-更新节点数据内容" class="headerlink" title="获取/更新节点数据内容"></a>获取/更新节点数据内容</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容</span><br>zkClient.setData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>.getBytes());<span class="hljs-comment">//更新节点数据内容</span><br></code></pre></td></tr></table></figure>



<h4 id="获取某个节点的所有子节点路径"><a href="#获取某个节点的所有子节点路径" class="headerlink" title="获取某个节点的所有子节点路径"></a>获取某个节点的所有子节点路径</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>



<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p><strong>下面简单演示一下如何给某个节点注册子节点监听器 。</strong>注册了监听器之后，这个节点的子节点发生变化比如增加、减少或者更新的时候，你可以自定义回调操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String path = <span class="hljs-string">&quot;/node1&quot;</span>;<br>PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache(zkClient, path, <span class="hljs-keyword">true</span>);<br>PathChildrenCacheListener pathChildrenCacheListener = (curatorFramework, pathChildrenCacheEvent) -&gt; &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;;<br>pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);<br>pathChildrenCache.start();<br></code></pre></td></tr></table></figure>



<p>如果你要获取节点事件类型的话，可以通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">pathChildrenCacheEvent.getType()<br></code></pre></td></tr></table></figure>



<p>一共有下面几种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> Type &#123;<br>    CHILD_ADDED,<span class="hljs-comment">//子节点增加</span><br>    CHILD_UPDATED,<span class="hljs-comment">//子节点更新</span><br>    CHILD_REMOVED,<span class="hljs-comment">//子节点被删除</span><br>    CONNECTION_SUSPENDED,<br>    CONNECTION_RECONNECTED,<br>    CONNECTION_LOST,<br>    INITIALIZED;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Type</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="RPC-框架代码分析之网络传输模块"><a href="#RPC-框架代码分析之网络传输模块" class="headerlink" title="RPC 框架代码分析之网络传输模块"></a>RPC 框架代码分析之网络传输模块</h1><blockquote>
<p>以下提到的 <strong>服务端</strong> 指的是提供服务/方法的一端，<strong>客户端</strong> 指的是调用远程(服务端)服务/方法的一端。</p>
</blockquote>
<p>我们之前在“如何自己实现一个 RPC 框架？”这篇文章中介绍到说：<strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务端。</strong> 这就涉及到了网络传输！网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。你也可以使用同步非阻塞的 I/O 模型 NIO ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择！</p>
<p>guide-rpc-framework 使用了一种基于 Socket，一种基于 Netty 的方式（循序渐进）。</p>
<p>网络传输模块整体结构如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705170846123.png" alt="image-20220705170846123"></p>
<p>一共被分为了 4 个包</p>
<ol>
<li>constants : 存放一些网络传输模块共用的常量</li>
<li>dto : 用于网络传输的类。</li>
<li>handler : 里面只有一个用于处理 rpc 请求的类RpcRequestHandler（根据 rpc 请求调用目标类的目标方法）。</li>
<li>transport : 用户网络传输相关类（真正传输网络请求的地方。提供了 Socket 和 Netty 两种网络传输方式）。</li>
</ol>
<h2 id="网络传输实体类"><a href="#网络传输实体类" class="headerlink" title="网络传输实体类"></a>网络传输实体类</h2><p>网络传输实体类在 dto 包下，主要有两个类。</p>
<p><code>RpcRequest.java</code></p>
<p>rpc 请求实体类。当你要调用远程方法的时候，你需要先传输一个 <code>RpcRequest</code> 给对方，<code>RpcRequest</code> 里面包含了要调用的目标方法和类的名称、参数等数据。</p>
<p>另外，<code>version </code>字段（服务版本）主要是为后续不兼容升级提供可能。<code>group</code> 字段主要用于处理一个接口有多个类实现的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageType rpcMessageType;<br>    <span class="hljs-keyword">private</span> String version;<br>    <span class="hljs-keyword">private</span> String group;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RpcServiceProperties <span class="hljs-title">toRpcProperties</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RpcServiceProperties.builder().serviceName(<span class="hljs-keyword">this</span>.getInterfaceName())<br>                .version(<span class="hljs-keyword">this</span>.getVersion())<br>                .group(<span class="hljs-keyword">this</span>.getGroup()).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>RpcResponse.java</code></p>
<p>既然有了 rpc 请求实体类，那肯定就要有 rpc 响应实体类了。</p>
<p>当服务端通过 <code>RpcRequest</code> 中的相关数据调用到目标服务的目标方法之后，调用结果就通过<code> RpcResponse</code> 返回给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponse</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">715745410605631233L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response code</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response message</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response body</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> T data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">RpcResponse&lt;T&gt; <span class="hljs-title">success</span><span class="hljs-params">(T data, String requestId)</span> </span>&#123;<br>        RpcResponse&lt;T&gt; response = <span class="hljs-keyword">new</span> RpcResponse&lt;&gt;();<br>        response.setCode(RpcResponseCode.SUCCESS.getCode());<br>        response.setMessage(RpcResponseCode.SUCCESS.getMessage());<br>        response.setRequestId(requestId);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != data) &#123;<br>            response.setData(data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">RpcResponse&lt;T&gt; <span class="hljs-title">fail</span><span class="hljs-params">(RpcResponseCode rpcResponseCode)</span> </span>&#123;<br>        RpcResponse&lt;T&gt; response = <span class="hljs-keyword">new</span> RpcResponse&lt;&gt;();<br>        response.setCode(rpcResponseCode.getCode());<br>        response.setMessage(rpcResponseCode.getMessage());<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><p><strong>由于，这部分我提供了一种基于 Socket，一种基于 Netty 的网络传输方式（循序渐进）。</strong></p>
<p>因此，我先定义了一个发送 RPC 请求的顶层接口，然后我们分别使用 Socket 和 Netty 两种方式对这个接口进行实现即可！</p>
<p><code>RpcRequestTransport.java </code>传输请求的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * send RpcRequest。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月29日 13:26:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RpcRequestTransport</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * send rpc request to server and get result</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcRequest message body</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> data from server</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">sendRpcRequest</span><span class="hljs-params">(RpcRequest rpcRequest)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>下面，我们先来看一下比较简单点的使用 Socket 进行网络传输的方式。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>这里的客户端实际就是发送 RPC 请求的一端，可以对照我们之间画的 RPC 调用的原理图来理解。</p>
<p>客户端主要用于发送网络请求到服务端（目标方法所在的服务器）。当我们知道了服务端的地址之后，我们就可以通过 <code>SocketRpcClient</code> 发送 rpc 请求(<code>RpcRequest</code>) 到服务端了(如果我们要找到服务端的地址，涉及到了注册中心相关的知识。下一节会提到。)。</p>
<p>我们直接实现上面定义的 <code>RpcRequestTransport.java</code> 即可。这样的话，通过 Socket 来传输消息的模块就写好了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于 Socket 传输 RpcRequest</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月10日 18:40:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketRpcClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RpcRequestTransport</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscovery serviceDiscovery;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SocketRpcClient</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(&quot;zk&quot;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">sendRpcRequest</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;<br>        <span class="hljs-comment">// build rpc service name by rpcRequest</span><br>        String rpcServiceName = RpcServiceProperties.builder().serviceName(rpcRequest.getInterfaceName())<br>                .group(rpcRequest.getGroup()).version(rpcRequest.getVersion()).build().toRpcServiceName();<br>        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcServiceName);<br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket()) &#123;<br>            socket.connect(inetSocketAddress);<br>            ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            <span class="hljs-comment">// Send data to the server through the output stream</span><br>            objectOutputStream.writeObject(rpcRequest);<br>            ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            <span class="hljs-comment">// Read RpcResponse from the input stream</span><br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;调用服务失败:&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>上面的逻辑很简单，就是对 Socket 发送网络请求这个基础知识的运用。</p>
<p>我这里就不再对上面的代码进行解析了，看不懂的小伙伴自行翻看之前关于 Socket 讲解的章节。</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p><code>SocketRpcServer.java</code></p>
<p>Socket 服务端。用于等待客户端连接。当客户端成功连接之后，就可以发送 rpc 请求(RpcRequest) 到服务端了。然后，服务端拿到 RpcRequest就会去执行对应的方法。执行完对应的方法之后，就把执行得到的结果放在 RpcResponse 中返回给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月10日 08:01:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketRpcServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService threadPool;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceProvider serviceProvider;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SocketRpcServer</span><span class="hljs-params">()</span> </span>&#123;<br>        threadPool = ThreadPoolFactoryUtils.createCustomThreadPoolIfAbsent(<span class="hljs-string">&quot;socket-server-rpc-pool&quot;</span>);<br>        serviceProvider = SingletonFactory.getInstance(ServiceProviderImpl.class);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(Object service)</span> </span>&#123;<br>        serviceProvider.publishService(service);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(Object service, RpcServiceProperties rpcServiceProperties)</span> </span>&#123;<br>        serviceProvider.publishService(service, rpcServiceProperties);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket()) &#123;<br>            String host = InetAddress.getLocalHost().getHostAddress();<br>            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(host, PORT));<br>            CustomShutdownHook.getCustomShutdownHook().clearAll();<br>            Socket socket;<br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-keyword">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;client connected [&#123;&#125;]&quot;</span>, socket.getInetAddress());<br>                threadPool.execute(<span class="hljs-keyword">new</span> SocketRpcRequestHandlerRunnable(socket));<br>            &#125;<br>            threadPool.shutdown();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Netty-1"><a href="#Netty-1" class="headerlink" title="Netty"></a>Netty</h3><p>Netty 这部分的原理也差不多，不过实现代码差别很大。</p>
<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p><code>NettyClient.java</code></p>
<p>Netty 客户端主要提供了:</p>
<ul>
<li><code>doConnect() </code>:用于连接服务端（目标方法所在的服务器）并返回对应的 <code>Channel</code>。当我们知道了服务端的地址之后，我们就可以通过 <code>NettyClient</code> 成功连接服务端了。（有了<code>Channel</code>之后就能发送数据到服务端了）</li>
<li><code>sendRpcRequest() </code>: 用于传输 rpc 请求(<code>RpcRequest</code>) 到服务端。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyRpcClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RpcRequestTransport</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscovery serviceDiscovery;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnprocessedRequests unprocessedRequests;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelProvider channelProvider;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup eventLoopGroup;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">doConnect</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        CompletableFuture&lt;Channel&gt; completableFuture = <span class="hljs-keyword">new</span> CompletableFuture&lt;&gt;();<br>        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                log.info(<span class="hljs-string">&quot;The client has connected [&#123;&#125;] successful!&quot;</span>, inetSocketAddress.toString());<br>                completableFuture.complete(future.channel());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> completableFuture.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">sendRpcRequest</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;<br>        <span class="hljs-comment">// build return value</span><br>        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="hljs-keyword">new</span> CompletableFuture&lt;&gt;();<br>        <span class="hljs-comment">// build rpc service name by rpcRequest</span><br>        String rpcServiceName = rpcRequest.toRpcProperties().toRpcServiceName();<br>        <span class="hljs-comment">// get server address</span><br>        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcServiceName);<br>        <span class="hljs-comment">// get  server address related channel</span><br>        Channel channel = getChannel(inetSocketAddress);<br>        <span class="hljs-keyword">if</span> (channel.isActive()) &#123;<br>            <span class="hljs-comment">// put unprocessed request</span><br>            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);<br>            RpcMessage rpcMessage = <span class="hljs-keyword">new</span> RpcMessage();<br>            rpcMessage.setData(rpcRequest);<br>            rpcMessage.setCodec(SerializationTypeEnum.PROTOSTUFF.getCode());<br>            rpcMessage.setCompress(CompressTypeEnum.GZIP.getCode());<br>            rpcMessage.setMessageType(RpcConstants.REQUEST_TYPE);<br>            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.info(<span class="hljs-string">&quot;client send message: [&#123;&#125;]&quot;</span>, rpcMessage);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    future.channel().close();<br>                    resultFuture.completeExceptionally(future.cause());<br>                    log.error(<span class="hljs-string">&quot;Send failed:&quot;</span>, future.cause());<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> resultFuture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>UnprocessedRequests.java</code></p>
<p>用于存放未被服务端处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnprocessedRequests</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;&gt; UNPROCESSED_RESPONSE_FUTURES = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String requestId, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future)</span> </span>&#123;<br>        UNPROCESSED_RESPONSE_FUTURES.put(requestId, future);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(RpcResponse&lt;Object&gt; rpcResponse)</span> </span>&#123;<br>        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future = UNPROCESSED_RESPONSE_FUTURES.remove(rpcResponse.getRequestId());<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != future) &#123;<br>            future.complete(rpcResponse);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>NettyClientHandler</code></p>
<p>自定义客户端<code> ChannelHandler</code> 用于处理服务器发送的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnprocessedRequests unprocessedRequests;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelProvider channelProvider;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyClientHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);<br>        <span class="hljs-keyword">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取从服务端返回的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;client receive msg: [&#123;&#125;]&quot;</span>, msg);<br>            <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> RpcResponse) &#123;<br>                RpcResponse&lt;Object&gt; rpcResponse = (RpcResponse&lt;Object&gt;) msg;<br>                unprocessedRequests.complete(rpcResponse);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Netty 心跳机制相关。保证客户端和服务端的连接不被断掉，避免重连。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//省略部分代码</span><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>从代码中，可以看出当 rpc 请求被成功处理（客户端收到服务端的执行结果）之后，我们调用了 <code>unprocessedRequests.complete(rpcResponse)</code> 方法，这样的话，你只需要通过下面的方式就能成功接收到服务端返回的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);<br>rpcResponse = completableFuture.get();<br></code></pre></td></tr></table></figure>

<p><code>ChannelProvider.java</code></p>
<p>用于存放<code> Channel</code>（<code>Channel</code>用于在服务端和客户端之间传输数据）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelProvider</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Channel&gt; channelMap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChannelProvider</span><span class="hljs-params">()</span> </span>&#123;<br>        channelMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">get</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        String key = inetSocketAddress.toString();<br>        <span class="hljs-comment">// determine if there is a connection for the corresponding address</span><br>        <span class="hljs-keyword">if</span> (channelMap.containsKey(key)) &#123;<br>            Channel channel = channelMap.get(key);<br>            <span class="hljs-comment">// if so, determine if the connection is available, and if so, get it directly</span><br>            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span> &amp;&amp; channel.isActive()) &#123;<br>                <span class="hljs-keyword">return</span> channel;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channelMap.remove(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(InetSocketAddress inetSocketAddress, Channel channel)</span> </span>&#123;<br>        String key = inetSocketAddress.toString();<br>        channelMap.put(key, channel);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        String key = inetSocketAddress.toString();<br>        channelMap.remove(key);<br>        log.info(<span class="hljs-string">&quot;Channel map size :[&#123;&#125;]&quot;</span>, channelMap.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="服务端相关"><a href="#服务端相关" class="headerlink" title="服务端相关"></a>服务端相关</h4><p><code>NettyRpcServer.java</code></p>
<p>Netty 服务端。并监听客户端的连接。另外，还提供了两个用户手动注册服务的方法（<em>还可以通过注解<code>RpcService</code>注册服务，这个后面也会介绍到</em>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyRpcServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9998</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceProvider serviceProvider = SingletonFactory.getInstance(ServiceProviderImpl.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(Object service, RpcServiceProperties rpcServiceProperties)</span> </span>&#123;<br>        serviceProvider.publishService(service, rpcServiceProperties);<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        CustomShutdownHook.getCustomShutdownHook().clearAll();<br>        String host = InetAddress.getLocalHost().getHostAddress();<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        DefaultEventExecutorGroup serviceHandlerGroup = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<br>                RuntimeUtil.cpus() * <span class="hljs-number">2</span>,<br>                ThreadPoolFactoryUtils.createThreadFactory(<span class="hljs-string">&quot;service-handler-group&quot;</span>, <span class="hljs-keyword">false</span>)<br>        );<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span><br>                    .childOption(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">// 是否开启 TCP 底层心跳机制</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    <span class="hljs-comment">// 当客户端第一次进行请求的时候才会进行初始化</span><br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            <span class="hljs-comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span><br>                            ChannelPipeline p = ch.pipeline();<br>                            p.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS));<br>                            p.addLast(<span class="hljs-keyword">new</span> RpcMessageEncoder());<br>                            p.addLast(<span class="hljs-keyword">new</span> RpcMessageDecoder());<br>                            p.addLast(serviceHandlerGroup, <span class="hljs-keyword">new</span> NettyRpcServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">// 绑定端口，同步等待绑定成功</span><br>            ChannelFuture f = b.bind(host, PORT).sync();<br>            <span class="hljs-comment">// 等待服务端监听端口关闭</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;occur exception when start server:&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.error(<span class="hljs-string">&quot;shutdown bossGroup and workerGroup&quot;</span>);<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>            serviceHandlerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>NettyServerHandler.java</code></p>
<p>自定义服务端 <code>ChannelHandler</code> 用于处理客户端发送的数据。</p>
<p>当客户端发的 rpc 请求(<code>RpcRequest</code>) 来了之后，服务端就会处理 <code>rpc</code> 请求(<code>RpcRequest</code>) ，处理完之后就把得到 rpc 相应(<code>RpcResponse</code>)传输给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RpcRequestHandler rpcRequestHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyServerHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);<br>    &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取从客户端消息，然后调用目标服务的目标方法并返回给客户端。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>      <span class="hljs-comment">// 省略部分代码</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// Netty 心跳机制相关。保证客户端和服务端的连接不被断掉，避免重连。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>     <span class="hljs-comment">// 省略部分代码</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>在《如何自己实现一个 RPC 框架》这一节，我们就提到了传输协议的作用。</p>
<p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二级制数据之后，就可以正确的解析出我们需要的数据。这有一点像密文传输的感觉。</strong></p>
<p>以下便是我们设计的传输协议（编解码器这里会用到！！！）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">*   <span class="hljs-number">0</span>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>        <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span>     <span class="hljs-number">8</span>         <span class="hljs-number">9</span>          <span class="hljs-number">10</span>      <span class="hljs-number">11</span>     <span class="hljs-number">12</span>  <span class="hljs-number">13</span>  <span class="hljs-number">14</span>   <span class="hljs-number">15</span> <span class="hljs-number">16</span><br>*   +-----+-----+-----+-----+--------+----+----+----+------+-----------+-------+----- --+-----+-----+-------+<br>*   |   magic   code        |version | full length         | messageType| codec|compress|    RequestId       |<br>*   +-----------------------+--------+---------------------+-----------+-----------+-----------+------------+<br>*   |                                                                                                       |<br>*   |                                         body                                                          |<br>*   |                                                                                                       |<br>*   |                                        ... ...                                                        |<br>*   +-------------------------------------------------------------------------------------------------------+<br>* <span class="hljs-number">4</span>B  magic code（魔法数）   <span class="hljs-number">1</span>B version（版本）   <span class="hljs-number">4</span>B full length（消息长度）    <span class="hljs-number">1</span>B messageType（消息类型）<br>* <span class="hljs-number">1</span>B compress（压缩类型） <span class="hljs-number">1</span>B codec（序列化类型）    <span class="hljs-number">4</span>B  requestId（请求的Id）<br></code></pre></td></tr></table></figure>



<ul>
<li>魔法数 ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。</li>
<li>序列化器类型 ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。</li>
<li>消息长度 ： 运行时计算出来。</li>
<li>……</li>
</ul>
<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器这里主要用到了 Kryo 序列化和反序列化以及 Netty 网络传输字节容器 ByteBuf 相关的知识。</p>
<p>编解码器的作用主要是让我们在 Netty 进行网络传输所用的对象类型 ByteBuf 与 我们代码层面需要的业务对象之间转换。这部分的代码还是比较多的，小伙伴们可以自己阅读以下，整体逻辑还是比较简单的。</p>
<p><strong>一定要先搞懂传输协议之后再去看这部分代码。</strong></p>
<p><code>RpcMessageDecoder.java</code></p>
<p>自定义解码器。负责处理”入站”消息，将 ByteBuf 消息格式的对象转换为我们需要的业务对象。</p>
<blockquote>
<p>网络传输需要通过字节流来实现，ByteBuf 可以看作是 Netty 提供的字节数据的容器，使用它会让我们更加方便地处理字节数据。</p>
</blockquote>
<p><code>RpcMessageEncoder.java</code></p>
<p>自定义编码器。负责处理”出站”消息，将消息格式转换字节数组然后写入到字节数据的容器 ByteBuf 对象中。</p>
<h1 id="RPC-框架代码分析之注册中心模块"><a href="#RPC-框架代码分析之注册中心模块" class="headerlink" title="RPC 框架代码分析之注册中心模块"></a>RPC 框架代码分析之注册中心模块</h1><p>我们之前在“如何自己实现一个 RPC 框架？”这篇文章中介绍到说：<strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<p>简单来说注册中心就像是一个中转站，提供的作用就是根据调用的服务名称找到远程服务的地址（数据保存服务）。</p>
<p>注册中心模块整体结构如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705172541611.png" alt="image-20220705172541611"></p>
<p>我们定义了两个接口<code> ServiceDiscovery.java</code> 和 <code>ServiceRegistry.java</code>，这两个接口分别定义了服务发现和服务注册行为。</p>
<p><code>ServiceRegistry.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务注册</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 08:39:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceRegistry</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册服务到注册中心</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcServiceName    完整的服务名称（class name+group+version）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inetSocketAddress 远程服务地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(String rpcServiceName, InetSocketAddress inetSocketAddress)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>ServiceDiscovery.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务发现</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年06月01日 15:16:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceDiscovery</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 rpcServiceName 获取远程服务地址</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcServiceName 完整的服务名称（class name+group+version）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 远程服务地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">InetSocketAddress <span class="hljs-title">lookupService</span><span class="hljs-params">(String rpcServiceName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>接下来，我们使用 ZooKeeper 作为注册中心的实现方式，并实现了这两个接口。</p>
<p><code>ZkServiceRegistry.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务注册（基于zookeeper实现）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkServiceRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceRegistry</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(String rpcServiceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        String servicePath = CuratorUtils.ZK_REGISTER_ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + rpcServiceName + inetSocketAddress.toString();<br>        CuratorFramework zkClient = CuratorUtils.getZkClient();<br>        CuratorUtils.createPersistentNode(zkClient, servicePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>当我们的服务被注册进 zookeeper 的时候，我们将完整的服务名称 rpcServiceName （class name+group+version）作为根节点 ，子节点是对应的服务地址（ip+端口号）。</p>
<blockquote>
<ul>
<li>class name : 服务接口名也就是类名比如：github.javaguide.HelloService。</li>
<li>version :（服务版本）主要是为后续不兼容升级提供可能</li>
<li>group :主要用于处理一个接口有多个类实现的情况。</li>
</ul>
</blockquote>
<p>一个根节点（rpcServiceName）可能会对应多个服务地址（相同服务被部署多份的情况）。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220713161511054.png" alt="image-20220713161511054"></p>
<p>如果我们要获得某个服务对应的地址的话，就直接根据完整的服务名称来获取到其下的所有子节点，然后通过具体的负载均衡策略取出一个就可以了。相关代码如下在 <code>ZkServiceDiscovery.java</code>中已经给出。</p>
<p><code>ZkServiceDiscovery.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务发现（基于zookeeper实现）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkServiceDiscovery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceDiscovery</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadBalance loadBalance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkServiceDiscovery</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadBalance = <span class="hljs-keyword">new</span> RandomLoadBalance();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title">lookupService</span><span class="hljs-params">(String rpcServiceName)</span> </span>&#123;<br>        CuratorFramework zkClient = CuratorUtils.getZkClient();<br>        List&lt;String&gt; serviceUrlList = CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);<br>        <span class="hljs-keyword">if</span> (serviceUrlList.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(RpcErrorMessage.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);<br>        &#125;<br>        <span class="hljs-comment">// load balancing</span><br>        String targetServiceUrl = loadBalance.selectServiceAddress(serviceUrlList);<br>        log.info(<span class="hljs-string">&quot;Successfully found the service address:[&#123;&#125;]&quot;</span>, targetServiceUrl);<br>        String[] socketAddressArray = targetServiceUrl.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        String host = socketAddressArray[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> port = Integer.parseInt(socketAddressArray[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InetSocketAddress(host, port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们根据完整的服务名称便可以将对应的服务地址查出来， 查出来的服务地址可能并不止一个。</p>
<p>所以，我们可以通过对应的负载均衡策略来选择出一个服务地址。</p>
<p><code>CuratorUtils.java</code></p>
<p>另外，我们还自定义了一个 ZooKeeper Java 客户端 Curtor 的工具类 CuratorUtils.java 。关于这个工具类，这里就不再提了。</p>
<p>在《08 Zookeeper 常用命令+ Curtor 使用详解》中已经介绍的非常详细了。</p>
<h1 id="RPC-框架代码分析之其他模块"><a href="#RPC-框架代码分析之其他模块" class="headerlink" title="RPC 框架代码分析之其他模块"></a>RPC 框架代码分析之其他模块</h1><h2 id="动态代理屏蔽网络传输细节"><a href="#动态代理屏蔽网络传输细节" class="headerlink" title="动态代理屏蔽网络传输细节"></a>动态代理屏蔽网络传输细节</h2><p>我们在前面的章节讲到过我们需要用到动态代理来屏蔽复杂的网络传输细节。对应的代码:<code> RpcClientProxy.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcClientProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<p>当我们去调用一个远程的方法的时候，实际上是通过代理对象调用的。</p>
<p>获取代理对象的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>网络传输细节都被封装在了  <code>invoke()  </code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> </span>&#123;<br>    log.info(<span class="hljs-string">&quot;invoked method: [&#123;&#125;]&quot;</span>, method.getName());<br>    RpcRequest rpcRequest = RpcRequest.builder().methodName(method.getName())<br>            .parameters(args)<br>            .interfaceName(method.getDeclaringClass().getName())<br>            .paramTypes(method.getParameterTypes())<br>            .requestId(UUID.randomUUID().toString())<br>            .group(rpcServiceProperties.getGroup())<br>            .version(rpcServiceProperties.getVersion())<br>            .build();<br>    RpcResponse&lt;Object&gt; rpcResponse = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (rpcRequestTransport <span class="hljs-keyword">instanceof</span> NettyRpcClient) &#123;<br>        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);<br>        rpcResponse = completableFuture.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rpcRequestTransport <span class="hljs-keyword">instanceof</span> SocketRpcClient) &#123;<br>        rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.check(rpcResponse, rpcRequest);<br>    <span class="hljs-keyword">return</span> rpcResponse.getData();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>通过注解注册/消费服务</p>
<p>我们这里借用了 Spring 容器相关的功能。核心代码都放在了 ： <code>src/main/java/github/javaguide/spring</code>  包下面。</p>
<p>我们定义两个注解： </p>
<ul>
<li>RcpService  ：注册服务</li>
<li>RpcReference  ：消费服务</li>
</ul>
<p><code>RcpService.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RpcService &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service version, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">version</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service group, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">group</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>RpcReference.java </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RpcReference &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service version, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">version</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service group, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">group</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>﻿</p>
<p>简单说一下原理。</p>
<p>我们实现需要 <code>BeanPostProcessor</code> 接口并重写 <code>postProcessBeforeInitialization()</code>方法和 <code>postProcessAfterInitialization() </code>方法。</p>
<p>Spring bean 在实例化之前会调用<code> postProcessBeforeInitialization()</code>方法，在 Spring bean 实例化之后会调用 <code>postProcessAfterInitialization()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>




<p>被我们使用 <code>RpcService</code>和<code>RpcReference</code> 注解的类都算是 Spring Bean。 </p>
<ul>
<li>我们可以在<code>postProcessBeforeInitialization()</code>方法中去判断类上是否有<code>RpcService</code> 注解。如果有的话，就取出 <code>group </code>和<code> version</code> 的值。然后，再调用<code> ServiceProvider</code> 的 <code>publishService() </code>方法发布服务即可！</li>
<li>我们可以在<code>postProcessAfterInitialization()</code>方法中遍历类的属性上是否有 <code>RpcReference</code> 注解。如果有的话，我们就通过反射将这个属性赋值即可！</li>
</ul>
<h1 id="（优化）使用CompletableFuture优化接受服务提供端返回结果"><a href="#（优化）使用CompletableFuture优化接受服务提供端返回结果" class="headerlink" title="（优化）使用CompletableFuture优化接受服务提供端返回结果"></a>（优化）使用CompletableFuture优化接受服务提供端返回结果</h1><h2 id="使用-AttributeMap-接受服务端返回结果"><a href="#使用-AttributeMap-接受服务端返回结果" class="headerlink" title="使用 AttributeMap 接受服务端返回结果"></a>使用 AttributeMap 接受服务端返回结果</h2><p>最开始的时候是通过 <code>AttributeMap</code> 绑定到Channel上实现的，相关代码如下：</p>
<p><code>NettyClientTransport.java</code>（用来发送 RpcRequest 请求）</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174156055.png" alt="image-20220705174156055"></p>
<p><code>NettyClientHandler.java</code> （自定义客户端 ChannelHandler 来处理服务端发过来的数据）</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174227753.png" alt="image-20220705174227753"></p>
<p>这种是实现的缺点是不清晰，而且你每次都要调用<code>channel.closeFuture().sync();</code> 阻塞来手动等待请求返回。</p>
<h2 id="使用-CompletableFuture-进行优化"><a href="#使用-CompletableFuture-进行优化" class="headerlink" title="使用 CompletableFuture 进行优化"></a>使用 CompletableFuture 进行优化</h2><p>我使用 <code>CompletableFuture</code> 包装返回结果，对代码进行了重构，重要部分的代码如下：</p>
<p><code>NettyClientTransport.java</code>（用来发送 RpcRequest 请求）</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174215554.png" alt="image-20220705174215554"></p>
<p><code>NettyClientHandler.java</code> （自定义客户端 ChannelHandler 来处理服务端发过来的数据）</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174522589.png" alt="image-20220705174522589"></p>
<p><code>UnprocessedRequests.java </code>存放了未处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174536550.png" alt="image-20220705174536550"></p>
<p>现在，在你只需要通过下面的方式就能成功接收到客户端返回的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);<br>rpcResponse = completableFuture.get();<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>springcloud</title>
    <url>/2022/07/07/springcloud/</url>
    <content><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185642516.png" alt="image-20220428185642516"></p>
<p><strong>优点：</strong>架构简单，部署成本低</p>
<p><strong>缺点：</strong>耦合度高（维护困难、升级困难）</p>
<h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185707634.png" alt="image-20220428185707634"></p>
<p><strong>优点：</strong>降低服务耦合，有利于服务升级和拓展</p>
<p><strong>缺点：</strong>服务调用关系错综复杂</p>
<p>分布式架构虽然降低了服务耦合，但是服务拆分时也有<strong>很多问题需要思考</strong>：</p>
<ul>
<li>服务拆分的粒度如何界定？</li>
<li>服务之间如何调用？</li>
<li>服务的调用关系如何管理？</li>
</ul>
<p><strong>人们需要制定一套行之有效的标准来约束分布式架构。</strong></p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185738700.png" alt="image-20220428185738700"></p>
<p>微服务的上述特性<strong>其实是在给分布式架构制定一个标准</strong>，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p>
<p><strong>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</strong></p>
<p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p>
<p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>
<p>其中常见的组件包括：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185807546.png" alt="image-20220428185807546"></p>
<p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185819931.png" alt="image-20220428185819931"></p>
<h2 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h2><p>需要学习的微服务知识内容</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185933999.png" alt="image-20220428185933999"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185914756.png" alt="image-20220428185914756"></p>
<h2 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428190002468.png" alt="image-20220428190002468"></p>
<h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><p><strong>服务拆分注意事项</strong></p>
<p>单一职责：不同微服务，不要重复开发相同业务</p>
<p>数据独立：不要访问其它微服务的数据库</p>
<p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090745.png"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090745.png" alt="img"></a></p>
<p>cloud-demo：父工程，管理依赖</p>
<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
</ul>
<p>要求：</p>
<ul>
<li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li>
<li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li>
<li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li>
</ul>
<p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090750.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090750.png" alt="img"></a></p>
<p>启动完成后，访问 <a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>正如上面的服务拆分要求中所提到，</p>
<blockquote>
<p>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</p>
</blockquote>
<p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090814.png" alt="img"></p>
<p>发送请求，自动序列化为 Java 对象。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090846.png" alt="img"></p>
<p>启动完成后，访问：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090909.png" alt="img"></p>
<p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p>
<h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>最广为人知的注册中心就是 Eureka，其结构如下：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090919.png"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090919.png" alt="img"></a></p>
<p><strong>order-service 如何得知 user-service 实例地址？</strong></p>
<ul>
<li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li>
<li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li>
</ul>
<p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p>
<ul>
<li>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</li>
</ul>
<p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p>
<ul>
<li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li>
<li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service 拉取服务时，，可以拉取到最新的信息，将故障实例排除了</li>
</ul>
<h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p><strong>搭建 eureka-server</strong></p>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>编写启动类</strong></p>
<p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xn2001.eureka;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>编写配置文件</strong></p>
<p>编写一个 application.yml 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p>
<p>启动完成后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote>
<p>将 user-service、order-service 都注册到 eureka</p>
</blockquote>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>client</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在启动类上添加注解：<code>@EnableEurekaClient</code></p>
<p>在 application.yml 文件，添加下面的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>      <span class="hljs-comment">#name：orderservice</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http:127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure>

<p>3个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p>
<p>[<img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090958.png" alt="img"></p>
<p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901091005.png" alt="img"></p>
<p>4个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p>
<h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h2><blockquote>
<p>在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</p>
</blockquote>
<p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p>
<p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901091216.png" alt="img"></p>
<p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。</p>
<h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p>
<p><strong>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204718544.png" alt="image-20220502204718544"></p>
<h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p>
<p>我们进行源码跟踪：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204740323.png" alt="image-20220502204740323"></p>
<p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>
<ul>
<li><code>request.getURI()</code>：获取请求uri，即 <a href="http://user-service/user/8">http://user-service/user/8</a></li>
<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id <code>user-service</code></li>
<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li>
</ul>
<p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p>
<p>继续跟入 <code>execute()</code> 方法：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204800776.png" alt="image-20220502204800776">ps://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901091330.png)</p>
<ul>
<li><code>getLoadBalancer(serviceId)</code>：根据服务id获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务 id 去 eureka 中获取服务列表。</li>
<li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li>
</ul>
<p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204807870.png" alt="image-20220502204807870">210901091345.png)</p>
<p>我们继续跟入：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204829178.png" alt="image-20220502204829178"></p>
<p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204841773.png" alt="image-20220502204841773"></p>
<p>我们看看这个 <code>rule</code> 是谁：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204854794.png" alt="image-20220502204854794"></p>
<p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204904472.png" alt="image-20220502204904472"></p>
<p>负载均衡默认使用了轮训算法，当然我们也可以自定义。</p>
<h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的 <code>RestTemplate</code> 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li>
<li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li>
<li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li>
<li>eureka 返回列表，localhost:8081、localhost:8082</li>
<li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li>
<li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205148614.png" alt="image-20220502205148614"></p>
<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>内置负载均衡规则类</strong></th>
<th align="left"><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">RoundRobinRule</td>
<td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td align="left"><strong>ZoneAvoidanceRule</strong></td>
<td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td align="left">BestAvailableRule</td>
<td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td align="left">RandomRule</td>
<td align="left">随机选择一个可用的服务器。</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td align="left">重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p>
<h2 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p>
<p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205114259.png" alt="image-20220502205114259"></p>
<p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：一般用默认的负载均衡规则，不做修改。</p>
<h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205135263.png" alt="image-20220502205135263"></p>
<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 项目启动时直接去拉取userservice的集群，多个用&quot;,&quot;隔开</span><br></code></pre></td></tr></table></figure>

<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，在国外也有大量的使用。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205234666.png" alt="image-20220502205234666"></p>
<p>解压启动 Nacos，详细请看 <a href="https://www.xn2001.com/archives/661.html">Nacos安装指南</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">startup</span><span class="hljs-selector-class">.cmd</span> <span class="hljs-selector-tag">-m</span> <span class="hljs-selector-tag">standalone</span><br></code></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p>
<h2 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。</p>
<p><strong>引入依赖</strong></p>
<p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>配置nacos地址</strong></p>
<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址： </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure>

<p><strong>还需要配置服务名称</strong></p>
<p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214602344.png" alt="image-20220502214602344"></p>
<p>浏览器访问：<a href="http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p>
<h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214517868.png" alt="image-20220502214517868"></p>
<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p>
<h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>接下来我们给 user-service <strong>配置集群</strong></p>
<p>修改 user-service 的 application.yml 文件，添加集群配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称 HZ杭州</span><br></code></pre></td></tr></table></figure>

<p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<br></code></pre></td></tr></table></figure>

<p>查看 nacos 控制台：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214544922.png" alt="image-20220502214544922"></p>
<h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">iRule</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//默认为轮询规则，这里自定义为随机规则</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRule();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment">#负载均衡规则 </span><br></code></pre></td></tr></table></figure>

<p>然后，再对 orderservice 配置集群。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure>

<p>现在我启动了四个服务，分别是：</p>
<ul>
<li>orderservice - HZ</li>
<li>userservice - HZ</li>
<li>userservice1 - HZ</li>
<li>userservice2 - SH</li>
</ul>
<p>访问地址：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p>
<p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p>
<p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214629993.png" alt="image-20220502214629993"></p>
<h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p>
<p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214643631.png" alt="image-20220502214643631"></p>
<p>在弹出的编辑窗口，修改权重</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214655845.png" alt="image-20220502214655845"></p>
<p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到 0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p>
<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p>
<ul>
<li>Nacos 中可以有多个 namespace</li>
<li>namespace 下可以有 group、service 等</li>
<li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214708111.png" alt="image-20220502214708111"></p>
<h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214721702.png" alt="image-20220502214721702"></p>
<p>我们可以点击页面新增按钮，添加一个 namespace：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214733491.png" alt="image-20220502214733491"></p>
<p>然后，填写表单：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214750406.png" alt="image-20220502214750406"></p>
<p>就能在页面看到一个新的 namespace：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214801507.png" alt="image-20220502214801507"></p>
<h3 id="配置namespace"><a href="#配置namespace" class="headerlink" title="配置namespace"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p>
<p>例如，修改 order-service 的 application.yml 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间ID</span><br></code></pre></td></tr></table></figure>

<p>重启 order-service 后，访问控制台。</p>
<p><strong>public</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214821277.png" alt="image-20220502214821277"></p>
<p><strong>dev</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214833255.png" alt="image-20220502214833255"></p>
<p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214845028.png" alt="image-20220502214845028"></p>
<h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p>
<ul>
<li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure>

<p>另外，Nacos 集群<strong>默认采用AP方式(可用性)**，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p>
<h1 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200723770.png" alt="image-20220503200723770"></p>
<p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p>
<h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200736172.png" alt="image-20220503200736172"></p>
<p>然后在弹出的表单中，填写配置信息：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200754869.png" alt="image-20220503200754869"></p>
<p><strong>注意：</strong>项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。这里的后缀名最好写<code>.yaml</code>。</p>
<h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200813407.png" alt="image-20220503200813407"></p>
<p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200824188.png" alt="image-20220503200824188"></p>
<p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p>
<p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200923259.png" alt="image-20220503200923259"></p>
<p><strong>引入 nacos-config 依赖</strong></p>
<p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>添加 bootstrap.yml</strong></p>
<p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure>

<p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p>
<p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201041580.png" alt="image-20220503201041580"></p>
<p>使用代码来验证是否拉取成功</p>
<p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String dateformat;<br><br><span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">now</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//格式化时间</span><br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200944583.png" alt="image-20220503200944583"></p>
<p>启动服务后，访问：<a href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201114911.png" alt="image-20220503201114911"></p>
<h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p>
<p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p>
<h3 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201128313.png" alt="image-20220503201128313"></p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。</p>
<p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatternProperties</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String dateformat;<br>&#125;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br><span class="hljs-meta">@GetMapping(&quot;now2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">now2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//格式化时间</span><br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p>
<ul>
<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>
<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li>
</ul>
<p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p>
<p><strong>添加一个环境共享配置</strong></p>
<p>我们在 nacos 中添加一个 userservice.yaml 文件：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201156476.png" alt="image-20220503201156476"></p>
<p><strong>在 user-service 中读取共享配置</strong></p>
<p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092314.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092314.png" alt="img"></a></p>
<p>在 user-service 服务中，修改 UserController，添加一个方法：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092331.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092331.png" alt="img"></a></p>
<p><strong>运行两个 UserApplication，使用不同的profile</strong></p>
<p>修改 UserApplication2 这个启动项，改变其profile值：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092345.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092345.png" alt="img"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092338.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092338.png" alt="img"></a></p>
<p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p>
<p>启动 UserApplication 和 UserApplication2</p>
<p>访问地址：<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092400.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092400.png" alt="img"></a></p>
<p>访问地址：<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092419.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092419.png" alt="img"></a></p>
<p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p>
<p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p>
<p>通过下面的两种方式来指定：</p>
<ul>
<li>extension-configs</li>
<li>shared-configs</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">extends-configs:</span> <span class="hljs-comment"># 多微服务间共享的配置列表</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">common.yaml</span> <span class="hljs-comment"># 要共享的配置文件id</span><br><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 多微服务间共享的配置列表</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">common.yaml</span> <span class="hljs-comment"># 要共享的配置文件id</span><br></code></pre></td></tr></table></figure>

<h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092501.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092501.png" alt="img"></a></p>
<p>更细致的配置</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092520.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092520.png" alt="img"></a></p>
<h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092616.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092616.png" alt="img"></a></p>
<ul>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护</li>
</ul>
<p>Feign 是一个声明式的 http 客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092639.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092639.png" alt="img"></a></p>
<h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p>
<p>我们在 order-service 引入 feign 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>添加注解</strong></p>
<p>在 order-service 启动类添加注解开启 Feign</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092704.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092704.png" alt="img"></a></p>
<p><strong>请求接口</strong></p>
<p>在 order-service 中新建一个接口，内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.client;<br><br><span class="hljs-keyword">import</span> cn.itcast.order.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p>
<p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p>
<p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p>
<p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserClient userClient;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">queryOrderAndUserById</span><span class="hljs-params">(Long orderId)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.查询订单</span><br>    Order order = orderMapper.findById(orderId);<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 2021/8/20 使用feign远程调用</span><br>    User user = userClient.findById(order.getUserId());<br>    <span class="hljs-comment">// 3. 将用户信息封装进订单</span><br>    order.setUser(user);<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">作用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>feign.Logger.Level</strong></td>
<td align="left">修改日志级别</td>
<td align="left">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td align="left">feign.codec.Decoder</td>
<td align="left">响应结果的解析器</td>
<td align="left">http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td align="left">feign.codec.Encoder</td>
<td align="left">请求参数编码</td>
<td align="left">将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td align="left">feign.Contract</td>
<td align="left">支持的注解格式</td>
<td align="left">默认是SpringMVC的注解</td>
</tr>
<tr>
<td align="left">feign.Retryer</td>
<td align="left">失败重试机制</td>
<td align="left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p>
<p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure>

<p><strong>也可以针对所有服务：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure>

<p>而日志的级别分为四种：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li>
</ul>
<p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFeignConfiguration</span>  </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.<span class="hljs-function">Level <span class="hljs-title">feignLogLevel</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure>

<p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p>
<ul>
<li><strong>URLConnection</strong>：默认实现，不支持连接池</li>
<li><strong>Apache HttpClient</strong> ：支持连接池</li>
<li><strong>OKHttp</strong>：支持连接池</li>
</ul>
<p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p>
<p>另外，日志级别应该尽量用 basic/none，可以有效提高性能。</p>
<p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p>
<p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>配置连接池</strong></p>
<p>在 order-service 的 application.yml 中添加配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure>

<p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092729.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092729.png" alt="img"></a></p>
<p>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 HttpClient</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092737.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092737.png" alt="img"></a></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p>
<p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p>
<p>2）Feign 客户端、Controller 都集成该接口</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092803.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092803.png" alt="img"></a></p>
<p>优点</p>
<ul>
<li>简单</li>
<li>实现了代码共享</li>
</ul>
<p>缺点</p>
<ul>
<li>服务提供方、服务消费方紧耦合</li>
<li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li>
</ul>
<h3 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p>
<p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092811.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092811.png" alt="img"></a></p>
<p>接下来我们就用该方法在代码中实现</p>
<p><strong>首先创建一个 module，命名为 feign-api</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092835.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092835.png" alt="img"></a></p>
<p>在 feign-api 中然后引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>order-service中的 UserClient、User 都复制到 feign-api 项目中</p>
<p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092848.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092848.png" alt="img"></a></p>
<p><strong>在order-service中使用 feign-api</strong></p>
<p>首先，删除 order-service 中的 UserClient、User</p>
<p>在 order-service 中引入 feign-api</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xn2001.feign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>修改注解</strong></p>
<p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p>
<p>修改 order-service 启动类上的 @EnableFeignClients 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.xn2001.feign.clients&quot;)</span><br></code></pre></td></tr></table></figure>

<h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li>请求路由</li>
<li>权限控制</li>
<li>限流</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173727591.png" alt="image-20220521173727591"></p>
<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>
<p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>
<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>
<p>在 SpringCloud 中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>
<h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol>
<li>创建 SpringBoot 工程 gateway，引入网关依赖</li>
<li>编写启动类</li>
<li>编写基础配置和路由规则</li>
<li>启动网关服务进行测试</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>创建 application.yml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure>

<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>
<p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p>
<p>重启网关，访问 <a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a href="http://userservice/user/1">http://userservice/user/1</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173845186.png" alt="image-20220521173845186"></p>
<p>多个 predicates 的话，要同时满足规则，下文有例子。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173917312.png" alt="image-20220521173917312"></p>
<p>路由配置包括：</p>
<ol>
<li>路由id：路由的唯一标示</li>
<li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li>
<li>路由断言（predicates）：判断路由的规则</li>
<li>路由过滤器（filters）：对请求或响应做处理</li>
</ol>
<h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p>
<p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">After</td>
<td align="left">是某个时间点后的请求</td>
<td align="left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td align="left">Before</td>
<td align="left">是某个时间点之前的请求</td>
<td align="left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td align="left">Between</td>
<td align="left">是某两个时间点之前的请求</td>
<td align="left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">请求必须包含某些cookie</td>
<td align="left">- Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td align="left">Header</td>
<td align="left">请求必须包含某些header</td>
<td align="left">- Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">请求必须是访问某个host（域名）</td>
<td align="left">- Host=<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td>
</tr>
<tr>
<td align="left">Method</td>
<td align="left">请求方式必须是指定方式</td>
<td align="left">- Method=GET,POST</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">请求路径必须符合指定规则</td>
<td align="left">- Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td align="left">Query</td>
<td align="left">请求参数必须包含指定参数</td>
<td align="left">- Query=name, Jack或者- Query=name</td>
</tr>
<tr>
<td align="left">RemoteAddr</td>
<td align="left">请求者的ip必须是指定范围</td>
<td align="left">- RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td align="left">Weight</td>
<td align="left">权重处理</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p>
</blockquote>
<p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">predicates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">After=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure>

<p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p>
<h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173935022.png" alt="image-20220521173935022"></p>
<p>Spring提供了31种不同的路由过滤器工厂。</p>
<blockquote>
<p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">AddRequestHeader</td>
<td align="left">给当前请求添加一个请求头</td>
</tr>
<tr>
<td align="left">RemoveRequestHeader</td>
<td align="left">移除请求中的一个请求头</td>
</tr>
<tr>
<td align="left">AddResponseHeader</td>
<td align="left">给响应结果中添加一个响应头</td>
</tr>
<tr>
<td align="left">RemoveResponseHeader</td>
<td align="left">从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td align="left">RequestRateLimiter</td>
<td align="left">限制请求的流量</td>
</tr>
</tbody></table>
<p>下面我们以 AddRequestHeader 为例：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174021064.png" alt="image-20220521174021064"></p>
<p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p>
<p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=sign,</span> <span class="hljs-string">xn2001.com</span> <span class="hljs-string">is</span> <span class="hljs-string">eternal</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure>

<p>如何验证，我们修改 userservice 中的一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="hljs-meta">@RequestHeader(value = &quot;sign&quot;, required = false)</span> String sign)</span> </span>&#123;<br>    log.warn(sign);<br>    <span class="hljs-keyword">return</span> userService.queryById(id);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重启两个服务，访问：<a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p>
<p>可以看到控制台打印出了这个请求头</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174034929.png" alt="image-20220521174034929"></p>
<p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=sign,</span> <span class="hljs-string">xn2001.com</span> <span class="hljs-string">is</span> <span class="hljs-string">eternal</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure>

<h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p>
<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p>
<p><strong>需求：</strong>定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p>
<ul>
<li>参数中是否有 authorization</li>
<li>authorization 参数值是否为 admin</li>
</ul>
<p>如果同时满足则放行，否则拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-comment">// 测试：http://localhost:10010/order/101?authorization=admin</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取第一个 authorization 参数</span><br>        String authorization = exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(authorization))&#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 设置拦截状态码信息</span><br>        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>        <span class="hljs-comment">// 设置拦截</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置过滤器优先级，值越低优先级越高</span><br>    <span class="hljs-comment">// 也可以使用 @Order 注解</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p>
<p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174102554.png" alt="image-20220521174102554"></p>
<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li>
<li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure>



<h1 id="ELasticsearch搜索引擎"><a href="#ELasticsearch搜索引擎" class="headerlink" title="ELasticsearch搜索引擎"></a>ELasticsearch搜索引擎</h1><p>ELasticsearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容，可以用来实现搜索、日志统计、分析、系统监控等功能。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><strong>首先，倒排索引的概念是基于 MySQL 这样的正向索引而言的。</strong></p>
<p>那么我们先讲何为正向索引。例如给下表（tb_goods）中的 id 创建索引</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135704943.png" alt="image-20220522135704943"></p>
<p>如果是根据 id 查询，那么直接走索引，查询速度非常快。</p>
<p>但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：</p>
<ol>
<li>用户搜索数据，条件是 title 符合 <code>&quot;%手机%&quot;</code></li>
<li>逐行获取数据，比如 id 为 1 的数据</li>
<li>判断数据中的 title 是否符合用户搜索条件</li>
<li>如果符合则放入结果集，不符合则丢弃。然后回到步骤1</li>
</ol>
<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是。。。</p>
<p>而倒排索引中有两个非常重要的概念：</p>
<ul>
<li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档 id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引</li>
</ul>
<p>如图：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135727991.png" alt="image-20220522135727991"></p>
<p><strong>倒排索引的搜索流程</strong>如下（以搜索”华为手机”为例）</p>
<ol>
<li>用户输入条件<code>&quot;华为手机&quot;</code>进行搜索</li>
<li>对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code></li>
<li>拿着词条在倒排索引中查找，可以得到包含词条的文档 id 有 1、2、3</li>
<li>拿着文档 id 到正向索引中查找具体文档</li>
</ol>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135742748.png" alt="image-20220522135742748"></p>
<p><strong>虽然要先查询倒排索引，再查询正向索引，但是词条和文档id 都建立了索引，查询速度非常快！无需全表扫描。</strong></p>
<p>为什么一个叫做正向索引，一个叫做倒排索引呢？</p>
<p><strong>正向索引</strong>是最传统的，根据 id 索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong></p>
<p><strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据得到的文档 id 获取该文档。是<strong>根据词条找文档的过程</strong></p>
<h2 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h2><p>elasticsearch 是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 json 格式后存储在 elasticsearch</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135806235.png" alt="image-20220522135806235"></p>
<p>而 JSON 文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p>
<h2 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h2><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135826088.png" alt="image-20220522135826088"></p>
<p>因此，我们可以把索引当做是数据库中的表。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p>
<p><strong>mysql 与 elasticsearch</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL</strong></th>
<th align="left"><strong>Elasticsearch</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Table</td>
<td align="left">Index</td>
<td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td align="left">Row</td>
<td align="left">Document</td>
<td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td align="left">Column</td>
<td align="left">Field</td>
<td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td align="left">Schema</td>
<td align="left">Mapping</td>
<td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td align="left">SQL</td>
<td align="left">DSL</td>
<td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody></table>
<ul>
<li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li>
<li>Elasticsearch：擅长海量数据的搜索、分析、计算</li>
</ul>
<p>因此在企业中，往往是两者结合使用：</p>
<ul>
<li>对安全性要求较高的写操作，使用 MySQL 实现</li>
<li>对查询性能要求较高的搜索需求，使用 ELasticsearch 实现</li>
<li>两者再基于某种方式，实现数据的同步，保证一致性</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135845119.png" alt="image-20220522135845119"></p>
<h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>IK分词器包含两种模式：</p>
<ul>
<li><code>ik_smart</code>：智能切分，粗粒度</li>
<li><code>ik_max_word</code>：最细切分，细粒度</li>
</ul>
<h2 id="扩展词词典"><a href="#扩展词词典" class="headerlink" title="扩展词词典"></a>扩展词词典</h2><p>在上面的IK分词器我们可以随着热点词来扩展，可以自己添加，比如 ”钟老师应该是一个热点词“，另外你也可以配置一些停用掉的敏感词，让其不进行分词。</p>
<p>打开IK分词器 config 目录是 <code>IKAnalyzer.cfg.xml</code>，添加一个文件名，我们以 <code>ext.dic</code> 文件名为例。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140038286.png" alt="image-20220522140038286"></p>
<p>我们去创建 <code>ext.dic</code> ，在其中添加热点词就好了，一个词一行。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140052838.png" alt="image-20220522140052838"></p>
<p>重启elasticsearch。</p>
<h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><h3 id="Mapping属性映射"><a href="#Mapping属性映射" class="headerlink" title="Mapping属性映射"></a>Mapping属性映射</h3><p>索引库就类似数据库表，<strong>mapping 映射就类似表的结构</strong></p>
<p>我们要向 es 中存储数据，必须先创建“库”和“表”</p>
<p>mapping 是对索引库中文档的约束，常见的 mapping 属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float、</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li><strong>index：是否创建索引，默认为 true</strong></li>
<li>analyzer：使用哪种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<p>我们以需要存储下面的 JSON 为例来讲解</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">&quot;weight&quot;</span>: <span class="hljs-number">52.1</span>,<br>    <span class="hljs-attr">&quot;isMarried&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;钟老师真菜&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;jialna@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: [<span class="hljs-number">99.1</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">98.9</span>],<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;湖&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;心&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先对应的每个字段映射（mapping）情况如下：</p>
<ul>
<li>age：类型为 integer；参与搜索，index 为 true；无需分词器</li>
<li>weight：类型为 float；参与搜索，index 为 true；无需分词器</li>
<li>isMarried：类型为boolean；参与搜索，index 为 true；无需分词器</li>
<li>info：类型为字符串，需要分词，因此是 text；参与搜索，index为true；分词器可以用 ik_smart</li>
<li>email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，index 为 false；无需分词器</li>
<li>score：虽然是数组，<strong>但是我们只看元素的类型</strong>，类型为 float；参与搜索，index 为 true；无需分词器</li>
<li>name：类型为 object，需要定义多个子属性<ul>
<li>name.firstName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li>
<li>name.lastName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li>
</ul>
</li>
</ul>
<h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p>上面我们了解了 Mapping 属性映射，接下来我们就去看看如何创建索引库及映射。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /索引库名称<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;字段名&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;字段名2&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;false&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;字段名3&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;子字段&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// ...略</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>PUT /hotel<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;name&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;address&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;price&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;score&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;brand&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;city&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;starName&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;business&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;location&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;geo_point&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;pic&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;all&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特殊字段说明：</p>
<ul>
<li>location：地理坐标，里面包含精度、纬度</li>
<li>all：一个组合字段，其目的是将多字段的值利用 <code>copy_to</code> 合并，提供给用户搜索，这样一来就只需要搜索一个字段就可以得到结果，性能更好。</li>
</ul>
<blockquote>
<p>ES中支持两种地理坐标数据类型：</p>
<ul>
<li>geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：”32.8752345, 120.2981576”</li>
<li>geo_shape：有多个 geo_point 组成的复杂几何图形。例如一条直线，”LINESTRING (-77.03653 38.897676, -77.009051 38.889939)”</li>
</ul>
</blockquote>
<h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改 mapping</strong></p>
<p>虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，不会对倒排索引产生影响。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /索引库名/_mapping<br>&#123;<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;新字段名&quot;</span>:&#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">DELETE /索引库名<br></code></pre></td></tr></table></figure>

<h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">GET /数据库名<br></code></pre></td></tr></table></figure>

<h2 id="DSL文档操作"><a href="#DSL文档操作" class="headerlink" title="DSL文档操作"></a>DSL文档操作</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br>&#123;<br>    <span class="hljs-attr">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-attr">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-attr">&quot;字段3&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;子属性1&quot;</span>: <span class="hljs-string">&quot;值3&quot;</span>,<br>        <span class="hljs-attr">&quot;子属性2&quot;</span>: <span class="hljs-string">&quot;值4&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>POST /xn2001/_doc/1<br>&#123;<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;我不会Java&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;jialna@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;钟&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;弟弟&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>修改文档有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p><strong>全量修改</strong>是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的 id 删除文档</li>
<li>新增一个相同 id 的文档</li>
</ul>
<p><strong>注意</strong>：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就是变成了新增操作</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /&#123;索引库名&#125;/_doc/id<br>&#123;<br>    <span class="hljs-attr">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-attr">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-comment">// ... 略</span><br>&#125;<br>PUT /xn2001/_doc/1<br>&#123;<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;我也不会敲代码&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;3300123589@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;弟弟&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;钟&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>增量修改</strong>是只修改指定 id 匹配的文档中的部分字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">POST /&#123;索引库名&#125;/_update/文档id<br>&#123;<br>    <span class="hljs-attr">&quot;doc&quot;</span>: &#123;<br>         <span class="hljs-attr">&quot;字段名&quot;</span>: <span class="hljs-string">&quot;新的值&quot;</span>,<br>    &#125;<br>&#125;<br>POST /heima/_update/1<br>&#123;<br>  <span class="hljs-attr">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;update@qq.com&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">GET /&#123;索引库名称&#125;/_doc/&#123;id&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">DELETE /&#123;索引库名&#125;/_doc/&#123;id&#125;<br></code></pre></td></tr></table></figure>

<h2 id="RestClient文档操作"><a href="#RestClient文档操作" class="headerlink" title="RestClient文档操作"></a>RestClient文档操作</h2><p>ES 官方提供了各种不同语言的客户端，用来操作 ES。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<h3 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h3><p>在 elasticsearch 提供的 API 中，elasticsearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 elasticsearch 的连接。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>SpringBoot 默认的 ES 版本是 7.6.2，我们需要覆盖默认的ES版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>初始化 RestHighLevelClient，初始化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">RestHighLevelClient client = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure>

<p>我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 <code>@BeforeEach</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/19 17:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelIndexTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.restHighLevelClient);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//指定索引库名</span><br>    CreateIndexRequest hotel = <span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">//写入JSON数据，这里是Mapping映射</span><br>    hotel.source(HotelConstants.MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">//创建索引库</span><br>    restHighLevelClient.indices().create(hotel, RequestOptions.DEFAULT);<br>&#125;<br><br><span class="hljs-comment">//具体的json数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelConstants</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String MAPPING_TEMPLATE = <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    DeleteIndexRequest hotel = <span class="hljs-keyword">new</span> DeleteIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    restHighLevelClient.indices().delete(hotel,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断索引库"><a href="#判断索引库" class="headerlink" title="判断索引库"></a>判断索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">existHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    GetIndexRequest hotel = <span class="hljs-keyword">new</span> GetIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-keyword">boolean</span> exists = restHighLevelClient.indices().exists(hotel, RequestOptions.DEFAULT);<br>    System.out.println(exists);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/19 17:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelDocumentTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.restHighLevelClient);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Hotel hotel = hotelService.getById(<span class="hljs-number">61083L</span>);<br>        HotelDoc hotelDoc = <span class="hljs-keyword">new</span> HotelDoc(hotel);<br>        <span class="hljs-comment">// 1.准备Request对象</span><br>        IndexRequest hotelIndex = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());<br>        <span class="hljs-comment">// 2.准备Json文档</span><br>        hotelIndex.source(JSON.toJSONString(hotelDoc), XContentType.JSON);<br>        <span class="hljs-comment">// 3.发送请求</span><br>        restHighLevelClient.index(hotelIndex, RequestOptions.DEFAULT);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    GetRequest hotel = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求，得到响应</span><br>    GetResponse hotelResponse = restHighLevelClient.get(hotel, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.解析响应结果</span><br>    String hotelDocSourceAsString = hotelResponse.getSourceAsString();<br>    <span class="hljs-comment">// 4.json转实体类</span><br>    HotelDoc hotelDoc = JSON.parseObject(hotelDocSourceAsString, HotelDoc.class);<br>    System.out.println(hotelDoc);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    DeleteRequest hotel = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    restHighLevelClient.delete(hotel,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><p>前面我们说过，修改文档有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p>在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p>所以全量修改写法与新增文档一样，下面我们主要是介绍增量修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testUpdateDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    UpdateRequest request = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.doc(<br>        <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-string">&quot;952&quot;</span>,<br>        <span class="hljs-string">&quot;starName&quot;</span>, <span class="hljs-string">&quot;四钻&quot;</span><br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    restHighLevelClient.update(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h3><p>案例需求：利用 <code>BulkRequest</code> 批量将数据库数据导入到索引库中。</p>
<ul>
<li>利用 mybatis-plus 查询酒店数据</li>
<li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li>
<li>利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档</li>
</ul>
<p>批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。</p>
<p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140530912.png" alt="image-20220522140530912"></p>
<p>利用这一点，我们可以写出自己需要的代码，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testBulk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    BulkRequest bulkRequest = <span class="hljs-keyword">new</span> BulkRequest();<br>    List&lt;Hotel&gt; hotelList = hotelService.list();<br>    hotelList.forEach(item -&gt; &#123;<br>        HotelDoc hotelDoc = <span class="hljs-keyword">new</span> HotelDoc(item);<br>        bulkRequest.add(<span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                .id(hotelDoc.getId().toString())<br>                .source(JSON.toJSONString(hotelDoc), XContentType.JSON));<br>    &#125;);<br>    restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>总之，在 Java 代码中，client 针对操作索引库还是文档，基本都是一样的代码</p>
<p>restHighLevelClient.indices().xxx，代表操作索引库</p>
<p>restHighLevelClient.xxx，代表操作文档</p>
<p>而其中所需要的参数，我们直接通过 <strong>ctrl+p</strong> 这样的快捷键去查看就可以，不需要单独记住。</p>
<h2 id="DSL文档查询"><a href="#DSL文档查询" class="headerlink" title="DSL文档查询"></a>DSL文档查询</h2><p>Elasticsearch 提供了基于 JSON 的 DSL(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>)来定义查询。常见的查询类型包括：</p>
<p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p>
<p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p>
<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
<p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：</p>
<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
<p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p>
<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
<p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>
<ul>
<li>bool</li>
<li>function_score</li>
</ul>
<hr>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 查询所有</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>使用场景：全文检索查询的基本流程如下：</p>
<ul>
<li>对用户搜索的内容做分词，得到词条</li>
<li>根据词条去倒排索引库中匹配，得到文档id</li>
<li>根据文档id找到文档，返回给用户</li>
</ul>
<p>比较常用的场景包括：</p>
<ul>
<li>商城的输入框搜索</li>
<li>百度输入框搜索</li>
</ul>
<p>常见的全文检索查询包括：</p>
<ul>
<li>match 查询：单字段查询</li>
<li>multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件</li>
</ul>
<p>match 查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>mulit_match 查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span>,<br>      <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;FIELD1&quot;</span>, <span class="hljs-string">&quot; FIELD12&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为我们将 brand、name、business 值都利用 <strong>copy_to</strong> 复制到了 <strong>all</strong> 字段中，你根据三个字段搜索，和根据 all字段搜索效果是一样的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;all&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br>GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span>,<br>      <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;brand&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>搜索字段越多，对查询性能影响越大，因此建议采用 copy_to 将多个字段合并为一个，然后使用单字段查询的方式。</strong></p>
<h3 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h3><p>精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以<strong>不会</strong>对搜索条件分词。</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
<h4 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h4><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p>
<p>语法说明：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// term查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;VALUE&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;brand&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>
<p>基本语法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// range查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 这里的gte代表大于等于，gt则代表大于</span><br>        <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">20</span> <span class="hljs-comment">// lte代表小于等于，lt则代表小于</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140701446.png" alt="image-20220522140701446"></p>
<p>精确查询常见的有哪些？</p>
<ul>
<li>term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段</li>
<li>range 查询：根据数值范围查询，可以是数值、日期的范围</li>
</ul>
<h3 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h3><p>地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p>
<p>常见的使用场景包括：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
<li>微信：搜索我附近的人</li>
</ul>
<blockquote>
<p>矩形范围查询</p>
</blockquote>
<p>矩形范围查询，也就是 <code>geo_bounding_box</code> 查询，查询坐标落在某个矩形范围的所有文档</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164127368.png" alt="image-20220522164127368"></p>
<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_bounding_box查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;geo_bounding_box&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;top_left&quot;</span>: &#123; <span class="hljs-comment">// 左上点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span>: <span class="hljs-number">31.1</span>,<br>          <span class="hljs-attr">&quot;lon&quot;</span>: <span class="hljs-number">121.5</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;bottom_right&quot;</span>: &#123; <span class="hljs-comment">// 右下点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span>: <span class="hljs-number">30.9</span>,<br>          <span class="hljs-attr">&quot;lon&quot;</span>: <span class="hljs-number">121.7</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>附近查询</p>
</blockquote>
<p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档</p>
<p>在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164158386.png" alt="image-20220522164158386"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_distance 查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;geo_distance&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;distance&quot;</span>: <span class="hljs-string">&quot;15km&quot;</span>, <span class="hljs-comment">// 半径</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;31.21,121.5&quot;</span> <span class="hljs-comment">// 圆心</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还可以根据距离排序</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;location&quot;</span>: <span class="hljs-string">&quot;31.034661,121.612282&quot;</span>, <span class="hljs-comment">//圆心</span><br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">//排序</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">//单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">&quot;hits&quot; : [<br>    &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;hotel&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;2056298828&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>            ...<br>        &#125;,<br>        &quot;sort&quot; : [<br>            <span class="hljs-number">4.8541199685347785</span> <span class="hljs-comment">//这里的结果为离圆心的距离</span><br>        ]<br>    &#125;,<br></code></pre></td></tr></table></figure>

<p>注意：输出结果中的 <strong>sort</strong> 为距离，比较常用。</p>
<p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的</p>
<h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>
<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>
</ul>
<h3 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h3><blockquote>
<p>这部分内容作为了解即可。</p>
</blockquote>
<p>当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。例如，我们搜索 “虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">17.850193</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;虹桥如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">12.259849</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;外滩如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">11.91091</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;迪士尼如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><p>根据相关度打分是比较合理的需求，但有时候也不能够满足我们的需求。</p>
<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁给的钱多排名就越靠前。</p>
<p><strong>要想认为控制相关性算分，就需要利用 elasticsearch 中的 function score 查询了。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164427295.png" alt="image-20220522164427295"></p>
<p>function score 查询中包含四部分内容：</p>
<ul>
<li><strong>原始查询</strong>条件：query 部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li>
<li><strong>过滤条件</strong>：filter 部分，符合该条件的文档才会<strong>重新算分</strong></li>
<li><strong>算分函数</strong>：符合 filter 条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul>
<li>weight：函数结果是常量</li>
<li>field_value_factor：以文档中的某个字段值作为函数结果</li>
<li>random_score：以随机数作为函数结果</li>
<li>script_score：自定义算分函数算法</li>
</ul>
</li>
<li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul>
<li>multiply：相乘</li>
<li>replace：用 function score 替换 query score</li>
<li>sum、avg、max、min</li>
</ul>
</li>
</ul>
<p>function score 的运行流程如下：</p>
<ol>
<li>根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li>
<li>根据<strong>过滤条件</strong>，过滤文档</li>
<li>符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li>
<li>将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li>
</ol>
<p>因此，其中的关键点是</p>
<ul>
<li>过滤条件：决定哪些文档的算分被修改</li>
<li>算分函数：决定函数算分的算法</li>
<li>运算模式：决定最终算分结果</li>
</ul>
<p>例如：我们给“如家”这个品牌的酒店排名靠前一些</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;function_score&quot;</span>: &#123;<br>      &quot;query&quot;: &#123;  .... &#125;, // 原始查询，可以是任意条件<br>      &quot;functions&quot;: [ // 算分函数<br>        &#123;<br>          <span class="hljs-attr">&quot;filter&quot;</span>: &#123; <span class="hljs-comment">// 满足的条件，品牌必须是如家</span><br>            <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;如家&quot;</span><br>            &#125;<br>          &#125;,<br>          <span class="hljs-attr">&quot;weight&quot;</span>: <span class="hljs-number">10</span> <span class="hljs-comment">// 算分权重为10</span><br>        &#125;<br>      ],<br>      &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试，在未添加算分函数时，如家得分如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164516047.png" alt="image-20220522164516047"></p>
<p>添加了算分函数后，如家得分就提升了</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164530125.png" alt="image-20220522164530125"></p>
<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有</p>
<ul>
<li>must：必须匹配每个子查询，类似“与”</li>
<li>should：选择性匹配子查询，类似“或”</li>
<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>
<li>filter：必须匹配，<strong>不参与算分</strong></li>
</ul>
<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤</p>
<p><strong>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool查询了。</strong></p>
<p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p>
<ul>
<li>搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分</li>
<li>其它过滤条件，采用 filter 查询，不参与算分</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;must&quot;</span>: [<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;city&quot;</span>: <span class="hljs-string">&quot;上海&quot;</span> &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;should&quot;</span>: [<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;皇冠假日&quot;</span> &#125;&#125;,<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;华美达&quot;</span> &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;must_not&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;range&quot;</span>: &#123; <span class="hljs-attr">&quot;price&quot;</span>: &#123; <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">500</span> &#125; &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;filter&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;range&quot;</span>: &#123;<span class="hljs-attr">&quot;score&quot;</span>: &#123; <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">45</span> &#125; &#125;&#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。</p>
<ul>
<li>名称搜索，属于全文检索查询，应该参与算分，放到 must 中</li>
<li>价格不高于 400，用 range 查询，属于过滤条件，不参与算分，放到 must_not 中</li>
<li>周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分，放到 filter 中</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164728363.png" alt="image-20220522164728363"></p>
<p>bool 查询的几种逻辑关系</p>
<ul>
<li>must：必须匹配的条件，可以理解为“与”</li>
<li>should：选择性匹配的条件，可以理解为“或”</li>
<li>must_not：必须不匹配的条件，不参与打分</li>
<li>filter：必须匹配的条件，不参与打分</li>
</ul>
<h2 id="搜索结果处理"><a href="#搜索结果处理" class="headerlink" title="搜索结果处理"></a>搜索结果处理</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>elasticsearch 默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等</p>
<p>keyword、数值、日期类型排序的语法基本一致。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>  <span class="hljs-comment">// 排序字段、排序方式ASC、DESC</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序。</p>
<p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164754555.png" alt="image-20220522164754555"></p>
<p>地理坐标排序略有不同</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;FIELD&quot;</span> : <span class="hljs-string">&quot;纬度，经度&quot;</span>, <span class="hljs-comment">// 文档中geo_point类型的字段名、目标坐标点</span><br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">// 排序方式</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">// 排序的距离单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;location&quot;</span>: <span class="hljs-string">&quot;31.034661,121.612282&quot;</span>, <br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat</a></p>
</blockquote>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>elasticsearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。</p>
<p>elasticsearch 通过修改 from、size 参数来控制要返回的分页结果：</p>
<ul>
<li>from：从第几个文档开始</li>
<li>size：总共查询几个文档</li>
</ul>
<p>类似于mysql中的<code>limit ?, ?</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>深度分页问题</p>
</blockquote>
<p>现在，我要查询990~1000的数据，查询逻辑要这么写</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">990</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p>
<p>注意：elasticsearch 内部分页时，必须先查询 0~1000条，然后截取其中的 990 ~ 1000 的这10条</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164937837.png" alt="image-20220522164937837"></p>
<p>查询TOP1000，如果 es 是单点模式，这并无太大影响。</p>
<p>但是 elasticsearch 将来一定是集群，例如我集群有5个节点，我要查询 TOP1000 的数据，并不是每个节点查询200条就可以了。节点A的 TOP200，在另一个节点可能排到10000名以外了。</p>
<p><strong>因此要想获取整个集群的 TOP1000，必须先查询出每个节点的 TOP1000，汇总结果后，重新排名，重新截取 TOP1000。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164952750.png" alt="image-20220522164952750"></p>
<p><strong>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此 elasticsearch 会禁止from+ size 超过10000的请求。</strong></p>
<p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p>
<ul>
<li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li>
<li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li>
</ul>
<hr>
<p>分页查询的常见实现方案以及优缺点</p>
<ul>
<li><code>from + size</code><ul>
<li>优点：支持随机翻页</li>
<li>缺点：深度分页问题，默认查询上限（from + size）是10000</li>
<li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li>
</ul>
</li>
<li><code>after search</code><ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：只能向后逐页查询，不支持随机翻页</li>
<li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li>
</ul>
</li>
<li><code>scroll</code><ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>
<li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li>
</ul>
</li>
</ul>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165015423.png" alt="image-20220522165015423"></p>
<p>高亮显示的实现分为两步：</p>
<ul>
<li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span> <span class="hljs-comment">// 查询条件，高亮一定要使用全文检索查询</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;highlight&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;fields&quot;</span>: &#123; <span class="hljs-comment">// 指定要高亮的字段</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;em&gt;&quot;</span>,  <span class="hljs-comment">// 用来标记高亮字段的前置标签</span><br>        <span class="hljs-attr">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span> <span class="hljs-comment">// 用来标记高亮字段的后置标签</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>
<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>
<li>如果要对非搜索字段高亮，则需要添加一个属性：<code>required_field_match=false</code></li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165033153.png" alt="image-20220522165033153"></p>
<blockquote>
<p>DSL 总体结构如下：</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165048231.png" alt="image-20220522165048231"></p>
<h2 id="RestClient文档查询"><a href="#RestClient文档查询" class="headerlink" title="RestClient文档查询"></a>RestClient文档查询</h2><h3 id="发起查询请求"><a href="#发起查询请求" class="headerlink" title="发起查询请求"></a>发起查询请求</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165109299.png" alt="image-20220522165109299"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/10/16 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelSearchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match_All</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        request.source()<br>                .query(QueryBuilders.matchAllQuery());<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一步，创建<code>SearchRequest</code>对象，指定索引库名</li>
<li>第二步，利用<code>request.source()</code>构建 DSL，DSL 中可以包含查询、分页、排序、高亮等<ul>
<li><code>query()</code>：代表查询条件，利用 <code>QueryBuilders.matchAllQuery()</code> 构建一个 match_all 查询的 DSL</li>
</ul>
</li>
<li>第三步，利用 <code>client.search()</code> 发送请求，得到响应</li>
</ul>
<p>关键的 API 有两个，一个是 <code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165155892.png" alt="image-20220522165155892"></p>
<p>另一个是 <code>QueryBuilders</code>，其中包含 match、term、function_score、bool 等各种查询</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165215501.png" alt="image-20220522165215501"></p>
<h3 id="解析查询响应"><a href="#解析查询响应" class="headerlink" title="解析查询响应"></a>解析查询响应</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165233745.png" alt="image-20220522165233745"></p>
<p>Elasticsearch 返回的结果是一个 JSON 字符串，结构包含</p>
<ul>
<li><code>hits</code>：命中的结果<ul>
<li><code>total</code>：总条数，其中的value是具体的总条数值</li>
<li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li>
<li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个 json 对象<ul>
<li><code>_source</code>：文档中的原始数据，也是 json 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下</p>
<ul>
<li><code>SearchHits</code>：通过 <code>response.getHits()</code> 获取，就是 json 中的最外层的 hits，代表命中的结果<ul>
<li><code>SearchHits.getTotalHits().value</code>：获取总条数信息</li>
<li><code>SearchHits.getHits()</code>：获取 SearchHit 数组，也就是文档数组<ul>
<li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的 <code>_source</code>，也就是原始的 json 文档数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/10/16 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelSearchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match_All</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        request.source()<br>                .query(QueryBuilders.matchAllQuery());<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        SearchHits searchHits = response.getHits();<br>        System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>        SearchHit[] hits = searchHits.getHits();<br>        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>            String sourceAsString = hit.getSourceAsString();<br>            HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>            System.out.println(hotelDoc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165256103.png" alt="image-20220522165256103"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source()<br>            .query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>,<span class="hljs-string">&quot;如家&quot;</span>));<br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multiMatchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source()<br>            .query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;如家&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;brand&quot;</span>));<br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询主要是两者</p>
<ul>
<li>term：词条精确匹配</li>
<li>range：范围查询</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165330608.png" alt="image-20220522165330608"></p>
<h3 id="布尔查询-1"><a href="#布尔查询-1" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是用 must、must_not、filter等方式组合其它查询，代码示例如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165341669.png" alt="image-20220522165341669"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    request.source()<br>            .query(<br>                    QueryBuilders.boolQuery()<br>                            .must(QueryBuilders.termQuery(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>))<br>                            .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">300</span>))<br>            );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="排序、分页"><a href="#排序、分页" class="headerlink" title="排序、分页"></a>排序、分页</h3><p>搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 <code>request.source()</code> 来设置。</p>
<p>对应的API如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165400398.png" alt="image-20220522165400398"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPageAndSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 页码，每页大小</span><br>    <span class="hljs-keyword">int</span> page = <span class="hljs-number">1</span>, size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 2.2.排序 sort</span><br>    request.source().sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>    <span class="hljs-comment">// 2.3.分页 from、size</span><br>    request.source().from((page - <span class="hljs-number">1</span>) * size).size(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h3><ul>
<li>查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。</li>
<li>结果解析：结果除了要解析 <code>_source</code> 文档数据，还要解析高亮结果</li>
</ul>
<p><strong>高亮请求的构建 API</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165415263.png" alt="image-20220522165415263"></p>
<p>上述代码省略了查询条件部分，但是高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;如家&quot;</span>));<br>    <span class="hljs-comment">// 2.2.高亮</span><br>    request.source().highlighter(<span class="hljs-keyword">new</span> HighlightBuilder().field(<span class="hljs-string">&quot;name&quot;</span>).requireFieldMatch(<span class="hljs-keyword">false</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response); <span class="hljs-comment">//代码在下文</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>高亮结果解析</strong></p>
<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>
<p>因此解析高亮的代码需要额外处理：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165433204.png" alt="image-20220522165433204"></p>
<ul>
<li>第一步：从结果中获取 source。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json 字符串，需要反序列为 HotelDoc 对象</li>
<li>第二步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个 Map，key 是高亮字段名称，值是HighlightField 对象，代表高亮值</li>
<li>第三步：从 map 中根据高亮字段名称，获取高亮字段值对象 HighlightField</li>
<li>第四步：从 HighlightField 中获取 Fragments，并且转为字符串。<strong>这部分是真正的高亮字符串</strong></li>
<li>第五步：用高亮的结果替换 HotelDoc 中的非高亮结果</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> </span>&#123;<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    <span class="hljs-comment">// 4.1.获取总条数</span><br>    <span class="hljs-keyword">long</span> total = searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 4.2.文档数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 获取文档source</span><br>        String json = hit.getSourceAsString();<br>        <span class="hljs-comment">// 反序列化</span><br>        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);<br>        <span class="hljs-comment">// 获取高亮结果</span><br>        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;<br>            <span class="hljs-comment">// 根据字段名获取高亮结果</span><br>            HighlightField highlightField = highlightFields.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (highlightField != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 获取高亮值</span><br>                String name = highlightField.getFragments()[<span class="hljs-number">0</span>].string();<br>                <span class="hljs-comment">// 覆盖非高亮结果</span><br>                hotelDoc.setName(name);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;hotelDoc = &quot;</span> + hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

























<h1 id="Sentine流量组件"><a href="#Sentine流量组件" class="headerlink" title="Sentine流量组件"></a>Sentine流量组件</h1><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><blockquote>
<p>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</p>
</blockquote>
<p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183034937.png" alt="image-20220520183034937"></p>
<p>如图，如果服务提供者I 发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I 的业务似乎不受影响。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183059877.png" alt="image-20220520183059877"></p>
<p>但是，依赖服务I 的业务请求被阻塞，则 tomcat 的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183114168.png" alt="image-20220520183114168"></p>
<p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，<strong>从而导致所有其它服务都不可用</strong>。</p>
<p>综上，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，这就是雪崩问题。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183129914.png" alt="image-20220520183129914"></p>
<p>解决雪崩问题的常见方式有四种</p>
<ol>
<li>超时处理</li>
<li>线程隔离</li>
<li>降级熔断</li>
<li>限流</li>
</ol>
<blockquote>
<p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p>
<p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p>
</blockquote>
<p>1.超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183203519.png" alt="image-20220520183203519"></p>
<p>2.线程隔离</p>
<p>是一种舱壁模式，如下图，船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此也叫线程隔离。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183217487.png" alt="image-20220520183217487"></p>
<p>3.降级熔断</p>
<p>是一种断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p>
<p>断路器会统计访问某个服务的请求数量，异常比例。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183301761.png" alt="image-20220520183301761"></p>
<p>当发现访问服务 D 的请求异常比例过高时，认为服务 D 有导致雪崩的风险，会拦截访问服务 D 的一切请求，形成熔断。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183317450.png" alt="image-20220520183317450"></p>
<p>4.限流</p>
<p><strong>流量控制</strong>：限制业务访问的 QPS，避免服务因流量的突增而故障。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183330199.png" alt="image-20220520183330199"></p>
<p>在 SpringCloud 当中支持多种服务保护技术</p>
<ul>
<li><a href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></li>
<li><a href="https://github.com/alibaba/Sentinel">Sentinel</a></li>
<li><a href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li>
</ul>
<p>早期比较流行的是 Hystrix 框架，但目前国内实用最广泛的还是阿里巴巴的 Sentinel 框架，这里我们做下对比：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>Sentinel</strong></th>
<th align="left"><strong>Hystrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">隔离策略</td>
<td align="left">信号量隔离</td>
<td align="left">线程池隔离/信号量隔离</td>
</tr>
<tr>
<td align="left">熔断降级策略</td>
<td align="left">基于慢调用比例或异常比例</td>
<td align="left">基于失败比率</td>
</tr>
<tr>
<td align="left">实时指标实现</td>
<td align="left">滑动窗口</td>
<td align="left">滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td align="left">规则配置</td>
<td align="left">支持多种数据源</td>
<td align="left">支持多种数据源</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">多个扩展点</td>
<td align="left">插件的形式</td>
</tr>
<tr>
<td align="left">基于注解的支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">限流</td>
<td align="left">基于 QPS，支持基于调用关系的限流</td>
<td align="left">有限的支持</td>
</tr>
<tr>
<td align="left">流量整形</td>
<td align="left">支持慢启动、匀速排队模式</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">系统自适应保护</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">控制台</td>
<td align="left">开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td align="left">不完善</td>
</tr>
<tr>
<td align="left">常见框架的适配</td>
<td align="left">Servlet、Spring Cloud、Dubbo、gRPC 等</td>
<td align="left">Servlet、Spring Cloud Netflix</td>
</tr>
</tbody></table>
<h2 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h2><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p>
<p>Sentinel 具有以下特征</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h2 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h2><p>下载后 jar 包后，运行代码：<code>java -jar sentinel-dashboard-1.8.1.jar</code></p>
<p>如果要修改 Sentinel 的默认端口、账户、密码，可以通过下列配置：</p>
<table>
<thead>
<tr>
<th align="left"><strong>配置项</strong></th>
<th align="left"><strong>默认值</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">server.port</td>
<td align="left">8080</td>
<td align="left">服务端口</td>
</tr>
<tr>
<td align="left">sentinel.dashboard.auth.username</td>
<td align="left">sentinel</td>
<td align="left">默认用户名</td>
</tr>
<tr>
<td align="left">sentinel.dashboard.auth.password</td>
<td align="left">sentinel</td>
<td align="left">默认密码</td>
</tr>
</tbody></table>
<p>例如，修改端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改其他配置也在配置项前面添加-D，注意不要在最后添加，会不起作用</span><br><span class="hljs-comment"># 也可以使用java -jar sentinel-dashboard-1.8.1.jar --server.port=9090 修改端口</span><br>java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar<br></code></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:8080/">http://localhost:8080</a> 页面，就可以看到 Sentinel 的控制台了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183712354.png" alt="image-20220520183712354"></p>
<p>账号和密码默认都是：sentinel</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183727720.png" alt="image-20220520183727720"></p>
<p>此时空白一片，还需要我们来整合进 SpringCloud</p>
<p>准备好我们的项目，在资料中，结构如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183803497.png" alt="image-20220520183803497"></p>
<p>我们在 order-service 中整合 Sentinel，并连接 Sentinel 的控制台，步骤如下</p>
<p>1）引入 Sentinel 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sentinel--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2）配置控制台</p>
<p>修改 application.yml 文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure>

<p>3）访问 order-service 的任意端点</p>
<p>打开浏览器，访问 <a href="http://localhost:10010/order/101%EF%BC%8C%E5%A4%9A%E8%AE%BF%E9%97%AE%E5%87%A0%E6%AC%A1%EF%BC%8C%E5%A4%9A%E7%82%B9%E5%87%A0%E6%AC%A1%E5%88%B7%E6%96%B0%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A6%E5%8F%91">http://localhost:10010/order/101，多访问几次，多点几次刷新，这样才能触发</a> Sentinel 的监控。</p>
<p>然后再访问 Sentinel 的控制台，查看效果。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183830014.png" alt="image-20220520183830014"></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>雪崩问题虽有四种方案，但是<strong>限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。</strong>学过毛中特的都知道，《预判风险所在是防范风险的前提》，我们先学习流量控制。</p>
<h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>当请求进入微服务时，首先会访问 DispatcherServlet，然后进入 Controller、Service、Mapper，这样的一个调用链就叫做 <strong>簇点链路</strong>。</p>
<p><strong>簇点链路中被监控的每一个接口就是一个资源</strong>。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点（Endpoint，也就是 Controller 中的方法），因此 SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源。</p>
<p>例如，我们刚才访问的 order-service 中的 OrderController 中的端点：/order/{orderId}</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183901596.png" alt="image-20220520183901596"></p>
<p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p>
<ul>
<li>流控：流量控制</li>
<li>降级：降级熔断</li>
<li>热点：热点参数限流，是限流的一种</li>
<li>授权：请求的权限控制</li>
</ul>
<p>点击资源 /order/{orderId} 后面的流控按钮，就可以弹出表单。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183920103.png" alt="image-20220520183920103"></p>
<p>表单中可以填写限流规则，如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183935131.png" alt="image-20220520183935131"></p>
<p>其含义是限制 /order/{orderId} 这个资源的单机 QPS 为 1，即每秒只允许 1 次请求，超出的请求会被拦截并报错。</p>
<blockquote>
<p>需求：给 /order/{orderId} 这个资源设置流控规则，QPS 不能超过 5，然后测试。</p>
</blockquote>
<p>1）首先在 sentinel 控制台添加限流规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183948014.png" alt="image-20220520183948014"></p>
<p>2）利用 jmeter 测试</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184005873.png" alt="image-20220520184005873"></p>
<p>20 个用户，2 秒内运行完，这样的话 QPS 就是 10，超过了我们在 sentinel 设置的 5</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184026072.png" alt="image-20220520184026072"></p>
<p>可以看到，成功的请求每次只有 5 个。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184048177.png" alt="image-20220520184048177"></p>
<h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong></p>
<h4 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h4><ul>
<li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式<ul>
<li>直接对当前资源限流</li>
</ul>
</li>
<li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流<ul>
<li>相当于高优先级资源触发阈值，对低优先级资源限流。</li>
</ul>
</li>
<li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流<ul>
<li>是针对请求来源的限流</li>
</ul>
</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184103693.png" alt="image-20220520184103693"></p>
<p>上面我们测试的就是直接模式，默认就是直接模式。</p>
<h4 id="关联模式"><a href="#关联模式" class="headerlink" title="关联模式"></a>关联模式</h4><p>统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。</p>
<p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184127009.png" alt="image-20220520184127009"></p>
<p>例如：配置规则，<strong>当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184142345.png" alt="image-20220520184142345"></p>
<p>我们去程序中模拟：</p>
<ul>
<li>在 OrderController 新建两个端点：/order/query 和 /order/update，无需实现业务</li>
<li>配置流控规则，当 /order/ update 资源被访问的 QPS 超过 5 时，对 /order/query 请求限流</li>
</ul>
<p>1）定义 /order/query 端点，模拟订单查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）定义 /order/update 端点，模拟订单更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;更新订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重启服务，查看 Sentinel 控制台的簇点链路。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184209929.png" alt="image-20220520184209929"></p>
<p>3）配置流控规则</p>
<p>想要对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询 /order/query 限流</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184223704.png" alt="image-20220520184223704"></p>
<p>在表单中填写流控规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184240617.png" alt="image-20220520184240617"></p>
<h4 id="链路模式"><a href="#链路模式" class="headerlink" title="链路模式"></a>链路模式</h4><p>只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p>
<p>例如有两条请求链路</p>
<ul>
<li>/test1 –&gt; /common</li>
<li>/test2 –&gt; /common</li>
</ul>
<p>如果只希望统计从 /test2 进入到 /common 的请求，则可以这样配置</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184302231.png" alt="image-20220520184302231"></p>
<p><strong>实战案例</strong></p>
<p>有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p>
<ol>
<li>在 OrderService 中添加一个 queryGoods 方法，不用实现业务</li>
<li>在 OrderController 中，改造 /order/query 端点，调用 OrderService 中的 queryGoods 方法</li>
<li>在 OrderController 中添加一个 /order/save 端点，调用 OrderService 的 queryGoods 方法</li>
<li>给 queryGoods 设置限流规则，从 /order/query 进入 queryGoods 的方法限制 QPS 必须小于 2</li>
</ol>
<p>1）添加查询商品方法</p>
<p>在order-service服务中，给 OrderService 类添加一个 queryGoods 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryGoods</span><span class="hljs-params">()</span></span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）查询订单时，查询商品</p>
<p>在 order-service 的 OrderController 中，修改 /order/query 端点的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;查询订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;  <br></code></pre></td></tr></table></figure>

<p>3）新增订单，查询商品</p>
<p>在 order-service 的 OrderController 中，修改 /order/save 端点，模拟新增订单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;新增订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;新增订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4）给查询商品添加资源标记</p>
<p>默认情况下，OrderService 中的方法是不被 Sentinel 监控的，需要我们自己通过注解来标记要监控的方法。</p>
<p>给 OrderService 的 queryGoods 方法添加 <code>@SentinelResource</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SentinelResource(&quot;goods&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryGoods</span><span class="hljs-params">()</span></span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>链路模式中，是对不同来源的两个链路做监控。但是 Sentinel 默认会给进入 SpringMVC 的所有请求设置同一个 root 资源，会导致链路模式失效。我们需要关闭这种对 SpringMVC 的资源聚合，修改 order-service 服务的 application.yml 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭context整合</span><br></code></pre></td></tr></table></figure>

<p>重启服务，访问 /order/query 和 /order/save，可以查看到 Sentinel 的簇点链路规则中，出现了新的资源</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184341995.png" alt="image-20220520184341995"></p>
<p>5）添加流控规则</p>
<p>点击 goods 资源后面的流控按钮，在弹出的表单中填写下面信息</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184356116.png" alt="image-20220520184356116"></p>
<p>只统计从 /order/query 进入 /goods 的资源，QPS 阈值为 2，超出则被限流。</p>
<h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><h3 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h3><p>细心的小伙伴会发现在流控的高级选项中，还有一个流控效果选项，前面我们的测试都是基本快速失败的。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184416829.png" alt="image-20220520184416829"></p>
<p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种</p>
<ul>
<li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出 FlowException 异常，是默认的处理方式。</li>
<li>Warm Up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</li>
<li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</li>
</ul>
<h3 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h3><p>阈值一般是一个微服务能承担的最大 QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将 QPS 跑到最大值，可能导致服务瞬间宕机。</p>
<p>Warm Up 也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值初始值是 <code>maxThreshold / coldFactor</code>，持续指定时长后，逐渐提高到 maxThreshold 值。而 coldFactor 的默认值是 3.</p>
<p>例如，我设置 QPS 的 maxThreshold 为 10，预热时间为 5 秒，那么初始阈值就是 10 / 3 = 3，然后在 5 秒后逐渐增长到 10</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184435351.png" alt="image-20220520184435351"></p>
<p><strong>案例</strong>：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用 Warm Up 效果，预热时长为 5 秒。</p>
<p>1）配置流控规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184540453.png" alt="image-20220520184540453"></p>
<p>用官方的话讲，该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p>
<h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p>当请求超过 QPS 阈值时，「快速失败」和 「Warm Up」会拒绝新的请求并抛出异常。</p>
<p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p>
<p>例如：QPS = 5，意味着每 200ms 处理一个队列中的请求；timeout = 2000，意味着<strong>预期等待时长</strong>超过 2000ms 的请求会被拒绝并抛出异常。</p>
<p>比如现在一下子来了 12 个请求，因为每 200ms 执行一个请求，那么预期等待时长就是：</p>
<ul>
<li>第6个请求的<strong>预期等待时长</strong> = 200 * (6 - 1) = 1000ms</li>
<li>第12个请求的预期等待时长 = 200 * (12-1) = 2200ms</li>
</ul>
<p>又比如下图：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184551503.png" alt="image-20220520184551503"></p>
<p>现在，第 1 秒同时接收到 10 个请求，但第 2 秒只有 1 个请求，此时 QPS 的曲线这样的</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184614143.png" alt="image-20220520184614143"></p>
<p>如果使用排队等待的流控效果，所有进入的请求都要排队，以固定的 200ms 的间隔执行，QPS 会变的很平滑</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184630104.png" alt="image-20220520184630104"></p>
<p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<p><strong>案例</strong>：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用排队等待的流控效果，超时时长设置为 5s</p>
<p>1）添加流控规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184650487.png" alt="image-20220520184650487"></p>
<h2 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而「热点参数限流」是<strong>分别统计参数值相同的请求</strong>，判断是否超过 QPS 阈值。</p>
<h3 id="全局参数限流"><a href="#全局参数限流" class="headerlink" title="全局参数限流"></a>全局参数限流</h3><p>例如，一个根据 id 查询商品的接口</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184712832.png" alt="image-20220520184712832"></p>
<p>访问 /goods/{id} 的请求中，id 参数值会有变化，「热点参数限流」会根据参数值分别统计 QPS，统计结果：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184725180.png" alt="image-20220520184725180"></p>
<p>当 id=1 的请求触发阈值被限流时，id值不为1的请求则不受影响。</p>
<p>配置示例：对 hot 这个资源的 0 号参数（也就是第一个参数）做统计，每 1s <strong>相同参数值</strong>的请求数不能超过 5</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184740039.png" alt="image-20220520184740039"></p>
<h3 id="热点参数限流-1"><a href="#热点参数限流-1" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>假设上面的例子是一个商品查询接口，那么刚才的配置中，对这个接口的所有商品一视同仁，QPS 都限定为 5</p>
<p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的 QPS 限制与其它商品不一样，高一些。那就需要配置「热点参数限流」的高级选项了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184755485.png" alt="image-20220520184755485"></p>
<p>结合上一个配置，这里的含义是对 0 号的 long 类型参数限流，每 1 个相同参数的 QPS 不能超过 5，有如下两个例外</p>
<ul>
<li>如果参数值是 100，则每 1s 允许的 QPS 为 10</li>
<li>如果参数值是 101，则每 1s 允许的 QPS 为 15</li>
</ul>
<p><strong>案例需求</strong>：给 /order/{orderId} 这个资源添加「热点参数限流」，规则如下</p>
<ul>
<li>默认的热点参数规则是每 1s 请求量不超过 2</li>
<li>给 102 这个参数设置例外：每 1s 请求量不超过 4</li>
<li>给 103 这个参数设置例外：每 1s 请求量不超过 10</li>
</ul>
<p><strong>注意事项</strong>：热点参数限流对默认的 SpringMVC 资源无效，需要利用 <code>@SentinelResource</code> 注解标记资源。</p>
<p>1）标记资源</p>
<p>给 order-service 中的 OrderController 中的 /order/{orderId} 资源添加注解</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184809515.png" alt="image-20220520184809515"></p>
<p>2）热点参数限流规则</p>
<p>访问该接口，可以看到我们标记的 hot 资源出现了</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184821804.png" alt="image-20220520184821804"></p>
<p>点击左侧菜单中<strong>热点规则</strong>菜单</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184835734.png" alt="image-20220520184835734"></p>
<p>点击左侧菜单中<strong>热点规则</strong>菜单</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184856244.png" alt="image-20220520184856244"></p>
<p>点击新增，填写表单</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184910985.png" alt="image-20220520184910985"></p>
<h2 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h2><p>限流只是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p>
<p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p>
<p><strong>线程隔离</strong>：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184930101.png" alt="image-20220520184930101"></p>
<p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184941897.png" alt="image-20220520184941897"></p>
<p>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong>发起远程调用时做线程隔离、或者服务熔断。</p>
<p>而我们的微服务远程调用都是基于 Feign 来完成的，因此我们需要将 Feign 与 Sentinel 整合，在 Feign 里面实现线程隔离和服务熔断。</p>
<h2 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel</h2><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合 Feign 和 Sentinel</p>
<p>修改配置，开启 Sentinel 功能，修改 OrderService 的 application.yml 文件，开启 Feign 的 Sentinel 功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对sentinel的支持</span><br></code></pre></td></tr></table></figure>

<p>服务降级：访问失败后，服务</p>
<p><strong>编写失败降级逻辑代码</strong>，业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p>
<p>给 FeignClient 编写失败后的降级逻辑</p>
<p>①方式一：FallbackClass，但无法对远程调用的异常做处理。</p>
<p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p>
<p>这里我们演示方式二的失败降级处理。</p>
<p><strong>步骤一</strong>：在 feing-api 项目中定义类，实现 FallbackFactory</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172651031.png" alt="image-20220521172651031"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xn2001.feign.clients.fallback;<br><br><span class="hljs-keyword">import</span> com.xn2001.feign.clients.UserClient;<br><span class="hljs-keyword">import</span> com.xn2001.feign.pojo.User;<br><span class="hljs-keyword">import</span> feign.hystrix.FallbackFactory;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/5/9 14:24</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserClientFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FallbackFactory</span>&lt;<span class="hljs-title">UserClient</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserClient <span class="hljs-title">create</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> userClient -&gt; &#123;<br>           log.error(<span class="hljs-string">&quot;查询用户失败&quot;</span>,throwable);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>       &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤二</strong>：在 feing-api 项目中的 DefaultFeignConfiguration 类中将 UserClientFallbackFactory 注册为一个Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserClientFallbackFactory <span class="hljs-title">userClientFallbackFactory</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserClientFallbackFactory();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤三</strong>：在 feing-api 项目中的 UserClient 接口中使用 UserClientFallbackFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重启后，访问一次订单查询业务，然后查看 Sentinel 控制台，可以看到新的簇点链路</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172853837.png" alt="image-20220521172853837"></p>
<h2 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h2><p>线程隔离（舱壁模式）有两种方式实现</p>
<ul>
<li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果。</li>
<li>信号量隔离（Sentinel默认采用）：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</li>
</ul>
<p>两者的优缺点</p>
<ul>
<li>线程池隔离：基于线程池模式，有额外开销，但隔离控制更强</li>
<li>信号量隔离：基于计数器模式，简单，开销小</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172910064.png" alt="image-20220521172910064"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172923462.png" alt="image-20220521172923462"></p>
<p><strong>Sentinel 使用的是信号量隔离</strong>，而 Hystrix 则两种线程隔离都可以，18 年Hystrix已经停止更新。</p>
<p>如何使用呢，在添加限流规则时，可以选择两种阈值类型</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173012300.png" alt="image-20220521173012300"></p>
<ul>
<li>QPS：就是每秒的请求数，之前已经演示过。</li>
<li>线程数：是该资源能使用的 Tomcat 线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</li>
</ul>
<p><strong>案例需求</strong>：给 order-service 服务中的 UserClient 的查询用户接口设置流控规则，线程数不能超过 2，然后利用 JMeter 测试。</p>
<p>1）配置隔离规则，选择 feign 接口后面的流控按钮</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173029388.png" alt="image-20220521173029388"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173038565.png" alt="image-20220521173038565"></p>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p>
<p>断路器控制熔断和放行是通过状态机来完成的，如下图就是一个断路器的状态机</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173059233.png" alt="image-20220521173059233"></p>
<p>状态机包括三个状态</p>
<ul>
<li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。会去判断是否达到熔断条件，这一步我们叫做「熔断策略」，达到该条件则切换到 open 状态，打开断路器。</li>
<li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open 状态 5 秒后会进入 half-open 状态。</li>
<li>half-open：半开状态，会一段时间放行一次请求，根据执行结果来判断接下来的操作。请求成功：则切换到 closed 状态；请求失败：则切换到 open 状态。</li>
</ul>
<p>断路器熔断策略有三种：慢调用、异常比例、异常数</p>
<h4 id="慢调用"><a href="#慢调用" class="headerlink" title="慢调用"></a>慢调用</h4><p>业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p>
<p>例如下图，设置 RT 超过 500ms 的调用是慢调用，统计最近 10000ms 内的请求，如果请求量超过 10 次，并且慢调用比例不低于 0.5，则触发熔断，熔断时长为 5s，然后进入 half-open 状态，放行一次请求做测试。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173115082.png" alt="image-20220521173115082"></p>
<p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，慢调用的 RT 阈值为 50ms，统计时间为 1s ，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s；</p>
<p>1）设置慢调用</p>
<p>修改 user-service 中的 /user/{id} 这个接口的业务。通过休眠模拟一个延迟时间。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173127987.png" alt="image-20220521173127987"></p>
<p>2）设置熔断规则</p>
<p>下面，给 feign 接口设置降级规则，超过 50ms 的请求都会被认为是慢请求。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173148541.png" alt="image-20220521173148541"></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p>
<p>例如，异常比例设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 0.4，则触发熔断。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173223974.png" alt="image-20220521173223974"></p>
<p>异常数设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 2 次，则触发熔断。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173239882.png" alt="image-20220521173239882"></p>
<p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，统计时间为 1s，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s</p>
<p>1）设置异常请求</p>
<p>首先，修改 user-service 中的 /user/{id} 这个接口的业务。手动抛出异常，以触发异常比例的熔断，也就是说，id 为 2时，就会触发异常。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173259839.png" alt="image-20220521173259839"></p>
<p>2）设置熔断规则</p>
<p>在 5 次请求中，只要异常比例超过 0.4，也就是有 2 次以上的异常，就会触发熔断。            </p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173314778.png" alt="image-20220521173314778"></p>
]]></content>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2022/08/12/Netty/</url>
    <content><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><blockquote>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
</blockquote>
<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>
<h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p>
<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>
</ul>
<p>Netty 对 API 进行增强，使之更易用，如</p>
<ul>
<li>FastThreadLocal =&gt; ThreadLocal</li>
<li>ByteBuf =&gt; ByteBuffer</li>
</ul>
<h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、启动器，负责装配netty组件，启动服务器</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                <span class="hljs-comment">// 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector</span><br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 3、选择服务器的 ServerSocketChannel 实现</span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">// 4、child 负责处理读写，该方法决定了 child 执行哪些操作</span><br>            	<span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>            	<span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf=&gt;String</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                        <span class="hljs-comment">// 6、SocketChannel的业务处理，使用上一个处理器的处理结果</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(s);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                    <span class="hljs-comment">// 7、ServerSocketChannel绑定8080端口</span><br>                &#125;).bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现</span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>                <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 编码发出</span><br>                        channel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 指定要连接的服务器和端口</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                <span class="hljs-comment">// Netty 中很多方法都是异步的，如 connect</span><br>                <span class="hljs-comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span><br>                .sync()<br>                <span class="hljs-comment">// 获取 channel 对象，它即为通道抽象，可以进行数据读写操作</span><br>                .channel()<br>                <span class="hljs-comment">// 写入消息并清空缓冲区</span><br>                .writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220218561.png" alt="image-20220812220218561"></p>
<h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul>
<li>channel 可以理解为数据的通道</li>
<li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>handler 可以理解为数据的处理工序<ul>
<li>工序有多道，<strong>合在一起就是 pipeline（传递途径）</strong>，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul>
<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>
</ul>
</li>
<li>handler 分 Inbound 和 Outbound 两类<ul>
<li>Inbound 入站</li>
<li>Outbound 出站</li>
</ul>
</li>
</ul>
</li>
<li>eventLoop 可以理解为处理数据的工人<ul>
<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>
<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>
</ul>
</li>
</ul>
<h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p>
<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>
<p>它的继承关系如下</p>
<ul>
<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>继承自 netty 自己的 OrderedEventExecutor<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p><strong>事件循环组</strong> EventLoopGroup</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEventLoop</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 通过next方法可以获得下一个 EventLoop</span><br>        System.out.println(group.next());<br>        System.out.println(group.next());<br><br>        <span class="hljs-comment">// 通过EventLoop执行普通任务</span><br>        group.next().execute(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过EventLoop执行定时任务</span><br>        group.next().scheduleAtFixedRate(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello2&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 优雅地关闭</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">io.netty.channel.nio.NioEventLoop@7bb11784<br>io.netty.channel.nio.NioEventLoop@33a10788<br>nioEventLoopGroup-2-1 hello<br>nioEventLoopGroup-2-2 hello2<br>nioEventLoopGroup-2-2 hello2<br>nioEventLoopGroup-2-2 hello2<br></code></pre></td></tr></table></figure>

<p><strong>关闭 EventLoopGroup</strong></p>
<p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br><br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        Channel channel = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                .sync()<br>                .channel();<br>        System.out.println(channel);<br>        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">public class MyServer &#123;<br>    public static void main(String[] args) &#123;<br>        new ServerBootstrap()<br>            	// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件<br>                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))<br>            <br>				...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>多个客户端分别发送 <code>hello</code> 结果</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">nioEventLoopGroup-3-1 hello1<br>nioEventLoopGroup-3-2 hello2<br>nioEventLoopGroup-3-1 hello3<br>nioEventLoopGroup-3-2 hello4<br>nioEventLoopGroup-3-2 hello4<br></code></pre></td></tr></table></figure>

<p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220458021.png" alt="image-20220812220458021"></p>
<h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 增加自定义的非NioEventLoopGroup</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> DefaultEventLoopGroup();<br>        <br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;nioHandler&quot;</span>,<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br>                                <span class="hljs-comment">// 调用下一个handler</span><br>                                ctx.fireChannelRead(msg);<br>                            &#125;<br>                        &#125;)<br>                        <span class="hljs-comment">// 该handler绑定自定义的Group</span><br>                        .addLast(group, <span class="hljs-string">&quot;myHandler&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动四个客户端发送数据</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">nioEventLoopGroup-4-1 hello1<br>defaultEventLoopGroup-2-1 hello1<br>nioEventLoopGroup-4-2 hello2<br>defaultEventLoopGroup-2-2 hello2<br>nioEventLoopGroup-4-1 hello3<br>defaultEventLoopGroup-2-3 hello3<br>nioEventLoopGroup-4-2 hello4<br>defaultEventLoopGroup-2-4 hello4<br></code></pre></td></tr></table></figure>

<p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220542209.png" alt="image-20220812220542209"></p>
<h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>
<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span><br>    EventExecutor executor = next.executor();<br>    <br>    <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span><br>        next.invokeChannelRead(m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span><br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>
</ul>
<h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p>
<ul>
<li>close() 可以用来关闭Channel</li>
<li>closeFuture() 用来处理 Channel 的关闭<ul>
<li>sync 方法作用是同步等待 Channel 关闭</li>
<li>而 addListener 方法是异步等待 Channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法用于添加处理器</li>
<li>write() 方法将数据写入<ul>
<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>
<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>
</ul>
</li>
<li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li>
</ul>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>            	<span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br>        <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>        channelFuture.sync();<br>        <br>        <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>        Channel channel = channelFuture.channel();<br>        channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p>
<p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>
<p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p>
<p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p>
<p><strong>addListener方法</strong></p>
<p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br>		<span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Channel channel = channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建EventLoopGroup，使用完毕后关闭</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        channelFuture.sync();<br><br>        Channel channel = channelFuture.channel();<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        <span class="hljs-comment">// 创建一个线程用于输入并向服务器发送</span><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                String msg = scanner.next();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(msg)) &#123;<br>                    <span class="hljs-comment">// 关闭操作是异步的，在NIO线程中执行</span><br>                    channel.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(msg);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;inputThread&quot;</span>).start();<br><br>        <span class="hljs-comment">// 获得closeFuture对象</span><br>        ChannelFuture closeFuture = channel.closeFuture();<br>        System.out.println(<span class="hljs-string">&quot;waiting close...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 同步等待NIO线程执行完close操作</span><br>        closeFuture.sync();<br>        <br>        <span class="hljs-comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span><br>        System.out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>关闭channel</strong></p>
<p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>
<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>
<ul>
<li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 获得closeFuture对象<br>ChannelFuture closeFuture = channel.closeFuture();<br><br>// 同步等待NIO线程执行完close操作<br>closeFuture.sync();<br></code></pre></td></tr></table></figure>
</li>
<li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">closeFuture.addListener(new ChannelFutureListener() &#123;<br>    @Override<br>    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;<br>        // 等待channel关闭后才执行的操作<br>        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);<br>        // 关闭EventLoopGroup<br>        group.shutdownGracefully();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p>
<p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkFuture</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;JdkFuture&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 创建线程池</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>), factory);<br><br>        <span class="hljs-comment">// 获得Future对象</span><br>        Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过阻塞的方式，获得运行结果</span><br>        System.out.println(future.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyFuture</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-comment">// 获得 EventLoop 对象</span><br>        EventLoop eventLoop = group.next();<br>        Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 主线程中获取结果</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.getNow());<br>        System.out.println(<span class="hljs-string">&quot;get &quot;</span> + future.get());<br><br>        <span class="hljs-comment">// NIO线程中异步获取结果</span><br>        future.addListener(<span class="hljs-keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="hljs-keyword">super</span> Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-keyword">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.getNow());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">main 获取结果<br>getNow null<br>get 50<br>nioEventLoopGroup-2-1 获取结果<br>getNow 50<br></code></pre></td></tr></table></figure>

<p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p>
<ul>
<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>
<li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>
<li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>
</ul>
<h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyPromise</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建EventLoop</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoop eventLoop = group.next();<br><br>        <span class="hljs-comment">// 创建Promise对象，用于存放结果</span><br>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 自定义线程向Promise中存放结果</span><br>            promise.setSuccess(<span class="hljs-number">50</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 主线程从Promise中获取结果</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + promise.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipeLineServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 在socketChannel的pipeline中添加handler</span><br>                        <span class="hljs-comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span><br>    				 	<span class="hljs-comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span><br>                        <span class="hljs-comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span><br>                        <span class="hljs-comment">// 入站时，handler是从head向后调用的</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler1&quot;</span> ,<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Inbound handler 1&quot;</span>);<br>                                <span class="hljs-comment">// 父类该方法内部会调用fireChannelRead</span><br>                                <span class="hljs-comment">// 将数据传递给下一个handler</span><br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Inbound handler 2&quot;</span>);<br>                                <span class="hljs-comment">// 执行write操作，使得Outbound的方法能够得到调用</span><br>          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="hljs-string">&quot;Server...&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span><br>                        <span class="hljs-comment">// 出站时，handler的调用是从tail向前调用的</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler3&quot;</span> ,<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Outbound handler 1&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler4&quot;</span> ,<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Outbound handler 2&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果如下</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">nioEventLoopGroup-2-2 Inbound handler 1<br>nioEventLoopGroup-2-2 Inbound handler 2<br>nioEventLoopGroup-2-2 Outbound handler 2<br>nioEventLoopGroup-2-2 Outbound handler 1<br></code></pre></td></tr></table></figure>

<p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>
<p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p>
<ul>
<li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul>
<li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li>
</ul>
</li>
<li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li>
<li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li>
</ul>
<p><strong>具体结构如下</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220802980.png" alt="image-20220812220802980"></p>
<p><strong>调用顺序如下</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220817795.png" alt="image-20220812220817795"></p>
<h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220842203.png" alt="image-20220812220842203"></p>
<h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220857626.png" alt="image-20220812220857626"></p>
<h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEmbeddedChannel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ChannelInboundHandlerAdapter h1 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        ChannelInboundHandlerAdapter h2 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h3 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h4 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 用于测试Handler的Channel</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(h1, h2, h3, h4);<br>        <br>        <span class="hljs-comment">// 执行Inbound操作 </span><br>        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">// 执行Outbound操作</span><br>        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(ByteBuf buffer)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = buffer.readableBytes();<br>    <span class="hljs-keyword">int</span> rows = length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>        .append(NEWLINE);<br>    appendPrettyHexDump(buf, buffer);<br>    System.out.println(buf.toString());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br><br>        <span class="hljs-comment">// 查看写入结果</span><br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">read index:0 write index:0 capacity:16<br><br>read index:0 write index:20 capacity:64<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|<br>|00000010| 61 61 61 61                                     |aaaa            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p>
<p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p>
<p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p>
<h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure>

<p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure>

<p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<p><strong>验证</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br><br>        buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br><br>        buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeDirectByteBuf</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">// 使用池化的堆内存    </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeHeapByteBuf</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">// 使用池化的直接内存    </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeDirectByteBuf</span></span><br></code></pre></td></tr></table></figure>

<h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p>
<ul>
<li><p>最大容量与当前容量</p>
<ul>
<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>
<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li>
</ul>
</li>
<li><p>读写操作不同于ByteBuffer只用position进行控制，</p>
<p>ByteBuf分别由读指针和写指针两个指针控制</p>
<p>。进行读写操作时，无需进行模式的切换</p>
<ul>
<li>读指针前的部分被称为废弃部分，是已经读过的内容</li>
<li>读指针与写指针之间的空间称为可读部分</li>
<li>写指针与当前容量之间的空间称为可写部分</li>
</ul>
</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220939175.png" alt="image-20220812220939175"></p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td><strong>用一字节 01|00 代表 true|false</strong></td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 <strong>ByteBuffer</strong></td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li>
<li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li>
</ul>
</blockquote>
<p><strong>使用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeInt(<span class="hljs-number">5</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeIntLE(<span class="hljs-number">6</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeLong(<span class="hljs-number">7</span>);<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">read index:0 write index:0 capacity:16<br><br>read index:0 write index:4 capacity:16<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:0 write index:8 capacity:16<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:0 write index:12 capacity:16<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:0 write index:20 capacity:20<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br>|00000010| 00 00 00 07                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">buffer.writeLong(7);<br>ByteBufUtil.log(buffer);<br>// 扩容前<br>read index:0 write index:12 capacity:16<br>...<br><br>// 扩容后<br>read index:0 write index:20 capacity:20<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br>|00000010| 00 00 00 07                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<h4 id="扩容规则te"><a href="#扩容规则te" class="headerlink" title="扩容规则te"></a>扩容规则te</h4><ul>
<li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p>
<ul>
<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li>
</ul>
</li>
<li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p>
<p>n</p>
<ul>
<li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li>
</ul>
</li>
<li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20/20)<br>...<br></code></pre></td></tr></table></figure>

<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p>
<p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        buffer.writeInt(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 读取4个字节</span><br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 通过mark与reset实现重复读取</span><br>        buffer.markReaderIndex();<br>        System.out.println(buffer.readInt());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 恢复到mark标记处</span><br>        buffer.resetReaderIndex();<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">5</span><br>read index:<span class="hljs-number">8</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p>
<ul>
<li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p>
</li>
<li><p>入站 ByteBuf 处理原则</p>
<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li>
<li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>
<li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li>
<li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li><p>出站 ByteBuf 处理原则</p>
<ul>
<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li>
</ul>
</li>
<li><p>异常处理原则</p>
<ul>
<li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">while (!buffer.release()) &#123;&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p>
<p><strong>TailConext中释放ByteBuf的源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 具体的释放方法</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>判断传过来的是否为ByteBuf，是的话才需要释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p>
<p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221019762.png" alt="image-20220812221019762"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSlice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        ByteBuf slice1 = buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        ByteBuf slice2 = buffer.slice(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.retain();<br>        slice2.retain();<br>        <br>        ByteBufUtil.log(slice1);<br>        ByteBufUtil.log(slice2);<br><br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.println(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.setByte(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        ByteBufUtil.log(slice1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">read index:0 write index:5 capacity:5<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 05                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br>read index:0 write index:5 capacity:5<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 06 07 08 09 0a                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:0 write index:5 capacity:5<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 05 02 03 04 05                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以<strong>自动扩容</strong></li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如<ul>
<li>slice、duplicate、CompositeByteBuf</li>
</ul>
</li>
</ul>
<h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接建立时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接断开时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stopped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> StudyServer().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">public class StudyClient &#123;<br>    static final Logger log = LoggerFactory.getLogger(StudyClient.class);<br>    public static void main(String[] args) &#123;<br>        NioEventLoopGroup worker = new NioEventLoopGroup();<br>        try &#123;<br>            Bootstrap bootstrap = new Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                @Override<br>                protected void initChannel(SocketChannel ch) throws Exception &#123;<br>                    log.debug(&quot;connected...&quot;);<br>                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;<br>                        @Override<br>                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;<br>                            log.debug(&quot;sending...&quot;);<br>                            // 每次发送16个字节的数据，共发送10次<br>                            for (int i = 0; i &lt; 10; i++) &#123;<br>                                ByteBuf buffer = ctx.alloc().buffer();<br>                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; catch (InterruptedException e) &#123;<br>            log.error(&quot;client error&quot;, e);<br>        &#125; finally &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>服务器接收结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:/127.0.0.1:8080 - R:/127.0.0.1:53797] READ: 160B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p>
<h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p>
<p><strong>服务器代码</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 调整channel的容量<br>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p>
</blockquote>
<p><strong>服务器接收结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 36B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000020| 00 01 02 03                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000020| 04 05 06 07 08 09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br>|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br>|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000020| 04 05 06 07 08 09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 4B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 0c 0d 0e 0f                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p>
<h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul>
<li>现象<ul>
<li>发送 abc def，接收 abcdef</li>
</ul>
</li>
<li>原因<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul>
<li>现象<ul>
<li>发送 abcdef，接收 abc def</li>
</ul>
</li>
<li>原因<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 小于实际发送数据量</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>
</ul>
</li>
<li>数据链路层<ul>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p>
<p><strong>客户端代码改进</strong></p>
<p>修改channelActive方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>    ByteBuf buffer = ctx.alloc().buffer(<span class="hljs-number">16</span>);<br>    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>    ctx.writeAndFlush(buffer);<br>    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span><br>    ctx.channel().close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送10次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        send();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] ACTIVE<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 ! R:/127.0.0.1:65024] INACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] ACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 ! R:/127.0.0.1:65057] INACTIVE<br><br>...<br></code></pre></td></tr></table></figure>

<p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p>
<h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p>
<p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<br></code></pre></td></tr></table></figure>

<p><strong>客户端代码</strong></p>
<p>客户端发送数据的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为16</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 向服务器发送10个报文</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>    <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span><br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[maxLength];<br>    <span class="hljs-comment">// 生成长度为0~15的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(Math.random()*(maxLength-<span class="hljs-number">1</span>)); j++) &#123;<br>        bytes[j] = (<span class="hljs-keyword">byte</span>) c;<br>    &#125;<br>    buffer.writeBytes(bytes);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.writeAndFlush(buffer);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>服务器代码</strong></p>
<p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 通过定长解码器对粘包数据进行拆分<br>ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<br>ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|<br>+--------+-------------------------------------------------+----------------+<br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|<br>+--------+-------------------------------------------------+----------------+<br><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure>

<h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p>
<p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)**为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）**</p>
<p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p>
<p><strong>以换行符 \n 为分隔符</strong></p>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为 64</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">64</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>    <span class="hljs-comment">// 生成长度为0~62的数据</span><br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(random.nextInt(maxLength-<span class="hljs-number">2</span>)); j++) &#123;<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-comment">// 数据以 \n 结尾</span><br>    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.writeAndFlush(buffer);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务器代码</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 通过行解码器对粘包数据进行拆分，以 <span class="hljs-tag">\<span class="hljs-name">n</span></span> 为分隔符<br>// 需要指定最大长度<br>ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));<br>ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 10B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |<br>+--------+-------------------------------------------------+----------------+<br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 11B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |<br>+--------+-------------------------------------------------+----------------+<br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 2B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 63 63                                           |cc              |<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure>

<p><strong>以自定义分隔符 \c 为分隔符</strong></p>
<p>客户端代码</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">...<br>    <br>// 数据以 <span class="hljs-tag">\<span class="hljs-name">c</span></span> 结尾<br>sb.append(&quot;<span class="hljs-tag">\<span class="hljs-name">\</span></span>c&quot;);<br>buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br><br>...<br></code></pre></td></tr></table></figure>

<p>服务器代码</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 将分隔符放入ByteBuf中<br>ByteBuf bufSet = ch.alloc().buffer().writeBytes(&quot;<span class="hljs-tag">\<span class="hljs-name">\</span></span>c&quot;.getBytes(StandardCharsets.UTF_8));<br>// 通过行解码器对粘包数据进行拆分，以 <span class="hljs-tag">\<span class="hljs-name">c</span></span> 为分隔符<br>ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));<br>ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 14B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |<br>+--------+-------------------------------------------------+----------------+<br><br><br>8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 3B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 62 62 62                                        |bbb             |<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure>

<h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p>
<p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> maxFrameLength,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> lengthFieldOffset, <span class="hljs-keyword">int</span> lengthFieldLength,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> lengthAdjustment, <span class="hljs-keyword">int</span> initialBytesToStrip)</span></span><br></code></pre></td></tr></table></figure>

<p><strong>参数解析</strong></p>
<ul>
<li>maxFrameLength 数据最大长度<ul>
<li>表示数据的最大长度（包括附加信息、长度标识等内容）</li>
</ul>
</li>
<li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul>
<li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li>
</ul>
</li>
<li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul>
<li>数据中用于表示有用数据长度的标识所占的字节数</li>
</ul>
</li>
<li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul>
<li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li>
</ul>
</li>
<li>initialBytesToStrip <strong>数据读取起点</strong><ul>
<li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li>
</ul>
</li>
</ul>
<p><strong>参数图解</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221105822.png" alt="image-20220812221105822"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs TEX">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0 (= do not strip header)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br>+--------+----------------+      +--------+----------------+<br>| Length | Actual Content |-----&gt;| Length | Actual Content |<br>| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |<br>+--------+----------------+      +--------+----------------+<br></code></pre></td></tr></table></figure>

<p>从0开始即为长度标识，长度标识长度为2个字节</p>
<p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p>
<hr>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 2 (= the length of the Length field)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)<br>+--------+----------------+      +----------------+<br>| Length | Actual Content |-----&gt;| Actual Content |<br>| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |<br>+--------+----------------+      +----------------+<br></code></pre></td></tr></table></figure>

<p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p>
<p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p>
<hr>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 2 (= the length of Header 1)<br>lengthFieldLength   = 3<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |<br>|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure>

<p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p>
<p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p>
<hr>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 0<br>lengthFieldLength   = 3<br>lengthAdjustment    = 2 (= the length of Header 1)<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |<br>| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure>

<p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p>
<p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p>
<hr>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 1 (= the length of HDR1)<br>lengthFieldLength   = 2<br>lengthAdjustment    = 1 (= the length of HDR2)<br>initialBytesToStrip = 3 (= the length of HDR1 + LEN)<br>  <br>BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br>+------+--------+------+----------------+      +------+----------------+<br>| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |<br>| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |<br>+------+--------+------+----------------+      +------+----------------+<br></code></pre></td></tr></table></figure>

<p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p>
<hr>
<p><strong>使用</strong></p>
<p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncoderStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟服务器</span><br>        <span class="hljs-comment">// 使用EmbeddedChannel测试handler</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<br>                <span class="hljs-comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span><br>                <span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>                <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG)<br>        );<br><br>        <span class="hljs-comment">// 模拟客户端，写入数据</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();<br>        send(buffer, <span class="hljs-string">&quot;Hello&quot;</span>);<br>        channel.writeInbound(buffer);<br>        send(buffer, <span class="hljs-string">&quot;World&quot;</span>);<br>        channel.writeInbound(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ByteBuf buf, String msg)</span> </span>&#123;<br>        <span class="hljs-comment">// 得到数据的长度</span><br>        <span class="hljs-keyword">int</span> length = msg.length();<br>        <span class="hljs-keyword">byte</span>[] bytes = msg.getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-comment">// 将数据信息写入buf</span><br>        <span class="hljs-comment">// 写入长度标识前的其他信息</span><br>        buf.writeByte(<span class="hljs-number">0xCA</span>);<br>        <span class="hljs-comment">// 写入数据长度标识</span><br>        buf.writeInt(length);<br>        <span class="hljs-comment">// 写入长度标识后的其他信息</span><br>        buf.writeByte(<span class="hljs-number">0xFE</span>);<br>        <span class="hljs-comment">// 写入具体的数据</span><br>        buf.writeBytes(bytes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |<br>+--------+-------------------------------------------------+----------------+<br><br>146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p>
<p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p>
<h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 该指令一共有3部分，每条指令之后都要添加回车与换行符<br>*3<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><br>// 第一个指令的长度是3<br><span class="hljs-formula">$3<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br><span class="hljs-formula">// 第一个指令是set指令</span><br><span class="hljs-formula">set<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br><span class="hljs-formula">// 下面的指令以此类推</span><br><span class="hljs-formula">$</span>4<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><br>name<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><br><span class="hljs-formula">$5<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br><span class="hljs-formula">Nyima<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br></code></pre></td></tr></table></figure>

<p><strong>客户端代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group =  <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                    .group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            <span class="hljs-comment">// 打印日志</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    <span class="hljs-comment">// 回车与换行符</span><br>                                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] LINE = &#123;<span class="hljs-string">&#x27;\r&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>&#125;;<br>                                    <span class="hljs-comment">// 获得ByteBuf</span><br>                                    ByteBuf buffer = ctx.alloc().buffer();<br>                                    <span class="hljs-comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span><br>                                    <span class="hljs-comment">// set name Nyima</span><br>                                    buffer.writeBytes(<span class="hljs-string">&quot;*3&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;set&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$4&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;name&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$5&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;Nyima&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    ctx.writeAndFlush(buffer);<br>                                &#125;<br><br>                            &#125;);<br>                        &#125;<br>                    &#125;)<br>                    .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>));<br>            channelFuture.sync();<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().close().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭group</span><br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>控制台打印结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:/127.0.0.1:60792 - R:localhost/127.0.0.1:6379] WRITE: 34B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..<span class="hljs-formula">$3..set..$</span>4.|<br>|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..<span class="hljs-formula">$5..Nyima|</span><br><span class="hljs-formula">|00000020| 0d 0a                                           |..              |</span><br><span class="hljs-formula">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure>

<p><strong>Redis中查询执行结果</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span><br><span class="hljs-comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpServerUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span></span><br></code></pre></td></tr></table></figure>

<p><strong>服务器代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(group)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                        <span class="hljs-comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec());<br>                        <span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpRequest msg)</span> </span>&#123;<br>                                <span class="hljs-comment">// 获得请求uri</span><br>                                log.debug(msg.uri());<br><br>                                <span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>                                DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);<br>                                <span class="hljs-comment">// 设置响应内容</span><br>                                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>                                <span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>                                response.headers().setInt(CONTENT_LENGTH, bytes.length);<br>                                <span class="hljs-comment">// 设置响应体</span><br>                                response.content().writeBytes(bytes);<br><br>                                <span class="hljs-comment">// 写回响应</span><br>                                ctx.writeAndFlush(response);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;()<br></code></pre></td></tr></table></figure>

<p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);<br><span class="hljs-comment">// 设置响应内容</span><br><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);<br><span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>response.headers().setInt(CONTENT_LENGTH, bytes.length);<br><span class="hljs-comment">// 设置响应体</span><br>response.content().writeBytes(bytes);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>浏览器</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221229452.png" alt="image-20220812221229452"></p>
<p>控制台</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 请求内容<br>1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] READ: 688B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET /favicon.ico|<br>|00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP/1.1..Host:|<br>|00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.|<br>|00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee|<br>|00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|<br>....<br><br>// 响应内容<br>1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] WRITE: 61B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP/1.1 200 OK.|<br>|00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:|<br>|00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello|<br>|00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;/h1&gt;   |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul>
<li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p>
</li>
<li><p><strong>版本号</strong>：可以支持协议的升级</p>
</li>
<li><p>序列化算法</p>
<p>：消息正文到底采用哪种序列化反序列化方式</p>
<ul>
<li>如：json、protobuf、hessian、jdk</li>
</ul>
</li>
<li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p>
</li>
<li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p>
</li>
<li><p><strong>正文长度</strong></p>
</li>
<li><p><strong>消息正文</strong></p>
</li>
</ul>
<h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 设置魔数 4个字节</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;N&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>&#125;);<br>        <span class="hljs-comment">// 设置版本号 1个字节</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置序列化方式 1个字节</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置指令类型 1个字节</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 设置请求序号 4个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 为了补齐为16个字节，填充1个字节的数据</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br><br>        <span class="hljs-comment">// 获得序列化后的msg</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>        oos.writeObject(msg);<br>        <span class="hljs-keyword">byte</span>[] bytes = bos.toByteArray();<br><br>        <span class="hljs-comment">// 获得并设置正文长度 长度用4个字节标识</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 设置消息正文</span><br>        out.writeBytes(bytes);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取魔数</span><br>        <span class="hljs-keyword">int</span> magic = in.readInt();<br>        <span class="hljs-comment">// 获取版本号</span><br>        <span class="hljs-keyword">byte</span> version = in.readByte();<br>        <span class="hljs-comment">// 获得序列化方式</span><br>        <span class="hljs-keyword">byte</span> seqType = in.readByte();<br>        <span class="hljs-comment">// 获得指令类型</span><br>        <span class="hljs-keyword">byte</span> messageType = in.readByte();<br>        <span class="hljs-comment">// 获得请求序号</span><br>        <span class="hljs-keyword">int</span> sequenceId = in.readInt();<br>        <span class="hljs-comment">// 移除补齐字节</span><br>        in.readByte();<br>        <span class="hljs-comment">// 获得正文长度</span><br>        <span class="hljs-keyword">int</span> length = in.readInt();<br>        <span class="hljs-comment">// 获得正文</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));<br>        Message message = (Message) ois.readObject();<br>		<span class="hljs-comment">// 将信息放入List中，传递给下一个handler</span><br>        out.add(message);<br>        <br>        <span class="hljs-comment">// 打印获得的信息正文</span><br>        System.out.println(<span class="hljs-string">&quot;===========魔数===========&quot;</span>);<br>        System.out.println(magic);<br>        System.out.println(<span class="hljs-string">&quot;===========版本号===========&quot;</span>);<br>        System.out.println(version);<br>        System.out.println(<span class="hljs-string">&quot;===========序列化方法===========&quot;</span>);<br>        System.out.println(seqType);<br>        System.out.println(<span class="hljs-string">&quot;===========指令类型===========&quot;</span>);<br>        System.out.println(messageType);<br>        System.out.println(<span class="hljs-string">&quot;===========请求序号===========&quot;</span>);<br>        System.out.println(sequenceId);<br>        System.out.println(<span class="hljs-string">&quot;===========正文长度===========&quot;</span>);<br>        System.out.println(length);<br>        System.out.println(<span class="hljs-string">&quot;===========正文===========&quot;</span>);<br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p>
</li>
<li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p>
</li>
</ul>
<p><strong>编写测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCodec</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.slf4j.Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel();<br>        <span class="hljs-comment">// 添加解码器，避免粘包半包问题</span><br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> MessageCodec());<br>        LoginRequestMessage user = <span class="hljs-keyword">new</span> LoginRequestMessage(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-comment">// 测试编码与解码</span><br>        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();<br>        <span class="hljs-keyword">new</span> MessageCodec().encode(<span class="hljs-keyword">null</span>, user, byteBuf);<br>        channel.writeInbound(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li>
<li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li>
</ul>
<p>运行结果</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221252096.png" alt="image-20220812221252096"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221305651.png" alt="image-20220812221305651"></p>
<h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br><span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span><br>channel1.pipeline().addLast(loggingHandler);<br>channel2.pipeline().addLast(loggingHandler);<br></code></pre></td></tr></table></figure>

<p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p>
<ul>
<li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li>
<li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li>
</ul>
<p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p>
<p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p>
<h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p>
<p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p>
<p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p>
<ul>
<li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221329549.png" alt="image-20220812221329549"></p>
</li>
<li><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p>
<ul>
<li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li>
</ul>
</li>
</ul>
<p><strong>如果想要共享，需要怎么办呢？</strong></p>
<p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">ByteBuf</span>, <span class="hljs-title">Message</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Session</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Channel channel, String username)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">(Channel channel)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(Channel channel, String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(Channel channel, String name, Object value)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Channel <span class="hljs-title">getChannel</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GroupSession</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">createGroup</span><span class="hljs-params">(String name, Set&lt;String&gt; members)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">joinMember</span><span class="hljs-params">(String name, String member)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">removeMember</span><span class="hljs-params">(String name, String member)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">removeGroup</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Set&lt;String&gt; <span class="hljs-title">getMembers</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Channel&gt; <span class="hljs-title">getMembersChannel</span><span class="hljs-params">(String name)</span></span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断群聊是否一被创建</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 群聊名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCreated</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221410021.png" alt="image-20220812221410021"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221418916.png" alt="image-20220812221418916"></p>
<ul>
<li>client包：存放客户端相关类</li>
<li>message包：存放各种类型的消息</li>
<li>protocol包：存放自定义协议</li>
<li>server包：存放服务器相关类<ul>
<li>service包：存放用户相关类</li>
<li>session包：单聊及群聊相关会话类</li>
</ul>
</li>
</ul>
<h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatClient.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group);<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect().sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(boss, worker);<br>            bootstrap.channel(NioServerSocketChannel.class);<br>            bootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建连接时执行的处理器，用于执行登陆操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 开辟额外线程，用于用户登陆及后续操作</span><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br>            String username = scanner.next();<br>            System.out.println(<span class="hljs-string">&quot;请输入密码&quot;</span>);<br>            String password = scanner.next();<br>            <span class="hljs-comment">// 创建包含登录信息的请求体</span><br>            LoginRequestMessage message = <span class="hljs-keyword">new</span> LoginRequestMessage(username, password);<br>            <span class="hljs-comment">// 发送到channel中</span><br>            ctx.writeAndFlush(message);<br>            System.out.println(<span class="hljs-string">&quot;等待后续操作...&quot;</span>);<br>            <span class="hljs-comment">// 阻塞，直到登陆成功后CountDownLatch被设置为0</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                waitLogin.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 执行后续操作</span><br>            <span class="hljs-keyword">if</span> (!loginStatus.get()) &#123;<br>                <span class="hljs-comment">// 登陆失败，关闭channel并返回</span><br>                ctx.channel().close();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 登录成功后，执行其他操作</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                String command = scanner.nextLine();<br>                <span class="hljs-comment">// 获得指令及其参数，并发送对应类型消息</span><br>                String[] commands = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                <span class="hljs-keyword">switch</span> (commands[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatRequestMessage(username, commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gsend&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatRequestMessage(username,commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                        <span class="hljs-comment">// 分割，获得群员名</span><br>                        String[] members = commands[<span class="hljs-number">2</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>                        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(members));<br>                        <span class="hljs-comment">// 把自己加入到群聊中</span><br>                        set.add(username);<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateRequestMessage(commands[<span class="hljs-number">1</span>],set));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersRequestMessage(commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinRequestMessage(username, commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gquit&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitRequestMessage(username, commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>                        ctx.channel().close();<br>                        <span class="hljs-keyword">return</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        System.out.println(<span class="hljs-string">&quot;指令有误，请重新输入&quot;</span>);<br>                        <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;login channel&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> LoginResponseMessage) &#123;<br>            <span class="hljs-comment">// 如果是登录响应信息</span><br>            LoginResponseMessage message = (LoginResponseMessage) msg;<br>            <span class="hljs-keyword">boolean</span> isSuccess = message.isSuccess();<br>            <span class="hljs-comment">// 登录成功，设置登陆标记</span><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                loginStatus.set(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// 登陆后，唤醒登陆线程</span><br>            waitLogin.countDown();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LoginRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得登录信息</span><br>        String username = msg.getUsername();<br>        String password = msg.getPassword();<br>        <span class="hljs-comment">// 校验登录信息</span><br>        <span class="hljs-keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);<br>        LoginResponseMessage message;<br>        <span class="hljs-keyword">if</span> (login) &#123;<br>            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            <span class="hljs-comment">// 绑定channel与user</span><br>            SessionFactory.getSession().bind(ctx.channel(), username);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;登陆失败&quot;</span>);<br>        &#125;<br>        ctx.writeAndFlush(message);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理登录请求</span><br>LoginRequestMessageHandler loginRequestMessageHandler = <span class="hljs-keyword">new</span> LoginRequestMessageHandler();<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoginRequestMessageHandler());<br></code></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">5665 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 1, 0, 279<br>5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success=true, reason=&#x27;登陆成功&#x27;&#125;<br>5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;登陆成功&#x27;&#125;<br>success<br></code></pre></td></tr></table></figure>

<p><strong>服务器</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 217<br>11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username=&#x27;Nyima&#x27;, password=&#x27;123&#x27;&#125;<br><br>7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:/127.0.0.1:8080 - R:/127.0.0.1:60572] WRITE: 295B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 4e 59 49 4d 01 01 01 00 00 00 00 ff 00 00 01 17 |NYIM............|<br>|00000010| ac ed 00 05 73 72 00 31 63 6e 2e 6e 79 69 6d 61 |....sr.1cn.nyima|<br>|00000020| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes|<br>|00000030| 73 61 67 65 2e 4c 6f 67 69 6e 52 65 73 70 6f 6e |sage.LoginRespon|<br>|00000040| 73 65 4d 65 73 73 61 67 65 e2 34 49 24 72 52 f3 |seMessage.4I<span class="hljs-formula">$rR.|</span><br><span class="hljs-formula">|00000050| 07 02 00 00 78 72 00 34 63 6e 2e 6e 79 69 6d 61 |....xr.4cn.nyima|</span><br><span class="hljs-formula">|00000060| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes|</span><br><span class="hljs-formula">|00000070| 73 61 67 65 2e 41 62 73 74 72 61 63 74 52 65 73 |sage.AbstractRes|</span><br><span class="hljs-formula">|00000080| 70 6f 6e 73 65 4d 65 73 73 61 67 65 b3 7e 19 32 |ponseMessage.~.2|</span><br><span class="hljs-formula">|00000090| 9b 88 4d 7b 02 00 02 5a 00 07 73 75 63 63 65 73 |..M&#123;...Z..succes|</span><br><span class="hljs-formula">|000000a0| 73 4c 00 06 72 65 61 73 6f 6e 74 00 12 4c 6a 61 |sL..reasont..Lja|</span><br><span class="hljs-formula">|000000b0| 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 78 |va/lang/String;x|</span><br><span class="hljs-formula">|000000c0| 72 00 24 63 6e 2e 6e 79 69 6d 61 63 2e 73 74 75 |r.$</span>cn.nyimac.stu|<br>|000000d0| 64 79 2e 64 61 79 38 2e 6d 65 73 73 61 67 65 2e |dy.day8.message.|<br>|000000e0| 4d 65 73 73 61 67 65 dd e9 84 b7 21 db 18 52 02 |Message....!..R.|<br>|000000f0| 00 02 49 00 0b 6d 65 73 73 61 67 65 54 79 70 65 |..I..messageType|<br>|00000100| 49 00 0a 73 65 71 75 65 6e 63 65 49 64 78 70 00 |I..sequenceIdxp.|<br>|00000110| 00 00 00 00 00 00 00 01 74 00 0c e7 99 bb e9 99 |........t.......|<br>|00000120| 86 e6 88 90 e5 8a 9f                            |.......         |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure>

<h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ChatRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得user所在的channel</span><br>        Channel channel = SessionFactory.getSession().getChannel(msg.getTo());<br>        <span class="hljs-comment">// 如果双方都在线</span><br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 通过接收方与服务器之间的channel发送信息</span><br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通过发送方与服务器之间的channel发送消息</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;对方用户不存在或离线，发送失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理单聊请求</span><br>ChatRequestMessageHandler chatRequestMessageHandler = <span class="hljs-keyword">new</span> ChatRequestMessageHandler();<br>ch.pipeline().addLast(chatRequestMessageHandler);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>发送方（zhangsan）</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">send Nyima hello<br></code></pre></td></tr></table></figure>

<p>接收方（Nyima）</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 收到zhangsan发来的消息<br>20230 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from=&#x27;zhangsan&#x27;, content=&#x27;hello&#x27;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupCreateMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupCreateRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得要创建的群聊名</span><br>        String groupName = msg.getGroupName();<br>        <span class="hljs-comment">// 获得要创建的群聊的成员组</span><br>        Set&lt;String&gt; members = msg.getMembers();<br>        <span class="hljs-comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span><br>        Group group = GroupSessionFactory.getGroupSession().createGroup(groupName, members);<br>        <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 发送创建成功消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, groupName + <span class="hljs-string">&quot;创建成功&quot;</span>);<br>            ctx.writeAndFlush(groupCreateResponseMessage);<br>            <span class="hljs-comment">// 获得在线群员的channel，给群员发送入群聊消息</span><br>            List&lt;Channel&gt; membersChannel = GroupSessionFactory.getGroupSession().getMembersChannel(groupName);<br>            groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span>+groupName);<br>            <span class="hljs-comment">// 给每个在线群员发送消息</span><br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.writeAndFlush(groupCreateResponseMessage);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 发送失败消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">false</span>, groupName + <span class="hljs-string">&quot;已存在&quot;</span>);<br>            ctx.writeAndFlush(groupCreateResponseMessage);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理创建群聊请求</span><br>GroupCreateMessageHandler groupCreateMessageHandler = <span class="hljs-keyword">new</span> GroupCreateMessageHandler();<br>ch.pipeline().addLast(groupCreateMessageHandler);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>创建者客户端</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">// 首次创建<br>gcreate Netty学习 zhangsan,lisi<br><br>31649 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;Netty学习创建成功&#x27;&#125;<br>15244 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;您已被拉入Netty学习&#x27;&#125;<br><br><br>// 再次创建<br>gcreate Netty学习 zhangsan,lisi<br>40771 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;Netty学习已存在&#x27;&#125;<br></code></pre></td></tr></table></figure>

<p>群员客户端</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">28788 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;您已被拉入Netty学习&#x27;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupChatRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String groupName = msg.getGroupName();<br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断群聊是否存在</span><br>        <span class="hljs-keyword">boolean</span> isCreated = groupSession.isCreated(groupName);<br>        <span class="hljs-keyword">if</span> (isCreated) &#123;<br>            <span class="hljs-comment">// 给群员发送信息</span><br>            List&lt;Channel&gt; membersChannel = groupSession.getMembersChannel(groupName);<br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;群聊不存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理群聊聊天</span><br>GroupChatMessageHandler groupChatMessageHandler = <span class="hljs-keyword">new</span> GroupChatMessageHandler();<br>ch.pipeline().addLast(groupChatMessageHandler);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>发送方（群聊存在）</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">gsend Netty学习 你们好<br><br>45408 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=&#x27;zhangsan&#x27;, content=&#x27;你们好&#x27;&#125;<br></code></pre></td></tr></table></figure>

<p>接收方</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">48082 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=&#x27;zhangsan&#x27;, content=&#x27;你们好&#x27;&#125;<br></code></pre></td></tr></table></figure>

<p>发送方（群聊不存在）t</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">gsend Spring学习 你们好<br><br>25140 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;群聊不存在&#x27;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupJoinMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupJoinRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断该用户是否在群聊中</span><br>        Set&lt;String&gt; members = groupSession.getMembers(msg.getGroupName());<br>        <span class="hljs-keyword">boolean</span> joinFlag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span><br>        <span class="hljs-keyword">if</span> (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;<br>            joinFlag = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 加入群聊</span><br>            groupSession.joinMember(msg.getGroupName(), msg.getUsername());<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;加入&quot;</span>+msg.getGroupName()+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理加入群聊</span><br>GroupJoinMessageHandler groupJoinMessageHandler = <span class="hljs-keyword">new</span> GroupJoinMessageHandler();<br>ch.pipeline().addLast(groupJoinMessageHandler);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>正常加入群聊</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">94921 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;加入Netty学习成功&#x27;&#125;<br></code></pre></td></tr></table></figure>

<p>加入不能存在或已加入的群聊</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">44025 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;加入失败，群聊未存在或您已加入该群聊&#x27;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupQuitMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupQuitRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        String groupName = msg.getGroupName();<br>        Set&lt;String&gt; members = groupSession.getMembers(groupName);<br>        String username = msg.getUsername();<br>        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在</span><br>        <span class="hljs-keyword">boolean</span> joinFlag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;<br>            <span class="hljs-comment">// 可以退出</span><br>            joinFlag = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 退出成功</span><br>            groupSession.removeMember(groupName, username);<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;退出&quot;</span>+groupName+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退出失败</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+groupName+<span class="hljs-string">&quot;失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理退出群聊</span><br>GroupQuitMessageHandler groupQuitMessageHandler = <span class="hljs-keyword">new</span> GroupQuitMessageHandler();<br>ch.pipeline().addLast(groupQuitMessageHandler);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>正常退出</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">32282 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;退出Netty学习成功&#x27;&#125;<br></code></pre></td></tr></table></figure>

<p>退出不存在或未加入的群聊</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">67404 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;群聊不存在或您未加入该群，退出Netty失败&#x27;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupMembersMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupMembersRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理查看成员</span><br>GroupMembersMessageHandler groupMembersMessageHandler = <span class="hljs-keyword">new</span> GroupMembersMessageHandler();<br>ch.pipeline().addLast(groupMembersMessageHandler);<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">46557 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members=[zhangsan, Nyima]&#125;<br></code></pre></td></tr></table></figure>

<h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常退出，需要解绑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理退出聊天室</span><br>ch.pipeline().addLast(quitHandler);<br>GroupMembersMessageHandler groupMembersMessageHandler = <span class="hljs-keyword">new</span> GroupMembersMessageHandler();<br></code></pre></td></tr></table></figure>

<p><strong>退出时，客户端会关闭channel并返回</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>	<span class="hljs-comment">// 关闭channel并返回</span><br>    ctx.channel().close();<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure>

<h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p>
<ul>
<li>readerIdleTimeSeconds 读空闲经过的秒数</li>
<li>writerIdleTimeSeconds 写空闲经过的秒数</li>
<li>allIdleTimeSeconds 读和写空闲经过的秒数</li>
</ul>
<p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" alt="img"></a></p>
<ul>
<li>读空闲会触发<code>READER_IDLE</code></li>
<li>写空闲会触发<code>WRITE_IDLE</code></li>
<li>读和写空闲会触发<code>ALL_IDEL</code></li>
</ul>
<p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p>
<p><strong>服务器端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 添加双向处理器，负责处理READER_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得事件</span><br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>            <span class="hljs-comment">// 断开连接</span><br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>IdleStateHandler</code>进行空闲检测</p>
</li>
<li><p>使用双向处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ChannelDuplexHandler<br></code></pre></td></tr></table></figure>

<p>对入站与出站事件进行处理</p>
<ul>
<li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li>
</ul>
</li>
</ul>
<p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p>
<p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p>
<p><strong>客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送心跳包，让服务器知道客户端在线</span><br><span class="hljs-comment">// 3s未发生WRITER_IDLE，就像服务器发送心跳包</span><br><span class="hljs-comment">// 该值为服务器端设置的READER_IDLE触发时间的一半左右</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;<br>            <span class="hljs-comment">// 发送心跳包</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> PingMessage());<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object 被序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 被序列化对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 序列化后的字节数组</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 反序列化的目标类的Class对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 被反序列化的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 反序列化目标类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SerializerAlgorithm implements Serializer &#123;<br>    <span class="hljs-comment">// Java的序列化和反序列化</span><br>    Java &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>            <span class="hljs-comment">// 序列化后的字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> (ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>                 ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos)) &#123;<br>                oos.writeObject(object);<br>                bytes = bos.toByteArray();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>            T target = <span class="hljs-keyword">null</span>;<br>            System.out.println(Arrays.toString(bytes));<br>            <span class="hljs-keyword">try</span> (ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);<br>                 ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis)) &#123;<br>                target = (T) ois.readObject();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 返回反序列化后的对象</span><br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">// Json的序列化和反序列化</span><br>    Json &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>            String s = <span class="hljs-keyword">new</span> Gson().toJson(object);<br>            System.out.println(s);<br>            <span class="hljs-comment">// 指定字符集，获得字节数组</span><br>            <span class="hljs-keyword">return</span> s.getBytes(StandardCharsets.UTF_8);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>            String s = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>            System.out.println(s);<br>            <span class="hljs-comment">// 此处的clazz为具体类型的Class对象，而不是父类Message的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Gson().fromJson(s, clazz);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得序列化后的msg</span><br><span class="hljs-comment">// 使用指定的序列化方式</span><br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-comment">// 获得序列化后的对象</span><br><span class="hljs-keyword">byte</span>[] bytes = values[out.getByte(<span class="hljs-number">5</span>)-<span class="hljs-number">1</span>].serialize(msg);<br></code></pre></td></tr></table></figure>

<p><strong>解码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得反序列化方式</span><br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-comment">// 通过指定方式进行反序列化</span><br><span class="hljs-comment">// 需要通过Message的方法获得具体的消息类型</span><br>Message message = values[seqType-<span class="hljs-number">1</span>].deserialize(Message.getMessageClass(messageType), bytes);<br></code></pre></td></tr></table></figure>

<h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul>
<li>属于 <strong>SocketChannal</strong> 的参数</li>
<li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li>
<li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>        <br>        <span class="hljs-comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p>
</li>
<li><p>服务器通过</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServerBootstrap<br></code></pre></td></tr></table></figure>

<p>  来配置参数，但是对于不同的 Channel 需要选择不同的方法</p>
<ul>
<li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li>
<li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p>
<p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// Schedule connect timeout.</span><br>    <span class="hljs-comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span><br>    <span class="hljs-keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();<br>    <span class="hljs-comment">// 如果超时时间大于0</span><br>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span><br>        <span class="hljs-comment">// schedule(Runnable command, long delay, TimeUnit unit)</span><br>        connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span><br>                <span class="hljs-comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span><br>                <span class="hljs-comment">// 在主线程中抛出</span><br>                ChannelPromise connectPromise = AbstractNioChannel.<span class="hljs-keyword">this</span>.connectPromise;<br>                ConnectTimeoutException cause = <span class="hljs-keyword">new</span> ConnectTimeoutException(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress);<br>                <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;<br>                    close(voidPromise());<br>                &#125;<br>            &#125;<br>        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>   	...<br>        <br>&#125;<br></code></pre></td></tr></table></figure>

<p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p>
<ul>
<li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li>
<li>如果指定时间内没有建立连接，则会执行其中的任务<ul>
<li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li>
</ul>
</li>
</ul>
<h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p>
<h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221510897.png" alt="image-20220812221510897"></p>
<p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221524109.png" alt="image-20220812221524109"></p>
<p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221538399.png" alt="image-20220812221538399"></p>
<p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p>
<ul>
<li>半连接队列 - sync queue<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li>全连接队列 - accept queue<ul>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
</ul>
</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p>
<p><strong>设置方式如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置全连接队列，大小为2</span><br><span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.SO_BACKLOG, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> backlog = NetUtil.SOMAXCONN;<br></code></pre></td></tr></table></figure>

<p>具体的赋值操作如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SOMAXCONN = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span><br>        <span class="hljs-comment">// The known defaults:</span><br>        <span class="hljs-comment">// - Windows NT Server 4.0+: 200</span><br>        <span class="hljs-comment">// - Linux and Mac OS X: 128</span><br>        <span class="hljs-keyword">int</span> somaxconn = PlatformDependent.isWindows() ? <span class="hljs-number">200</span> : <span class="hljs-number">128</span>;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/proc/sys/net/core/somaxconn&quot;</span>);<br>        BufferedReader in = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span><br>            <span class="hljs-comment">// try / catch block.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/4936</span><br>            <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>                in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(file));<br>                <span class="hljs-comment">// 将somaxconn设置为Linux配置文件中设置的值</span><br>                somaxconn = Integer.parseInt(in.readLine());<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, file, somaxconn);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ...<br>            &#125;<br>            ...<br>        &#125;  <br>        <span class="hljs-comment">// 返回backlog的值</span><br>        <span class="hljs-keyword">return</span> somaxconn;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>backlog的值会根据操作系统的不同，来</p>
<p>选择不同的默认值</p>
<ul>
<li>Windows 200</li>
<li>Linux/Mac OS 128</li>
</ul>
</li>
<li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p>
</li>
</ul>
<h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul>
<li>属于 <strong>SocketChannal</strong> 参数</li>
<li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li>
<li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li>
</ul>
<h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul>
<li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li>
<li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li>
<li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li>
</ul>
<h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul>
<li>属于 <strong>SocketChannal</strong> 参数</li>
<li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span><br><span class="hljs-comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span><br><span class="hljs-keyword">new</span> ServerBootstrap().childOption(ChannelOption.ALLOCATOR, <span class="hljs-keyword">new</span> PooledByteBufAllocator());<br></code></pre></td></tr></table></figure>

<p><strong>ByteBufAllocator类型</strong></p>
<ul>
<li><p>池化并使用直接内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// true表示使用直接内存</span><br><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>池化并使用堆内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>非池化并使用直接内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ture表示使用直接内存</span><br><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>非池化并使用堆内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul>
<li>属于 <strong>SocketChannal</strong> 参数</li>
<li><strong>控制 Netty 接收缓冲区大小</strong></li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li>
</ul>
<h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p>
<p><strong>Message</strong>中添加如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    ...<br><br>    <span class="hljs-comment">// 添加RPC消息类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="hljs-number">101</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="hljs-number">102</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 将消息类型放入消息类对象Map中</span><br>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);<br>        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>RPC请求消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口中的方法名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String methodName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class&lt;?&gt; returnType;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数类型数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class[] parameterTypes;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数值数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object[] parameterValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RpcRequestMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setSequenceId(sequenceId);<br>        <span class="hljs-keyword">this</span>.interfaceName = interfaceName;<br>        <span class="hljs-keyword">this</span>.methodName = methodName;<br>        <span class="hljs-keyword">this</span>.returnType = returnType;<br>        <span class="hljs-keyword">this</span>.parameterTypes = parameterTypes;<br>        <span class="hljs-keyword">this</span>.parameterValue = parameterValue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;<br>    &#125;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInterfaceName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> interfaceName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMethodName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> methodName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getReturnType() &#123;<br>        <span class="hljs-keyword">return</span> returnType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class[] getParameterTypes() &#123;<br>        <span class="hljs-keyword">return</span> parameterTypes;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object[] getParameterValue() &#123;<br>        <span class="hljs-keyword">return</span> parameterValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcRequestMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;interfaceName=&#x27;&quot;</span> + interfaceName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, methodName=&#x27;&quot;</span> + methodName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, returnType=&quot;</span> + returnType +<br>                <span class="hljs-string">&quot;, parameterTypes=&quot;</span> + Arrays.toString(parameterTypes) +<br>                <span class="hljs-string">&quot;, parameterValue=&quot;</span> + Arrays.toString(parameterValue) +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p>
<ul>
<li>方法所在的全限定类名</li>
<li>方法名</li>
<li>方法返回值类型</li>
<li>方法参数类型</li>
<li>方法参数值</li>
</ul>
<p><strong>RPC响应消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object returnValue;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Exception exceptionValue;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;<br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReturnValue</span><span class="hljs-params">(Object returnValue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.returnValue = returnValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExceptionValue</span><span class="hljs-params">(Exception exceptionValue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.exceptionValue = exceptionValue;<br>    &#125;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getReturnValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exception <span class="hljs-title">getExceptionValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> exceptionValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcResponseMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;returnValue=&quot;</span> + returnValue +<br>                <span class="hljs-string">&quot;, exceptionValue=&quot;</span> + exceptionValue +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>响应消息中只需要获取<strong>返回结果和异常值</strong></p>
<p><strong>服务器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcRequestMessageHandler rpcRequestMessageHandler = <span class="hljs-keyword">new</span> RpcRequestMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                    ch.pipeline().addLast(rpcRequestMessageHandler);<br>                &#125;<br>            &#125;);<br>            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                    ch.pipeline().addLast(rpcResponseMessageHandler);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过接口Class获取实例对象的<strong>Factory</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServicesFactory</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> HashMap&lt;Class&lt;?&gt;, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Class&lt;?&gt; interfaceClass)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;<br>        <span class="hljs-comment">// 根据Class创建实例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>);<br>            Object instance = Class.forName(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;</span>).newInstance();<br>           <br>            <span class="hljs-comment">// 放入 InterfaceClass -&gt; InstanceObject 的映射</span><br>            map.put(clazz, instance);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;  <br>        <span class="hljs-keyword">return</span> map.get(interfaceClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage)</span> </span>&#123;<br>        RpcResponseMessage rpcResponseMessage = <span class="hljs-keyword">new</span> RpcResponseMessage();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 设置返回值的属性</span><br>            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());<br>            <span class="hljs-comment">// 返回一个实例</span><br>            HelloService service = (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));<br>            <br>            <span class="hljs-comment">// 通过反射调用方法，并获取返回值</span><br>            Method method = service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());<br>            <span class="hljs-comment">// 获得返回值</span><br>            Object invoke = method.invoke(service, rpcMessage.getParameterValue());<br>            <span class="hljs-comment">// 设置返回值</span><br>            rpcResponseMessage.setReturnValue(invoke);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">// 设置异常</span><br>            rpcResponseMessage.setExceptionValue(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 向channel中写入Message</span><br>    ctx.writeAndFlush(rpcResponseMessage);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>远程调用方法主要是通过反射实现的，大致步骤如下</p>
<ul>
<li>通过<strong>请求消息传入被调入方法的各个参数</strong></li>
<li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li>
<li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li>
<li>若有<strong>异常需要捕获，并放入响应消息中</strong></li>
</ul>
<h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        System.out.println((String)msg.getReturnValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		...<br>           <br>        <span class="hljs-comment">// 创建请求并发送</span><br>		RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(<span class="hljs-number">1</span>,<br>               <span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>,<br>               <span class="hljs-string">&quot;sayHello&quot;</span>,<br>               String.class,<br>               <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>               <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;Nyima&quot;</span>&#125;);<br>		<br>        channel.writeAndFlush(message);   <br>            <br>        ...    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>客户端</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">1606 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue=你好，Nyima, exceptionValue=null&#125;<br></code></pre></td></tr></table></figure>

<h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClientManager</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 产生SequenceId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger sequenceId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建代理对象</span><br>        HelloService service = (HelloService) getProxy(HelloService.class);<br>        <span class="hljs-comment">// 通过代理对象执行方法</span><br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;Nyima&quot;</span>));<br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;Hulu&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例模式创建Channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) &#123;<br>                    init();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> channel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用代理模式，帮助我们创建请求消息并发送</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;<br>        Class&lt;?&gt;[] classes = <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;;<br>        <span class="hljs-comment">// 使用JDK代理，创建代理对象</span><br>        Object o = Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-comment">// 创建请求消息</span><br>                <span class="hljs-keyword">int</span> id = sequenceId.getAndIncrement();<br>                RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(id, serviceClass.getName(),<br>                        method.getName(), method.getReturnType(),<br>                        method.getParameterTypes(),<br>                        args);<br>                <span class="hljs-comment">// 发送消息</span><br>                getChannel().writeAndFlush(message);<br><br>                <span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>                DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<br>                <span class="hljs-comment">// 将Promise放入Map中</span><br>                RpcResponseMessageHandler.promiseMap.put(id, promise);<br>                <span class="hljs-comment">// 等待被放入Promise中结果</span><br>                promise.await();<br>                <span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;<br>                    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>                    <span class="hljs-keyword">return</span> promise.getNow();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br><br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.channel(NioSocketChannel.class);<br>        bootstrap.group(group);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                ch.pipeline().addLast(loggingHandler);<br>                ch.pipeline().addLast(messageSharableCodec);<br>                ch.pipeline().addLast(rpcResponseMessageHandler);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)).sync().channel();<br>            <span class="hljs-comment">// 异步关闭 group，避免Channel被阻塞</span><br>            channel.closeFuture().addListener(future -&gt; &#123;<br>                group.shutdownGracefully();<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>获得Channel</strong></p>
<ul>
<li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li>
<li>通过<strong>单例模式</strong>创建与获取Channel</li>
</ul>
<p><strong>远程调用方法</strong></p>
<ul>
<li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li>
<li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li>
</ul>
<p><strong>远程调用方法返回值获取</strong></p>
<ul>
<li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p>
</li>
<li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p>
<ul>
<li>Key为<strong>SequenceId</strong></li>
<li>Value为对应的<strong>Promise</strong></li>
</ul>
</li>
<li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<br><span class="hljs-comment">// 将Promise放入Map中</span><br>RpcResponseMessageHandler.promiseMap.put(id, promise);<br><span class="hljs-comment">// 等待被放入Promise中结果</span><br>promise.await();<br><span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;<br>    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>    <span class="hljs-keyword">return</span> promise.getNow();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p>
<ul>
<li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li>
<li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());<br>Object returnValue = msg.getReturnValue();<br>Exception exception = msg.getExceptionValue();<br><span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 返回结果中有异常信息</span><br>        promise.setFailure(exception);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 方法正常执行，没有异常</span><br>        promise.setSuccess(returnValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>        Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());<br>        Object returnValue = msg.getReturnValue();<br>        Exception exception = msg.getExceptionValue();<br>        <span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 返回结果中有异常信息</span><br>                promise.setFailure(exception);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 方法正常执行，没有异常</span><br>                promise.setSuccess(returnValue);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拿到返回结果并打印</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span><br>Selector selector = Selector.open(); <br><br><span class="hljs-comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br>NioServerSocketChannel attachment = <span class="hljs-keyword">new</span> NioServerSocketChannel();<br><br><span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); <br>serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br><span class="hljs-comment">// 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br>SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">// 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure>

<ul>
<li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li>
<li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li>
<li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li>
<li>绑定端口</li>
<li>通过<code>interestOps</code>设置感兴趣的事件</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p>
<p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;<br>	validate();<br>	<span class="hljs-keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p>
<p><strong>dobind方法在主线程中执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;<br>    <span class="hljs-comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span><br>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span><br>    <span class="hljs-comment">// init由main线程完成，regisetr由NIO线程完成</span><br>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();<br>    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为register操作是异步的</span><br>    <span class="hljs-comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        ChannelPromise promise = channel.newPromise();<br>        <br>        <span class="hljs-comment">// 执行doBind0绑定操作</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-comment">// 如果register操作还没执行完，就会到这个分支中来</span><br>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);<br>        <br>        <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span><br>        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Throwable cause = future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered();<br><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li>
<li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li>
<li><strong>doBind0</strong>则负责连接的创建工作</li>
</ul>
<h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;<br>    Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel();<br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    ChannelFuture regFuture = config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Channel channel = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 通过反射初始化NioServerSocketChannel</span><br>    channel = channelFactory.newChannel();<br>    init(channel);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>newChannel方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newChannel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射调用NioServerSocketChannel的构造方法</span><br>        <span class="hljs-comment">// 创建NioServerSocketChannel对象</span><br>        <span class="hljs-keyword">return</span> constructor.newInstance();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>NioServerSocketChannel构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerSocketChannel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>newSocket方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title">newSocket</span><span class="hljs-params">(SelectorProvider provider)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ServerSocketChannel.open方法：</span><br>        <span class="hljs-comment">// SelectorProvider.provider().openServerSocketChannel()</span><br>	    <span class="hljs-comment">// 所以此处相当于ServerSocketChannel.open()</span><br>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    	<span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>	&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>  	  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>init方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>   	...<br>		<br>    <span class="hljs-comment">// NioSocketChannl的Pipeline    </span><br>    ChannelPipeline p = channel.pipeline();<br>		<br>    ...<br><br>    <span class="hljs-comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// register之后才调用该方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            <br>            <span class="hljs-comment">// 创建handler并加入到pipeline中</span><br>            ChannelHandler handler = config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 添加新的handler，在发生Accept事件后建立连接</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>init主要完成了以下三个操作</strong></p>
<ul>
<li><p>创建NioServerSocketChannel</p>
</li>
<li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p>
</li>
<li><p>由</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">initChannel<br></code></pre></td></tr></table></figure>

<p>方法向NioServerSocketChannel中添加了两个handler，</p>
<p>添加操作在register之后被执行</p>
<ul>
<li>一个handler负责设置配置</li>
<li>一个handler负责发生Accepet事件后建立连接</li>
</ul>
</li>
</ul>
<h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p>
<p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p>
<p><strong>promise.channel().unsafe().register(this, promise)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 获取EventLoop</span><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>   	<span class="hljs-comment">// 此处完成了由 主线程 到 NIO线程 的切换</span><br>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 向NIO线程中添加任务</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 该方法中会执行doRegister</span><br>                    <span class="hljs-comment">// 执行真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>           ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>register0方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       	...<br>            <br>        <span class="hljs-comment">// 执行真正的注册操作</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 调用init中的initChannel方法</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>doRegister方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br>            <span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>           <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回调initChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>    ChannelHandler handler = config.handler();<br>    <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>        pipeline.addLast(handler);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span><br>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span><br>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Register主要完成了以下三个操作</p>
<ul>
<li><p>完成了主线程到NIO的<strong>线程切换</strong></p>
<ul>
<li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li>
<li>切换的方式为让eventLoop执行register的操作</li>
<li><strong>register的操作在NIO线程中完成</strong></li>
</ul>
</li>
<li><p><strong>调用doRegister方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br><span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br><span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li>
<li>此时还未关注事件</li>
<li>添加NioServerSocketChannel附件</li>
</ul>
</li>
<li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p>
<ul>
<li><p>initChannel方法主要创建了</p>
<p>两个handler</p>
<ul>
<li>一个handler负责设置配置</li>
<li>一个handler负责发生Accept事件后建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br><span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();<br>regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Throwable cause = future.cause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>            promise.setFailure(cause);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>            promise.registered();<br>            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span><br>            doBind0(regFuture, channel, localAddress, promise);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p>
<p>NioServerSocketChannel.doBind方法</p>
<p>通过该方法，绑定了对应的端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span><br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>    invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            pipeline.fireChannelActive();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readPending = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span><br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 则让其关注Accepet事件</span><br>        <span class="hljs-comment">// readInterestOp 取值是 16</span><br>        <span class="hljs-comment">// 在 NioServerSocketChannel 创建时初始化</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p>
<ul>
<li><p>首先获取Channel所有感兴趣的事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br></code></pre></td></tr></table></figure>
</li>
<li><p>然后再设置其感兴趣的事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jselectionKey.interestOps(interestOps | readInterestOp);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>各个事件对应的值</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221611103.png" alt="image-20220812221611103"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p>
<ul>
<li>NioServerSocketChannel与ServerSocketChannel的创建</li>
<li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li>
<li>绑定了对应的端口</li>
<li>关注了Accept事件</li>
</ul>
<h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p>
<ul>
<li><p><strong>Selector</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleThreadEventLoop</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">private</span> SelectedSelectionKeySet selectedKeys;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Thread与TaskQueue</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractScheduledEventExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderedEventExecutor</span> </span>&#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;<br>    <br>        ...<br>           <br>        <span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        <span class="hljs-keyword">final</span> SelectorTuple selectorTuple = openSelector();<br>        <span class="hljs-keyword">this</span>.selector = selectorTuple.selector;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title">openSelector</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p>
<p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">unwrappedSelector = provider.openSelector();<br></code></pre></td></tr></table></figure>

<p>获得了Selector对象<code>unwrappedSelector</code></p>
<p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p>
<h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p>
<ul>
<li>selector中的SelectedKeys是<strong>基于数组</strong>的</li>
<li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li>
</ul>
<p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title">openSelector</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    <span class="hljs-keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();<br><br><br>    Object maybeException = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br>	<br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p>
<ul>
<li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br><span class="hljs-keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();<br><br>SelectedSelectionKeySet() &#123;<br>	keys = <span class="hljs-keyword">new</span> SelectionKey[<span class="hljs-number">1024</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p>
</li>
<li><p><strong>通过Selector的构造方法</strong>获得selector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>return <span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectorTuple(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">new</span> SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span>);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNioEventLoop</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EventLoop eventLoop = <span class="hljs-keyword">new</span> NioEventLoopGroup().next();<br>        <span class="hljs-comment">// 使用NioEventLoop执行任务</span><br>        eventLoop.execute(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进入<code>execute</code>执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>    <span class="hljs-comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span><br>    ObjectUtil.checkNotNull(task, <span class="hljs-string">&quot;task&quot;</span>);<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span><br>    execute(task, !(task <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进入上述代码的<code>execute</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前线程是否为NIO线程</span><br>    <span class="hljs-comment">// 判断方法为 return thread == this.thread;</span><br>    <span class="hljs-comment">// this.thread即为NIO线程，首次执行任务时，其为null</span><br>    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();<br>    <br>    <span class="hljs-comment">// 向任务队列taskQueue中添加任务</span><br>    addTask(task);<br>    <br>    <span class="hljs-comment">// 当前线程不是NIO线程，则进入if语句</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// 启动NIO线程的核心方法</span><br>        startThread();<br>        <br>        ...<br>        <br>    &#125;<br>	<br>    <span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进入<code>startThread</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                doStartThread();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_STARTED, ST_NOT_STARTED);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p>
<p>该run方法是<strong>NioEvnetLoop的run方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;	<br>      	<span class="hljs-comment">// 执行各种任务</span><br>   		<span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> strategy;<br>            <span class="hljs-keyword">try</span> &#123;<br>                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    <span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br>                    <span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>                        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                    &#125;<br>                    nextWakeupNanos.set(curDeadlineNanos);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                            strategy = select(curDeadlineNanos);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                        <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                        nextWakeupNanos.lazySet(AWAKE);<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>                &#125;<br>       		&#125;<br>    	&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      	<span class="hljs-comment">// 执行各种任务</span><br>   		...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p>
<p>run方法中有SELECT分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>	<span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br>	<span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>    &#125;<br>	nextWakeupNanos.set(curDeadlineNanos);<br>	<span class="hljs-keyword">try</span> &#123;<br>    	<span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>            <span class="hljs-comment">// 执行select方法</span><br>            strategy = select(curDeadlineNanos);<br>        &#125;<br>    &#125;<br>	...<br></code></pre></td></tr></table></figure>

<p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deadlineNanos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 如果没有指定阻塞事件，就调用select()</span><br>    <span class="hljs-keyword">if</span> (deadlineNanos == NONE) &#123;<br>        <span class="hljs-keyword">return</span> selector.select();<br>    &#125;<br>    <span class="hljs-comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span><br>    <span class="hljs-comment">// Timeout will only be 0 if deadline is within 5 microsecs</span><br>    <span class="hljs-keyword">long</span> timeoutMillis = deadlineToDelayNanos(deadlineNanos + <span class="hljs-number">995000L</span>) / <span class="hljs-number">1000000L</span>;<br>    <span class="hljs-keyword">return</span> timeoutMillis &lt;= <span class="hljs-number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p>
<p>唤醒是通过execute最后的if代码块来完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>    wakeup(inEventLoop);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> inEventLoop)</span> </span>&#123;<br>    <span class="hljs-comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span><br>    <span class="hljs-comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;<br>        <span class="hljs-comment">// 唤醒被selector.select方法阻塞的NIO线程</span><br>        selector.wakeup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>唤醒时需要进行两个判断</p>
<ul>
<li><p>判断提交任务的</p>
<p>是否为NIO线程</p>
<ul>
<li>若是其他线程，才能唤醒NIO线程</li>
<li>若是NIO线程自己，则不能唤醒</li>
</ul>
</li>
<li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p>
</li>
</ul>
<h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br><span class="hljs-keyword">switch</span> (strategy) &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>strategy的值由<code>calculateStrategy</code>方法确定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateStrategy</span><span class="hljs-params">(IntSupplier selectSupplier, <span class="hljs-keyword">boolean</span> hasTasks)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// selectSupplier.get() 底层是 selector.selectNow();</span><br>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p>
<ul>
<li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p>
<ul>
<li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IntSupplier selectNowSupplier = <span class="hljs-keyword">new</span> IntSupplier() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> NioEventLoop.<span class="hljs-keyword">this</span>.selectNow();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selector.selectNow();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>若没有任务，就会进入SELECT分支</p>
</li>
</ul>
<p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p>
<h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p>
<p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        ...<br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = select(curDeadlineNanos);  <br>        ...     <br>    <br>     	<span class="hljs-keyword">if</span>(...) &#123;<br>			...<br>     	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p>
<p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>    <span class="hljs-comment">// The selector returned prematurely many times in a row.</span><br>    <span class="hljs-comment">// Rebuild the selector to work around the problem.</span><br>    logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,selectCnt, selector);<br>    <span class="hljs-comment">// 重建selector，将原selector的配置信息传给新selector</span><br>    <span class="hljs-comment">// 再用新selector覆盖旧selector</span><br>    rebuildSelector();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p>
<h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p>
<p><strong>NioEventLoop.run方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理IO事件时间比例，默认为50%</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br><br><span class="hljs-comment">// 如果IO事件时间比例设置为100%</span><br><span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果需要去处理IO事件</span><br>        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先处理IO事件</span><br>            processSelectedKeys();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// 剩下的时间都去处理普通任务和定时任务</span><br>        ranTasks = runAllTasks();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果需要去处理IO事件</span><br>    <span class="hljs-comment">// 记录处理IO事件前的时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 去处理IO事件</span><br>        processSelectedKeys();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// ioTime为处理IO事件耗费的事件</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>        <span class="hljs-comment">// 计算出处理其他任务的事件</span><br>        <span class="hljs-comment">// 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行</span><br>        ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有IO事件需要处理</span><br>    <span class="hljs-comment">// This will run the minimum number of tasks</span><br>    <span class="hljs-comment">// 直接处理普通和定时任务</span><br>    ranTasks = runAllTasks(<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p>
<ul>
<li><p>判断ioRatio是否为100</p>
<ul>
<li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p>
<ul>
<li>若需要处理IO事件，则先处理IO事件</li>
</ul>
</li>
<li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 没有指定执行任务的时间</span><br>ranTasks = runAllTasks();<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>若ioRatio不为100</p>
<ul>
<li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p>
</li>
<li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比如ioTime为10s，ioRatio为50</span><br><span class="hljs-comment">// 那么通过 10*(100-50)/50=10 计算出其他任务可用的时间为 10s</span><br><span class="hljs-comment">// 处理IO事件占用的事件总比例为50%</span><br>ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br></code></pre></td></tr></table></figure>
</li>
<li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p>
</li>
</ul>
</li>
<li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行最少数量的任务</span><br>ranTasks = runAllTasks(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeys</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// 一般情况下都走这个分支</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 处理各种IO事件</span><br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>processSelectedKeysOptimized方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;<br>        <span class="hljs-comment">// 拿到SelectionKeyec</span><br>        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<br>        <span class="hljs-comment">// null out entry in the array to allow to have it GC&#x27;ed once the Channel close</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br>        <span class="hljs-keyword">final</span> Object a = k.attachment();<br><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>            <span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>            processSelectedKey(k, (AbstractNioChannel) a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, task);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>            <span class="hljs-comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>            selectedKeys.reset(i + <span class="hljs-number">1</span>);<br><br>            selectAgain();<br>            i = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<br></code></pre></td></tr></table></figure>

<p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br><span class="hljs-keyword">final</span> Object a = k.attachment();<br></code></pre></td></tr></table></figure>

<p>如果附件继承自AbstractNioChannel，则会调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>processSelectedKey(k, (AbstractNioChannel) a);<br></code></pre></td></tr></table></figure>

<p>去处理各个事件</p>
<p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p>
<p>获取SelectionKey的事件，然后进行相应处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            unsafe.close(unsafe.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-keyword">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br>        <span class="hljs-comment">// to a spin loop</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p>
<ul>
<li>selector.select()阻塞线程，直到事件发生</li>
<li>遍历selectionKeys</li>
<li>获取一个key，判断事件类型是否为Accept</li>
</ul>
<hr>
<ul>
<li>创建SocketChannel，设置为非阻塞</li>
<li>将SocketChannel注册到selector中</li>
<li>关注selectionKeys的read事件</li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞直到事件发生</span><br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-comment">// 拿到一个事件</span><br>    SelectionKey key = iter.next();<br>    <br>    <span class="hljs-comment">// 如果是 accept 事件</span><br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-comment">// 执行accept，获得SocketChannel</span><br>        SocketChannel channel = serverSocketChannel.accept();<br>        channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        <br>        <span class="hljs-comment">// 将SocketChannel注册到selector中，并关注read事件</span><br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p>
<h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>	unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NioMessageUnsafe.read</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ...<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>				<span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span><br>                <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span><br>                <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span><br>                <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span><br>                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);<br>                <br>                ...<br>                <br>				<span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span><br>                allocHandle.incMessagesRead(localRead);<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> size = readBuf.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span><br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        <br>        ...<br>        <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NioSocketChannel.doReadMessages</code>方法</p>
<p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span><br>    SocketChannel ch = SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span><br>            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>ServerBootstrapAcceptor.channelRead<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span><br>    <span class="hljs-keyword">final</span> Channel child = (Channel) msg;<br><br>    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span><br>    child.pipeline().addLast(childHandler);<br><br>    <span class="hljs-comment">// 设置选项</span><br>    setChannelOptions(child, childOptions, logger);<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <br>    ...<br><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br>AbstractChannel.AbstractUnsafe.register0<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <br>        ...<br>            <br>        <span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span><br>        doRegister();<br>        <br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发pipeline上active事件</span><br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将Selector注册到Selector中</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br>HeadContext.channelActive<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    ctx.fireChannelActive();<br>	<span class="hljs-comment">// 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)</span><br>    readIfIsAutoRead();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-keyword">true</span>;<br>	<span class="hljs-comment">// 这时候 interestOps是0</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关注read事件</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>	unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获得Channel的配置</span><br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>	<span class="hljs-comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span><br>	<span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();<br>    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 创建ByteBuf</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取内容，放入ByteBUf中</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                byteBuf.release();<br>                byteBuf = <span class="hljs-keyword">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    readPending = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发read 事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// 这时是处理NioSocketChannel上的handler</span><br>            pipeline.fireChannelRead(byteBuf);<br>            byteBuf = <span class="hljs-keyword">null</span>;<br>        &#125; <br>        <span class="hljs-comment">// 是否要继续循环</span><br>        <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>        allocHandle.readComplete();<br>        <span class="hljs-comment">// 触发 read complete事件</span><br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>         <span class="hljs-comment">// This could be for two reasons:</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br>DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">continueReading</span><span class="hljs-params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <br>           <span class="hljs-comment">// 一般为true</span><br>           config.isAutoRead() &amp;&amp;<br>           <span class="hljs-comment">// respectMaybeMoreData默认为true</span><br>           <span class="hljs-comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span><br>           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;<br>           <span class="hljs-comment">// 小于最大次数，maxMessagePerRead默认16</span><br>           totalMessages &lt; maxMessagePerRead &amp;&amp;<br>           <span class="hljs-comment">// 实际读到了数据</span><br>           totalBytesRead &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/09/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<ul>
<li><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p>
</li>
<li><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
</li>
<li><p><strong>原地排序</strong>：在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序；</p>
</li>
<li><p><strong>非原地排序</strong>：需要利用额外的数组来辅助排序；</p>
</li>
</ul>
</blockquote>
<p><strong>各排序算法总结：</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220911004032768.png" alt="image-20220911004032768"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote>
<p>冒泡排序是一种简单的排序算法，每轮比较，将未排序的最大的数字放到最后，经过n-1轮，整个数组都有序了。</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 冒泡排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> [] BubbleSort(<span class="hljs-keyword">int</span> [] a)&#123;<br>    <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">int</span> len = a.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len-i-<span class="hljs-number">1</span>;j++)&#123;<br>            <span class="hljs-comment">//交换两个相邻数字</span><br>            <span class="hljs-keyword">if</span>(a[j+<span class="hljs-number">1</span>]&lt;a[j])&#123;<br>                <span class="hljs-keyword">int</span> temp = a[j+<span class="hljs-number">1</span>];<br>                a[j+<span class="hljs-number">1</span>] = a[j];<br>                a[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>优化一下冒泡排序的算法</strong></p>
<blockquote>
<p>如果某一趟的遍历中，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">if</span> ( arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> arr;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len -i - <span class="hljs-number">1</span>; j++) &#123;<br>               <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) &#123;<br>                   flag = <span class="hljs-keyword">false</span>;<br>                   <span class="hljs-keyword">int</span> t = arr[j];<br>                   arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                   arr[j+<span class="hljs-number">1</span>] = t;<br>               &#125;<br>           &#125;<br>           <span class="hljs-comment">//一趟下来是否发生位置交换</span><br>           <span class="hljs-keyword">if</span>(<span class="hljs-keyword">false</span>)<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> arr;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用优化后的冒泡算法，在数组本身就有序的情况下，时间复杂度为O(n)</strong></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p>将数组分为已经排序和未排序两部分，初始时已排序部分元素个数为0。每次遍历，找到未排序数组中的最小元素，然后将它放在已排序数组中的末尾。经过n-1次遍历后，整个数组就是有序的了。</p>
<ul>
<li>初始状态：无序区为R[1…n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了</li>
</ul>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/2.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 选择排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> [] SelectSort(<span class="hljs-keyword">int</span> [] a)&#123;<br>        <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">int</span> len = a.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">int</span> minindex = i;<br>            <span class="hljs-comment">//遍历无序数组，找到最小的元素</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[j] &lt; a[minindex])<br>                    minindex = j;<br>            &#125;<br>			<span class="hljs-comment">//交换元素</span><br>            <span class="hljs-keyword">int</span> temp = a[i];<br>            a[i] = a[minindex];<br>            a[minindex] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>插入排序同样将数组分为已排序和未排序的两部分。每次遍历的时候都将当前元素和之前的元素进行比较，找到小于等于自己的元素，然后插入到他的后面；在比较过程中，大于当前元素的元素都将向后移动一位。</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/3.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> [] insertSort(<span class="hljs-keyword">int</span> [] a)&#123;<br>    <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">int</span> len = a.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-comment">//当前元素</span><br>        <span class="hljs-keyword">int</span> current = a[i];<br>        <span class="hljs-comment">//前一个元素的位置</span><br>        <span class="hljs-keyword">int</span> preindex = i-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(preindex&gt;=<span class="hljs-number">0</span>&amp;&amp;a[preindex] &gt; current)&#123;<br>            <span class="hljs-comment">//将大于当前元素的值向后移动一位</span><br>            a[preindex+<span class="hljs-number">1</span>] = a[preindex];<br>            preindex--;<br>        &#125;<br>        <span class="hljs-comment">//退出循环是因为preindex&lt;0 或者 a[preindex] &lt;= current</span><br>        <span class="hljs-comment">//也就是说当前元素应该插入到preindex后面，所以+1</span><br>        a[preindex+<span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote>
<p>希尔排序是插入排序的改进版，也叫缩小增量排序；插入排序每次只会和前面一个数字进行比较，<strong>如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了</strong>。而希尔排序会逐渐减小这个增量的值，随着增量逐渐减小，每组包含的元素越来越多，当增量为1的时候，整个数组被分成一组，算法终止。</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220911112014363.png" alt="image-20220911112014363"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 希尔排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] shellSort(<span class="hljs-keyword">int</span> [] a)&#123;<br>    <span class="hljs-keyword">if</span>(a.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">int</span> len = a.length;<br>    <span class="hljs-comment">//增量选择为 len/2，增量可以有多种选择方法</span><br>    <span class="hljs-keyword">int</span> gap = len/<span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">while</span>(gap&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//对于每一个增量，进行插入排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=gap;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">int</span> current = a[i];<br>            <span class="hljs-comment">//这里上一个元素的下标为当前下标-gap</span><br>            <span class="hljs-keyword">int</span> preindex = i-gap;<br>            <span class="hljs-keyword">while</span>(preindex&gt;=<span class="hljs-number">0</span> &amp;&amp; a[preindex]&gt;current)&#123;<br>                a[preindex+gap] = a[preindex];<br>                preindex-=gap;<br>            &#125;<br>            a[preindex+gap] = current;<br>        &#125;<br>        gap/=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>由上面代码可以看出，其实希尔排序就是插入排序的优化，代码也很像，只是需要每次对gap进行修改，并且元素之间的间隔不再是固定的1，而是这个gap。</strong></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>归并排序是分治法的一个典型应用。将一个大的数组分为多个子序列，对每个子序列进行排序，然后再将已经有序的子序列进行合并，得到最终的有序序列，即：<strong>先让每个子序列有序，再让子序列段间有序。</strong></p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ul>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/4.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 归并排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> left</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> right</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> [] mergeSort(<span class="hljs-keyword">int</span> [] a,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)&#123;<br>    <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>        <span class="hljs-comment">//将大数组分成两个子数组</span><br>        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//对左半边进行排序</span><br>        mergeSort(a,left,mid);<br>        <span class="hljs-comment">//对右半边进行排序</span><br>        mergeSort(a,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-comment">//合并</span><br>        merge(a,left,mid,right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] a,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> [] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [right-left+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j= mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &lt; a[j])<br>            temp[k++] = a[i++];<br>        <span class="hljs-keyword">else</span><br>            temp[k++] = a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)<br>        temp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=right)<br>        temp[k++]= a[j++];<br>    <span class="hljs-comment">//将临时数组的元素复制到原数组</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        a[left++] = temp[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>快速排序是选择一个基准数，将大于基准数的元素放在基准数右边，小于基准数的元素放在基准数左边。这是基准数的位置就是有序的了；在分别对左右两个子序列进行同样操作，最后达到有序。</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot ）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/5.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快速排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> left 数组的左边界</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> right 数组的右边界</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>        <span class="hljs-comment">//找到基准数的有序下表</span><br>        <span class="hljs-keyword">int</span> mid = Partition(nums,left,right);<br>        <span class="hljs-comment">//将数组分为两部分，递归分区操作</span><br>        QuickSort(nums,left,mid-<span class="hljs-number">1</span>);<br>        QuickSort(nums,mid+<span class="hljs-number">1</span>,right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">//默认数组的第一个为基准数</span><br>    <span class="hljs-keyword">int</span> pivot = nums[left];<br>    <span class="hljs-keyword">int</span> i = left+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> j = right;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>        <span class="hljs-comment">//从左到右找到数组中大于基准数的值</span><br>        <span class="hljs-keyword">while</span>(i&lt;=j &amp;&amp; nums[i] &lt;= pivot)<br>            i++;<br>        <span class="hljs-comment">//从右向左找到数组中小于基准数的值</span><br>        <span class="hljs-keyword">while</span>(i&lt;=j &amp;&amp; nums[j] &gt;= pivot)<br>            j--;<br>        <span class="hljs-keyword">if</span>(i&gt;=j)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//交换这两个数，让&lt; 基准数的元素到基准数左边，&gt; 基准数的元素到基准数右边</span><br>        <span class="hljs-keyword">int</span> t = nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = t;<br>    &#125;<br>    <span class="hljs-comment">//将基准数放到中间，此时基准数位置有序</span><br>    nums[left] = nums[j];<br>    nums[j] = pivot;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>另外一种快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//随机选取基准数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-comment">//随机选取基准数</span><br>            <span class="hljs-keyword">int</span> randomIndex = <span class="hljs-keyword">new</span> Random().nextInt(right-left)+left+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//将基准数放在数组的首部</span><br>            swap(nums,left,randomIndex);<br>            <span class="hljs-keyword">int</span> mid = Partition(nums,left,right);<br>            QuickSort(nums,left,mid-<span class="hljs-number">1</span>);<br>            QuickSort(nums,mid+<span class="hljs-number">1</span>,right);<br>        &#125;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] a,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> pivot = left,index = left+<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//此时right是下标值，因此是&lt;=</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=index;i&lt;=right;i++)&#123;<br>        <span class="hljs-comment">//将小于基准数的元素放在前面来，index表示不小于基准数的第一个下标</span><br>        <span class="hljs-keyword">if</span>(a[i] &lt; a[pivot])&#123;<br>            swap(a,index,i);<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//index由于每次执行+1，所以最后一个小于基准数的是index-1</span><br>    swap(a,index-<span class="hljs-number">1</span>,pivot);<br>    <span class="hljs-keyword">return</span> index-<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//交换两个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] a,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = a[left];<br>    a[left] = a[right];<br>    a[right] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在选择基准数的时候，如果每次选取的都是当前子序列中的最小值或者最大值，那么经过一次遍历之后，其他元素的位置没有变化。那么就有点像选择排序，时间复杂度为O(n²)。当数组已经有序时，如果选择的不是随机基准数会出现这种情况。</strong></p>
]]></content>
  </entry>
</search>
