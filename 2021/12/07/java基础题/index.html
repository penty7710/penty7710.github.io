

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="题目：1、列举出四种及以上Java的容器类（即集合类）？Set、List、Queue、Map、ArrayList、HashSet、HashMap">
  <meta name="author" content="pty">
  <meta name="keywords" content="">
  
  <title>Java基础 - Pety&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"placement":"right"},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"follow_dnt":true}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Pety's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pety</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/message.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-07 22:37" pubdate>
        December 7, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      110
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java基础</h1>
            
            <div class="markdown-body">
              <p>题目：<br>1、列举出四种及以上Java的容器类（即集合类）？<br>Set、List、Queue、Map、ArrayList、HashSet、HashMap</p>
<a id="more"></a>


<p>2、简单说说Java事件处理由哪四部分组成？<br>Java事件由四部分组成：<br>事件源：产生事件的对象，例如：各个组件<br>事件对象：事件类<br>监听器：监听器接口(里面定义了响应事件的抽象方法)<br>“注册”：产生事件的对象，通过调用一个方法，通知“监听器”。</p>
<p>3、Java网络编程主要基于两个协议，是哪两个协议，其作用各是什么？（7分）<br>答：是TCP协议和UDP协议（1分）<br>    TCP协议：是面向连接的传输层协议。 进程（应用程序）在使用TCP协议之前，必须先建立连接，在数据传输完毕后要释放已建立的连接。（3分）<br>    UDP协议：是无连接的传输层协议。进程（应用程序）使用UDP无须建立连接，当然，数据传输结束时也没有连接需要释放。因此，用UDP能减少开销和发送数据之前的时延。（3分）</p>
<p>4、X公司承接了一个软件项目，目前正在做可行性分析。项目经理偏向于采用Java语言开发此项目，但有少数员工提出也可以用其他语言开发如C++或C#等，为统一思想。项目经理委托小张收集数据，并给大家分析下Java的特点或优势。（请列举Java的特点至少6点，并简单进行分析说明）<br>答：简单、面向对象、支持分布式(即网络功能)、健壮性（少出低级错误）、安全（被破解的可能性）、体系结构中立（跨平台）、可移植性、解释执行、高性能、多线程、动态</p>
<p>5、Java相对于C、C++语言，更适合应用型软件的开发，这主要是Java语言本身就相对C++语言作出了一些变化，请分析出至少Java相对C++语言在语法上6个及更多的不同点。<br>答：1）全局变量：Java中没有全局变量。2）指针：Java不支持指针，但对象变量实际上都是指针。3）数据类型的支持：Java在不同平台上数据类型都统一。4）类型转换：Java有类型相容性检查。5）结构和联合：Java只支持类。6）多重继承：Java用接口实现类似多重继承的功能。7）内存管理：Java自动回收无用内存。8）头文件：Java支持包引入import。9）宏定义和预处理：Java不支持宏定义。</p>
<p>6、什么是JDBC，在什么时候会用到它？<br>答、JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<p>7、列举出任意四个JDBC连接数据库相关的Java类？<br>答：DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等</p>
<p>8、JDBC操作数据库的步骤？<br>答：注册数据库驱动。<br>建立数据库连接。<br>操作数据库：包括创建一个Statement，执行SQL语句，处理结果集等。<br>关闭数据库连接</p>
<p>9、有哪些不同类型的JDBC驱动，每种驱动的特点是什么？<br>答：有四类JDBC驱动。<br>1） JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。<br>2） Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。<br>3） Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。<br>4） Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。</p>
<p>10、JDBC是如何实现Java程序和JDBC驱动的松耦合的？<br>答：JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。在这里可以看到更多JDBC的使用示例。</p>
<p>11、JDBC的DriverManager是用来做什么的？<br>答：JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p>
<p>=======================================================<br>论述题：</p>
<p>对Java中JDBC的分析和理解？<br>   （1、可以从JDBC的含义；JDBC连接数据库相关的常用Java类；当前主要使用哪种类型的JDBC驱动；JDBC是如何实现Java程序和JDBC驱动的松耦合的；JDBC的DriverManager是用来做什么的；JDBC的DriverManager的理解等等角度进行分析（但不限于这些角度）<br>     2、能正确答出3个及以上点，且字数超过200字，则得满分<br>    ）。<br>答：<br>  1、JDBC的含义<br>  JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<p>  2、JDBC连接数据库相关的常用Java类包括（列举4个及以上，并可以简单说说列举的类的作用或含义）：<br>  DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等  </p>
<p>  3、主要使用的JDBC驱动类型<br>  Direct-to-Database Pure Java Driver：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQLConnector/J是MySQL数据库的驱动。</p>
<p>  4、JDBC如何实现Java程序和JDBC驱动的松耦合的<br>JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。</p>
<p>  5、JDBC的DriverManager<br>JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager. getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p>
<p>=======================================================</p>
<p>12、在Java程序中，如何获取数据库服务器的相关信息？<br>答：使用DatabaseMetaData可以获取到服务器的信息。当和数据库的连接成功建立了之后，可以通过调用getMetaData()方法来获取数据库的元信息。DatabaseMetaData里面有很多方法，通过它们可以获取到数据库的产品名称，版本号，配置信息等。相关代码为：<br>DatabaseMetaData metaData = con.getMetaData();<br>String dbProduct = metaData.getDatabaseProductName();</p>
<p>13、JDBC的Statement是什么？<br>答：Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法我们可以生成一个Statement对象。我们可以通过调用它的execute()，executeQuery()，executeUpdate()方法来执行静态SQL查询。由于SQL语句是程序中传入的，如果没有对用户输入进行校验的话可能会引起SQL注入的问题。<br>另外，默认情况下，一个Statement同时只能打开一个ResultSet。如果想操作多个ResultSet对象的话，需要创建多个Statement。Statement接口的所有execute方法开始执行时都默认会关闭当前打开的ResultSet。</p>
<p>14、execute，executeQuery，executeUpdate的区别是什么？<br>答：1）execute方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。<br>2）executeQuery方法用来执行查询(select)，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。<br>3）executeUpdate方法用来执行添删改操作，即insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。<br>4）只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p>
<p>15、JDBC的PreparedStatement是什么？<br>答：PreparedStatement对象代表的是一个预编译的SQL语句。用它提供的setter方法可以传入查询的变量。<br>由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。由于PreparedStatement自动对特殊字符转义，避免了SQL注入攻击，因此应当尽量的使用它。</p>
<p>16、PreparedStatement中如何注入NULL值？<br>答：可以使用它的setNull方法来把null值绑定到指定的变量上。setNull方法需要传入参数的索引以及SQL字段的类型，像这样：<br>ps.setNull(10, java.sql.Types.INTEGER);.</p>
<p>17、Statement中的getGeneratedKeys方法有什么用？<br>答：有的时候表会生成主键，这时候就可以用Statement的getGeneratedKeys()方法来获取这个自动生成的主键的值了。</p>
<p>18、相对于Statement，PreparedStatement的优点是什么？<br>答：它和Statement相比优点在于：<br>1）PreparedStatement有助于防止SQL注入，因为它会自动对特殊字符转义。<br>2）PreparedStatement可以用来进行动态查询。<br>3）PreparedStatement执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。<br>4）使用PreparedStatement的setter方法更容易写出面向对象的代码，而Statement的话，我们得拼接字符串来生成查询语句。如果参数太多了，字符串拼接看起来会非常难看并且容易出错。</p>
<p>19、JDBC中大数据量的分页解决方法?<br>答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。<br>mysql语法：<br>    SELECT *<br>    FROM 表名<br>    LIMIT [START], length;<br>oracle语法：<br>    SELECT *FROM (<br>        SELECT 列名,列名,ROWNUM rn<br>        FROM 表名<br>        WHERE ROWNUM&lt;=(currentPage*lineSize)) temp<br>    WHERE temp.rn&gt;(currentPage-1)*lineSize;</p>
<p>简答和分析题集</p>
<p>20 java中有几种类型的流?JDK为每种类型的流提供了一些抽象类以提供继承，请说出他们分别是哪些类？<br>答：<br>（1）字节流，字符流。<br>（2）字节流继承于InputStream，OutputStream。<br>（3）字符流继承于Reader Writer。</p>
<p>21 使用处理流的优势有哪些？如何识别所使用的流是处理流还是节点流？<br>答：<br>优势：对开发人员来说，使用处理流进行输入/输出操作更简单。使用处理流的执行效率更高。<br>识别：处理流的构造器的参数不是一个物理节点，而是已经存在的流。而节点流都是直接以物理 IO 及节点作为构造器参数的。</p>
<p>22 什么是标准的IO流？<br>答：在java语言中用stdin表示键盘，用stdout表示监视器。它们被封装在System类的类变量 in 和 out 中，对应系统调用System,in 和 System,out。这样的两个流加上System.err统称为标准流。<br>System类中声明的3个类变量：<br>（1）public static InputStream in;<br>（2）public static PrinStream out;<br>（3）public static PriStram err;</p>
<p>23  什么能被序列化？什么不能被序列化？<br>答：<br>能被序列化：<br>（1）属性<br>（2）类型；<br>不能被序列化：<br>（1）static的属性；<br>（2）方法，<br>（3）加了transient修饰符的属性。</p>
<p>24 什么是java序列化，如何实现java序列化？<br>答：<br>（1）序列化而就是一种处理对象流的机制，所谓对象流也就是对象的内容进行流化。<br>（2）实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputSream对象，接着使用ObjectOutputSream对象的writeObject方法就可以将参数obj对象写出，要恢复的话则使用输入流。</p>
<p>1.抽象：<br>　答：<br>  抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p>2.继承：<br>　答：<br>  继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>
<p>3.封装：<br>　答：<br>   封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<ol start="4">
<li>多态性：<br> 答：<br> 　多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li>
</ol>
<p>5、String是最基本的数据类型吗?<br>　答：<br>  基本数据类型有8个，包括byte、short、int、long、char、float、double和boolean。<br>　java.lang.String是类，不属于基本数据类型。</p>
<p>6、int 和 Integer 有什么区别<br>　Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。</p>
<p>小张到X软件公司实习，第一天程序员老李为摸底，问了他一个问题：Java中的有8个基本数据类型，这破坏了面向对象的思想，为此Java提供了封装类，那么这些封装类具体有哪些？请代小张回答（至少回答出其中六个即可得满分）</p>
<p>Java为每个原始类型提供了封装类。<br>原始类型       封装类<br>boolean      Boolean<br>char          Character<br>byte          Byte<br>short          Short<br>int          Integer<br>long          Long<br>float          Float<br>double      Double<br>　引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p>
<p>7、实习程序员小张，接到X项目组经理命令完成某模块代码开发。在设计中，该模块算法中特别提到将有大量字符串的拼接。编码过程中，小张准备使用自己熟悉的String对象类完成这段代码，并向程序员老王征求意见，谁知老王否定了小张用String类型的方案，并建议他此处使用StringBuffer对象更合适，这令小张有些困惑。请帮小张分析下为何此处要用StringBuffer？<br>  即回答：String 和StringBuffer的区别<br>　答：<br>  JAVA平台提供了两个类：String和StringBuffer。<br>  String不是简单类型，而是一个类，它被用来表示字符序列。String的特点是一旦赋值，便不能更改其指向的字符对象，如果更改，则会生成一个新的字符串对象。<br>  StringBuffer是一个具有对象引用传递特点的字符串对象。StringBuffer对象可以调用其方法动态的进行增加、插入、修改和删除操作，从而实现多次插入字符，而不用担心像String类那样不断产生新对象而消耗内存，因而在字符串变化较多的操作中，效率更高。</p>
<p>9、&amp;和&amp;&amp;的区别。<br>   答： &amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p>
<p>10、final, finally的区别。<br>　　答：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改（相当于常量）。被声明为final的方法也同样只能使用，不能覆盖。<br>    finally是异常处理语句结构的一部分，表示总是执行。一般在异常处理时提供 finally 块来执行任何清除操作。</p>
<p>11、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?<br>　  答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<p>12、error和exception有什么区别?<br>　 答：error 表示恢复不是不可能但很困难的情况下的一种严重问题，是一种系统性的错误，程序本身不能处理这样的情况，比如说内存溢出。<br>      exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，是不会发生这种错误的。</p>
<p>13、abstract class和interface有什么区别?<br>　  答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。     Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>　   接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<p>14、GC是什么? 为什么要有GC?<br>　　答：1）GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或错误的内存回收会导致程序或系统的不稳定，甚至崩溃；2）Java提供的垃圾回收机制（GC）可以自动监测对象是否超过作用域从而达到自动回收内存的目的；3）Java不提供显示释放已分配内存的操作方法。</p>
<p>15、分析题<br>    1）short s1 = 1; s1 = s1 + 1;有什么错?<br>    答：short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，int数据1给short型变量s1，需要强制转换类型）<br>    2）short s1 = 1; s1 += 1;有什么错?<br>    答：本题无措short s1 = 1; s1 += 1;（可以正确编译）</p>
<p>16、分析题：Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>    答：Math.round(11.5)==12<br>        Math.round(-11.5)==-11<br>        round方法返回与参数最接近的长整数，参数加1/2后求其floor.</p>
<p>17、String s = new String(“xyz”);创建了几个String Object?<br>    答：两个对象，一个是在字符串池中的对象“xyx”,引用对象s指向的堆空间的对象“xyx”。其中，堆空间的对象“xyz”是字符串池中字符串“xyz”的副本。    </p>
<p>18、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?<br>　  答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。</p>
<p>19、数组有没有length()这个方法? String有没有length()这个方法？<br>　  答：数组没有length()这个方法，只有length的属性，用来得到数组元素个数。<br>        String有length()这个方法，用来得到字符串长度。</p>
<p>20、构造器Constructor是否可被override?<br>　  答：构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。</p>
<p>21、是否可以继承String类?<br>　  答：String类是final类，故不可以继承。</p>
<p>22、swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?<br>　  答：switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。<br>       long,string 都不能作用于swtich。</p>
<p>23、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?<br>　  答：会执行，在return前执行。</p>
<p>24、编程题: 用最有效率的方法算出2乘以8等於几?<br>    答：用位运算符“&lt;&lt;”，语句写为：2 &lt;&lt; 3;</p>
<p>25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>　  答：<br>    是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p>
<p>26、Java中的异常处理机制的简单原理和应用。<br>　   答：<br>     当JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。</p>
<p>27、描述一下JVM加载class文件的原理机制?<br>　  答：JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<p>28、char型变量中能不能存贮一个中文汉字?为什么?<br>　  答：能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的</p>
<p>29、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?<br>    答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>    同步的实现方面有两种，分别是synchronized,wait与notify</p>
<p>30、线程的基本概念、线程的基本状态以及状态之间的关系<br>　 答：<br>   线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。<br>   Java中的线程有四种状态分别是：运行、就绪、挂起、结束。 </p>
<p>=============================================<br>论述题<br>31、谈谈对Java语言中异常处理的理解？（<br>    1）可以从异常处理包含哪些关键字；每个关键字的含义或作用；引用异常处理后对开发有哪些帮助；异常处理机制的类体系结构；异常处理实现的底层机制等角度进行分析（但不限于这些角度）；<br>    2）能正确答出3个及以上点，且字数超过200字，则得满分。答案仅供参考，不唯一<br>   ）<br>    答：<br>    1、基本概念<br>    Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p>
<pre><code>2、5个主要关键字的作用
用try来指定一块预防所有&quot;异常&quot;的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的&quot;异常&quot;的类型。
finally为确保一段代码不管发生什么&quot;异常&quot;都被执行一段代码。
throw语句用来明确地抛出一个&quot;异常&quot;。
throws用来标明一个成员函数可能抛出的各种&quot;异常&quot;。

3、实现的机制
Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。
4、采用异常处理机制的好处
可以提高Java语言的处理错误能力；可以帮助程序员调试程序，发现开发中的问题，提高开发效率；可以让Java程序有健壮性，程序不容易崩溃；</code></pre>
<p>===========================================================</p>
<p>32、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>   答：1）可以。<br>       2）只有一个类的类名能与Java程序的该源文件名相同。</p>
<p>33、java中实现多态的机制是什么（Java借助什么实现多态性）？<br>　 答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。<br>      重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。</p>
<p>34、在JAVA中，如何跳出当前的多重嵌套循环？<br>    答：用break; return 方法。</p>
<p>35、Java是从（  B  ）语言改进重新设计而发展来的？<br>A. Ada    B. C++    C.Pascal  D.BASIC<br>分析：Java是从C、C++发展过来的</p>
<p>36、研究下面Java代码<br>public class TestException{<br>    public static void main(String args[]){<br>        try{<br>            System.out.println(“hello,jr”);<br>            System.exit(0);<br>        }finally{<br>            System.out.println(“88”);<br>        }<br>    }<br>}<br>输出结果为：（  A  ）<br>A. hello,jr<br>B. 88<br>C. hello,jr后是88<br>D. 不能编译<br>分析：System.exit(0);会中断程序，即使是finally都无法被执行</p>
<p>37、下面说法正确的有（  C   ）<br>A. class中的contructor不可省略<br>B. contructor必须与class同名，但方法不能与class同名<br>C. contructor在一个对象被new时执行<br>D. 一个class只能定义一个contructor</p>
<p>分析：contructor就是指的构造方法，普通方法也可以和类同名</p>
<p>38、在java中，已定义两个接口B和C，要定义一个实现这两个接口的类，以下语句正确的是（  C  ）<br>A. interface A extends B,C<br>B. interface A implements B,C<br>C. class A implements B,C<br>D. class A implements B,implements C</p>
<p>分析：类实现接口的基本语法</p>
<p>39、当编译并允许下面程序时，会发生什么结果？（   D   ）<br>public class Demo{<br>    protected Demo(){<br>        for(int i=0;i&lt;10;i++){<br>            System.out.println(i);<br>        }<br>    }</p>
<pre><code>public static void main(String args[])&#123;
    Demo d=new Demo();
&#125;</code></pre>
<p>}<br>A. 编译错误，构造方法不能被声明为protected<br>B. 允许错误，构造方法不能被声明为protected<br>C. 编译并运行输出0到10<br>D. 编译并运行输出0到9</p>
<p>分析：本题程序无错误可正常运行，构造方法是可以定义为protected的。</p>
<p>40、当编译和运行下面程序时，哪项描述可以最准确的表达发生了什么事情（   B    ）<br>public class MyAr{</p>
<pre><code>public void amethod()&#123;
    int i;
    System.out.println(i);    
&#125;

public static void main(String args[])&#123;
    MyAr m=new MyAr();
    m.amethod();
&#125;</code></pre>
<p>}<br>A. 编译并输出0<br>B. 编译错误<br>C. 编译并输出null<br>D. 运行错误</p>
<p>分析： 方法amethod()中定义的变量：int i; 是一个方法级别的变量，必须手动赋予初值，否则编译错误。<br>       注意：成员变量系统给默认值，如果不显示手动赋值，依然是正确的。</p>
<p>41、给定java代码如下，关于super的用法，以下描述正确的是（    C   ）<br>class C extends B{<br>    public C(){<br>        super();<br>    }<br>}<br>A. 用来调用类B中定义的super()方法<br>B. 用来调用类C中定义的super()方法<br>C. 用来调用类B中的无参构造方法<br>D. 用来调用类B中第一个出现的构造方法</p>
<p>分析：super()的含义是用来调用父类（B）中不带参数的构造方法。super()的用法，一般出现在子类构造方法中第一行。</p>
<p>42、下列语句正确的是（   A  ）<br>A) 形式参数可被视为local variable<br>B) 形式参数可被字段修饰符修饰<br>C) 形式参数为方法被调用时，真正被传递的参数<br>D) 形式参数不可以是对象</p>
<p>分析：B项无此说法，C中被真正传递的是实参，D中形参可以使对象</p>
<p>43、以下代码输出结果为（  C    ）<br>public class Test{<br>    public static String output=””;</p>
<pre><code>public static void foo(int i)&#123;
    try&#123;
        if(i==1)
            throw new Exception();

        output+=&quot;1&quot;;            
    &#125;catch(Exception e)&#123;
        output+=&quot;2&quot;;
        return ;
    &#125;finally&#123;
        output+=&quot;3&quot;;
        output+=&quot;4&quot;;
    &#125;
&#125;

public static void main(String args[])&#123;
    foo(0);
    foo(1);
    System.out.println(output);
&#125;</code></pre>
<p>}<br>A. 1342        B. 123        C. 134234    D. 13423</p>
<p>分析：本题中，foo(0)时，if语句if(i==1)throw new Exception();不满足条件，不会抛出异常，因此此时output值为“134”；<br>      紧接着执行foo(1)时，if语句if(i==1)throw new Exception();满足条件，抛出异常，执行catch语句，output值变成“1342”；<br>      最难点在于此时碰到了return，是否还会执行finally语句，答案是会执行，因此最后output值变成“134234”；答案为C。</p>
<p>44、在Java中，下列（  D    ）类不能派生出子类？<br>A) public class MyClass{ … }<br>B) class MyClass{ … }<br>C) abstract class MyClass{ … }<br>D) final class MyClass{    … }</p>
<p>分析：类前面可以有public和默认两种权限，一般都能被子类继承，因此A、B答案可以派生子类<br>      C答案是抽象类，也可以被继承<br>      D答案是final修饰的类，是最终类，不允许被继承。</p>
<p>45、编译和运行下面代码时显示结果是（     ）<br>public class Conv{<br>    public static void main(String argv[]){<br>            Conv c=new Conv();<br>            String s=new String(“ello”);<br>            c.amethod(s);<br>    }<br>    public void amethod(String s){<br>            char c=’H’;<br>            c+=s;<br>            System.out.println(c);<br>    }<br>}<br>A、Hello<br>B、ello<br>C、elloH<br>D、编译错误<br>解答：D<br>分析：c是字符类型，s是字符串类型，字符型无法自动转换成字符串类型，因此语句c+=s;类型不兼容，有语法错误，故答案是D<br>修改方案：将char c=’H’;语句变为String c=”H”;</p>
<p>46、当下列程序执行时，其输出结果是（     ）。<br>int i=9;<br>switch (i) {<br> default:<br> System.out.println(“default”);<br> case 0:<br> System.out.println(“zero”);<br> break;<br> case 1:<br> System.out.println(“one”);<br> case 2:<br> System.out.println(“two”);<br>}<br>A、default<br>B、default, zero<br>C、错误： default 子句没有定义<br>D、没有输出结果<br>解答：Ｂ<br>原因：程序开始遇到default关键字，会执行其语句块中语句，输出“default”；<br>由于default语句块中没有结束switch语句的关键字break;<br>所以程序会继续执行其他case块中语句，并且无需验证case的值匹配；运行到case 0语句块时，首先输出“zero”，最后碰到break语句，结束整个switch语句块。<br>故最后输出结果：<br>default<br>zero</p>
<p>47、阅读下列代码，其正确的结果是（     ）。<br>publicclass Test2 {<br>    static boolean foo(char c) {<br>       System.out.print(c);<br>       return true;<br>    }<br>    Public static void main(String[] argv) {<br>       int i = 0;<br>       //for(65;88&amp;&amp;(i&lt;2);67)<br>       for (foo(‘A’); foo(‘B’) &amp;&amp; (i &lt; 2); foo(‘C’)) {<br>           i++;<br>           foo(‘D’);<br>       }<br>    }<br>}<br>A. ABDCBDCB<br>B. ABCDABCD<br>C. Compilation fails.<br>D. An exception is thrown at runtimeB、1<br>解答：A</p>
<p>48、有以下程序段：<br>class MyThread extends Thread {<br>    public static void main(String args[]) {<br>        MyThread t = new MyThread();<br>        MyThread s = new MyThread();<br>        t.start();<br>        System.out.print(“one.”);<br>        s.start();<br>        System.out.print(“two.”);<br>    }<br>    public void run() {<br>        System.out.print(“Thread”);<br>    }<br>}<br>则下列选项说法正确的是（     ）。<br>A、编译失败<br>B、程序运行结果为：one.Threadtwo.Thread<br>C、程序运行结果是：one.two.ThreaThread<br>D、程序运行结果不确定<br>解答：D<br>分析：线程是并行运行，故结果输出顺序是不确定。<br>部分同学计算机运行几次时，可能会发现结果确定，<br>是因计算机速度太快导致，可以多次运行十几次或几十次，可以发现结果有变化</p>
<p>49、仔细分析下面程序，其正确的输出结果是（     ）。<br>publicclass Test1 {<br>    public static void changeStr(String str){   //②str<br>        str=”welcome”;<br>    }<br>    public staticvoid main(String[] args) {<br>        String str=”1234”;               //①str<br>        changeStr(str);<br>        System.out.println(str);<br>    }<br>}<br>A、welcome<br>B、welcome1234<br>C、1234<br>D、1234welcome<br>解答：C</p>
<p>分析：<br>1）主方法中的①号变量str是实际参数，changeStr(String str)中的②号str是形式参数，虽然是两个同名字变量，但实际是两个变量。</p>
<p>2）Java字符串基于字符串池实现，虽然①号str传值给了②号str，并且传的是引用，<br>   但②号str中执行语句str=”welcome”;后，并没有修改”1234”这个值本身，而是在字符串池中，新增加了一个字符串常量”welcome”，<br>   ②号str的引用指向了新的”welcome”值，但①号str指向的值”1234”没有被修改，因此主方法中打印输出的①号str的值还是1234</p>
<p>3）这里要注意，正常情况下，给方法的参数传值，当值是对象类型时，是引用传递。（若是基本数据类型，则是值传递）<br>   引用传递的确是可以利用方法来修改引用指向对的成员变量值的，字符串类（String）因其实现的机制是基于字符串池，故情况特殊<br>   参见下面代码对比：</p>
<p>class Stu{<br>    int stuAge;<br>}<br>public class Test1 {<br>    public static void changeStu(Stu stu){<br>        stu.stuAge=100;<br>    }<br>    public static void changeStr(String str){<br>        str=”welcome”;<br>    }<br>    public static void main(String[] args) {<br>        String str=”1234”;<br>        changeStr(str);               //Java字符串基于字符串池实现，因此不是简单的传递引用<br>        System.out.println(str);<br>//        Stu s=new Stu();<br>//        s.stuAge=20;<br>//        changeStu(s);                //对象类型传的是引用<br>//        System.out.println(s.stuAge);//输出100<br>    }<br>}  </p>
<p>50、下面2个文件位于相同目录下，编译运行后会出现的情况是（      ）。<br>//File P1.java<br>package MyPackage;<br>class P1{<br>void afancymethod(){<br>        System.out.println(“What a fancy method”);<br>        }<br>}<br>//File P2.java<br>public class P2 extends P1{<br>    public static void main(String argv[]){<br>    P2 p2 = new P2();<br>    p2.afancymethod();<br>    }<br>}<br>A、2个文件都可以编译，P2运行输出“What a fancy method”<br>B、2个文件都不能编译<br>C、2个文件都可以编译，P2运行时报错误<br>D、P1编译成功，P2编译时报错误<br>解答：D</p>
<p>51、编译和运行下面代码时显示的结果是（     ）。<br>public class MyClass{<br> static int i;<br> public static void main(String argv[]){<br>     System.out.println(i);<br> }<br>}<br>A、Error Variable i may not have been initializenull<br>C、1<br>D、0<br>解答：D<br>分析：本题能正常运行，static int i;中定义的i是静态成员变量，Java中成员变量默认给了初值，整型的初值是0，故此题正确</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/29/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">linux常用命令</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/22/fastapi%E5%A4%9A%E6%96%87%E4%BB%B6/">
                        <span class="hidden-mobile">fastapi多文件</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js" ></script>



  <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>



  <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
